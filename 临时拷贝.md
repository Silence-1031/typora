- 

##

|      |      |      |      |
| ---- | ---- | ---- | ---- |
|      |      |      |      |
|      |      |      |      |

## 五、

## 六、核心结论与实践建议

1. **理解调用是优化的前提**：只有明确 “对象操作背后调用了哪些函数”，才能针对性减少冗余调用（如用 const 引用传参替代值传递，避免拷贝构造）。
2. **善用编译器优化**：优先用 “临时对象构造新对象”（如`Test t = 10;`），触发优化减少调用；避免 “先定义对象再赋值”（如`Test t; t = 10;`），避免冗余临时对象。
3. **规避安全风险**：禁止用指针绑定临时对象；用引用绑定临时对象时，必须加`const`（兼容编译器规则，延长生命周期）。
4. **析构匹配原则**：`new`对应`delete`，`new[]`对应`delete[]`；全局 / 静态对象无需手动释放，避免 double free。









# 视频知识点详细总结





本视频围绕 C++ 中类对象在函数调用过程中的核心机制展开，以`test`类为实例，通过代码分析和运行验证，重点讲解对象构造、析构、拷贝构造、赋值运算符重载的调用逻辑，为后续对象优化奠定基础。

## 一、回顾基础：对象的 4 个核心成员函数

视频开篇回顾上节课核心内容，强调**任何 C++ 对象的生命周期中，都会涉及 4 个最基本的成员函数**，是理解对象内存行为的关键：

1. **构造函数**：对象创建时初始化成员变量，决定对象 “如何诞生”；
2. **析构函数**：对象销毁时释放资源（如堆内存），决定对象 “如何消亡”；
3. **拷贝构造函数**：用已存在的对象初始化新对象（如`Test t2 = t1`），本质是 “对象的复制初始化”；
4. **赋值运算符重载函数**：两个已存在的对象之间赋值（如`t2 = t1`），本质是 “对象的内容覆盖”。

视频特别提醒

## 二、实例类`test`的结构设计

为直观观察函数调用过程，视频定义了`test`类并添加打印逻辑，类结构如下：

| 成员 / 函数                                    | 功能说明                                                     |
| ---------------------------------------------- | ------------------------------------------------------------ |
| 私有成员`int ma`                               | 存储对象核心数据，外部无法直接访问                           |
| 构造函数`Test(int data=10)`                    | 带默认参数的构造函数： - 无实参时用默认值 10 初始化`ma`； - 有实参时用实参初始化`ma`； - 打印 “构造函数调用” 信息。 |
| 析构函数`~Test()`                              | 对象销毁时调用，打印 “析构函数调用” 信息                     |
| 拷贝构造函数`Test(const Test& t)`              | 用已有`test`对象`t`初始化新对象，通过初始化列表`ma(t.ma)`赋值，打印 “拷贝构造调用” 信息。 |
| 赋值运算符重载`Test& operator=(const Test& t)` | 给已存在的对象赋值： - 浅拷贝（因无外部资源，无内存安全问题）； - 打印 “赋值运算符重载调用” 信息。 |
| 公有方法`int getData()`                        | 提供外部访问`ma`的接口，返回`ma`的值（封装性体现）           |

## 三、关键函数`getObject`的逻辑与风险提示

视频定义了函数`getObject(Test t)`，用于演示 “对象作为函数参数 / 返回值” 时的行为，同时强调内存安全风险：

### 1. `getObject`函数实现

cpp







```cpp
Test getObject(Test t) {
    int value = t.getData();  // 取形参t的ma值
    Test tmp(value);          // 用value构造局部对象tmp
    return tmp;               // 返回局部对象tmp
}
```



## 四、对象在函数调用中的完整调用流程（核心重点）

视频以`main`函数中 “`Test t1; Test t2 = getObject(t1);`” 为例，拆解从代码执行到对象销毁的**11 次函数调用**，明确每一步的触发逻辑和顺序：

| 步骤 | 函数调用类型   | 触发场景                                                     | 涉及对象                     |
| ---- | -------------- | ------------------------------------------------------------ | ---------------------------- |
| 1    | 构造函数       | `Test t1;`：创建`t1`，无实参→用默认值 10 构造                | `t1`（main 函数局部对象）    |
| 2    | 拷贝构造函数   | `getObject(t1)`：实参`t1`传递给形参`t`（函数参数传递是 “初始化”，非赋值） | 形参`t`（用`t1`初始化）      |
| 3    | 构造函数       | `Test tmp(value);`：在`getObject`内构造局部对象`tmp`         | `tmp`（`getObject`局部对象） |
| 4    | 拷贝构造函数   | `return tmp;`：`tmp`是局部对象，无法直接返回→在`main`栈上构造 “临时对象”，用`tmp`初始化 | 临时对象（`main`栈上）       |
| 5    | 析构函数       | `getObject`执行结束：局部对象`tmp`先销毁（栈内存 “后进先出”） | `tmp`                        |
| 6    | 析构函数       | `getObject`执行结束：形参`t`后销毁                           | 形参`t`                      |
| 7    | 赋值运算符重载 | `Test t2 = 临时对象;`：用`main`栈上的临时对象给`t2`赋值（`t2`已创建，触发赋值而非初始化） | `t2`与临时对象               |
| 8    | 析构函数       | 赋值语句结束：临时对象完成使命，销毁（临时对象生命周期仅当前语句） | 临时对象                     |
| 9    | 析构函数       | `main`函数结束：`t2`先销毁（栈 “后进先出”）                  | `t2`                         |
| 10   | 析构函数       | `main`函数结束：`t1`后销毁                                   | `t1`                         |

> 注：视频中最终统计为 11 次调用，核心原因是 “`t2`的创建是否触发默认构造”—— 若`Test t2;`先默认构造（步骤 1），再赋值（步骤 7），则总次数为 11 次，本质逻辑一致。

## 五、视频核心目标与后续铺垫

1. **核心目标**：让学习者 “看透对象背后的函数调用”—— 即使是简单的几行代码，也可能触发多次构造 / 析构，只有明确调用逻辑，才能后续优化（如减少不必要的拷贝、避免内存浪费）；
2. **后续铺垫**：本视频为 “对象优化” 打基础，后续会讲解如何通过 “传引用参数”“返回值优化（RVO）” 等方式，减少拷贝构造和析构的调用次数，提升程序效率。





# 视频知识点详细总结：C++ 对象优化三大核心规则

视频围绕 C++ 面向对象编程（OOP）中 “对象调用的函数开销优化” 展开，通过对比优化前后的函数调用次数（从 11 次缩减至 4 次），核心总结了 3 条对象优化规则，同时解释了底层原理与编译器优化逻辑，以下是详细拆解：

## 一、核心背景：对象调用的 “隐形开销”

在未优化的 C++ 代码中，对象的**构造、拷贝构造、析构**会产生大量 “隐形函数调用”，每一次调用都有栈帧创建 / 销毁的开销，导致代码效率下降。视频以 “Test 类对象的函数传参、返回、接收” 为案例，先明确未优化时的问题：

- 未优化前，完成相同功能需 11 次函数调用（含多次拷贝构造和析构）；
- 优化的核心目标：**减少不必要的拷贝构造和析构调用**，利用引用、临时对象、初始化等特性降低开销。

## 二、

## 

## 四、实战价值：面试与开发的应用

1. **面试考点**：视频明确提到，笔试 / 面试常考 “给定类代码，分析构造 / 析构 / 拷贝构造的调用顺序”，掌握这 3 条规则可快速准确解题；
2. **开发规范**：写 OOP 代码时，需养成 “传引用、返临时对象、初始化接收” 的习惯，尤其在高频调用的函数（如循环、容器操作）中，优化效果会被放大；
3. **效率对比**：未优化时 11 次调用，优化后 4 次调用，单次调用少 7 次开销，多次调用下效率提升显著（解决 “C++ 效率不如 C” 的常见误区）。

## 五、总结：优化规则速记表

| 场景               | 未优化方式         | 优化方式            | 减少的开销                        |
| ------------------ | ------------------ | ------------------- | --------------------------------- |
| 函数参数传递对象   | 值传递（Test t）   | 引用传递（Test& t） | 形参的拷贝构造 + 析构（2 次）     |
| 函数返回对象       | 返回已定义局部对象 | 返回临时对象        | 局部对象的拷贝构造 + 析构（2 次） |
| 接收函数返回的对象 | 先定义再赋值       | 初始化方式接收      | 临时对象的构造 + 析构（2 次）     |

最终目标：通过 3 条规则，将对象调用的 “隐形开销” 降至最低，兼顾代码可读性与运行效率。

# C++ 智能指针视频知识点详细总结

该视频来自哔哩哔哩 “基础知识_ev” 课程，属于 “C++ 开发工程师高级进阶课程” 的一部分，核心围绕 C++ 智能指针展开，结合原理、实现、使用场景及面试考点，系统讲解智能指针相关知识，以下是具体知识点梳理：

## 一、智能指针的核心背景：解决裸指针的痛点

视频开篇通过对比 “裸指针” 与 “智能指针”，明确智能指针的设计初衷，这是理解智能指针的基础：

1. 


1. - 

## 三、智能指针的分类与核心类型

视频明确将智能指针按 “是否带引用计数” 分为两类，分别讲解其适用场景（标准库中的核心类型）：

| 分类                   | 包含的智能指针类型                         | 核心特点                                                     |
| ---------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 不带引用计数的智能指针 | auto_ptr（已废弃）、scoped_ptr、unique_ptr | 独占资源所有权，同一时间只有一个智能指针能管理资源，不允许拷贝 / 赋值（或限制拷贝） |
| 带引用计数的智能指针   | shared_ptr、weak_ptr                       | shared_ptr 共享资源所有权（引用计数记录使用者数量，计数为 0 时释放资源）；weak_ptr 辅助解决循环引用 |

1. **不带引用计数的智能指针**

   - **auto_ptr**：C++98 中的早期类型，存在 “拷贝后原指针失效” 的问题（如`auto_ptr<int> p1(new int(10)); auto_ptr<int> p2 = p1;`后，p1 为空、p2 拥有资源），容易导致野指针，**C++11 后已废弃**，不推荐使用。
   - **scoped_ptr**：Boost 库中的类型（C++ 标准库无，但思想被 unique_ptr 借鉴），核心是 “禁止拷贝和赋值”（私有拷贝构造和赋值运算符），确保资源只能被当前智能指针独占，避免所有权转移的问题。
   - **unique_ptr**：C++11 标准库推荐的 “独占型智能指针”，优化了 auto_ptr 的缺陷 —— 通过 “移动语义”（`std::move`）实现所有权转移，不允许隐式拷贝，仅允许显式转移所有权（如`unique_ptr<int> p2 = std::move(p1);`），安全性更高，是裸指针的首选替代（无共享需求时）。

2. **带引用计数的智能指针**

   - shared_ptr

     ：“共享型智能指针”，核心是通过 “引用计数”（一个额外的计数器，记录当前管理该资源的 shared_ptr 数量）实现资源共享：

     - 当新的 shared_ptr 指向同一资源时，引用计数 + 1；
     - 当 shared_ptr 出作用域（析构）时，引用计数 - 1；
     - 引用计数减至 0 时，自动释放资源。

   - **weak_ptr**：辅助 shared_ptr 的 “弱引用智能指针”，**不增加引用计数**，仅用于观察 shared_ptr 管理的资源 —— 解决 shared_ptr 的 “循环引用” 问题（视频后续重点提及的面试考点），无法直接访问资源，需通过`lock()`方法转为 shared_ptr 后再访问。

## 四、智能指针的关键面试考点与问题解决

视频明确指出智能指针是校招面试的高频考点，重点讲解 2 个核心问题及解决方案：

1. **循环引用（交叉引用）问题**
   - **问题场景**：两个 shared_ptr 互相指向对方，导致引用计数无法减至 0，资源无法释放（如 A 类有 shared_ptr<B> b; B 类有 shared_ptr<A> a; 当两个对象的外部 shared_ptr 析构后，a 和 b 的引用计数仍为 1，内存泄漏）。
   - **解决方案**：将其中一个 shared_ptr 改为 weak_ptr——weak_ptr 不增加引用计数，打破循环，当外部 shared_ptr 析构后，引用计数可减至 0，资源正常释放。
2. **多线程访问共享对象的线程安全问题**
   - **问题场景**：多个线程同时操作 shared_ptr 管理的共享资源（如同时修改资源数据、或同时拷贝 shared_ptr）——shared_ptr 的 “引用计数” 本身是线程安全的（标准库保证原子操作），但**资源数据的访问不线程安全**。
   - **解决方案**：通过 “互斥锁”（如`std::mutex`）保护资源的访问逻辑，确保同一时间只有一个线程能修改资源；若仅读取资源，可使用`std::shared_lock`（读写锁）优化性能。
3. **自定义删除器**
   - **场景需求**：默认智能指针用`delete`释放资源，但当资源是 “数组”（`new[]`分配）、“文件句柄”、“动态库句柄” 等时，需自定义释放逻辑（如数组需`delete[]`，文件句柄需`fclose`）。
   - **实现方式**：智能指针（如 shared_ptr、unique_ptr）支持传入 “删除器”（函数对象、lambda 表达式等），在析构时调用自定义逻辑（如`shared_ptr<int> p(new int[10], [](int* ptr){ delete[] ptr; });`）。

## 五、课程配套与后续学习指引

视频末尾提供了学习辅助资源，帮助巩固知识点：

1. **配套博客**：讲师有专属博客，会持续更新智能指针及其他 C++ 知识点的详细内容，可用于预习、复习和深度理解。

2. 课程合集关联

   ：该视频属于 “C++ 开发工程师高级进阶课程” 的一部分，后续课程会深入讲解：

   - shared_ptr 的手动实现（带引用计数的完整逻辑）；
   - `make_shared`的优势（推荐用`make_shared`代替直接`new`初始化 shared_ptr，减少内存分配次数）；
   - 智能指针在实际项目中的应用（如结合线程池、容器等）。





# Redis String 类型命令作用总结

视频围绕 Redis 中 String 类型的核心命令展开讲解，可按 “基础存取”“数值操作”“组合功能” 三大类划分，各类命令的具体作用如下：

## 一、基础存取命令（单值 / 批量操作）

这类命令是 String 类型最核心的基础操作，用于键值对的添加、查询，支持单组和多组数据的批量处理。

| 命令                   | 作用                                      | 关键特点                                                     |
| ---------------------- | ----------------------------------------- | ------------------------------------------------------------ |
| `SET key value`        | 向 Redis 中添加或修改 String 类型的键值对 | - 若`key`不存在：执行 “新增” 操作- 若`key`已存在：执行 “覆盖修改” 操作 |
| `GET key`              | 根据`key`查询对应的 String 类型值         | - 若`key`不存在：返回`nil`（空）- 若`key`存在：返回对应的`value` |
| `MSET k1 v1 k2 v2 ...` | 批量添加 / 修改多组 String 类型键值对     | - 一次命令可处理多个键值对，减少网络交互次数，比多次执行`SET`更高效 |
| `MGET k1 k2 ...`       | 批量查询多个`key`对应的 String 类型值     | - 返回结果为 “数组形式”，顺序与传入的`key`顺序一致- 不存在的`key`对应位置返回`nil` |

## 二、数值专属操作命令

针对值为 “整数” 或 “浮点数” 的 String 类型键，提供自增 / 自减功能（底层通过特殊编码优化，节省内存）。

| 命令                   | 作用                                                         | 适用场景                           |
| ---------------------- | ------------------------------------------------------------ | ---------------------------------- |
| `INCR key`             | 让值为 “整数” 的`key`自增 1                                  | 计数器（如访问量、订单数）         |
| `INCRBY key step`      | 让值为 “整数” 的`key`按指定步长（`step`）自增；若`step`为负数，实现自减 | 自定义步长计数（如每次加 5、减 3） |
| `INCRBYFLOAT key step` | 让值为 “浮点数” 的`key`按指定步长（`step`）自增（支持小数步长） | 浮点数计数（如金额、评分）         |

## 三、组合功能命令（新增 + 附加条件）

将 “新增键值对” 与 “额外逻辑”（如判断 key 是否存在、设置有效期）结合，简化多步操作。

| 命令                       | 作用                                                         | 核心逻辑                                                     |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `SETNX key value`          | 仅当`key`不存在时，才添加 String 类型键值对（“NX” 即 “Not Exist”） | - 若`key`已存在：命令执行失败，返回`0`- 若`key`不存在：执行新增，返回`1` |
| `SET key value NX`         | 与`SETNX`功能完全一致（`NX`作为`SET`的可选参数）             | 等价于`SETNX`，属于更灵活的参数化写法                        |
| `SETEX key seconds value`  | 新增 String 类型键值对，并同时设置`key`的有效期（单位：秒）  | - 等价于 “先执行`SET key value`，再执行`EXPIRE key seconds`”- 有效期到后，`key`会被 Redis 自动删除 |
| `SET key value EX seconds` | 与`SETEX`功能完全一致（`EX`作为`SET`的可选参数）             | 等价于`SETEX`，参数化写法更灵活                              |

## 补充说明

1. String 类型的存储上限：单个键值对的`value`最大不能超过 512MB，不建议存储大文件（如图片），通常仅存储 “图片地址” 等小数据。
2. 通用删除命令：视频中提到 “删除” 需使用通用命令`DEL key`（非 String 专属），执行后`key`及对应值会被彻底删除。