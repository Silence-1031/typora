# 哈希

## 一、STL中的哈希结构

`unordered_set`和`unordered_map`是STL中基于哈希表实现的容器，本质上是**“哈希表的封装”**

1. **`unordered_set`**无重复的“哈希集合”

	- `unordered_set`:是哈希表的简化版，仅存储不重复的key（value）

	- 核心作用是“快速判断元素是否存在”


**核心特性：**

- 元素唯一性：插入重复元素时自动忽略

- 无序性：元素插入顺序与存储顺序无关
- 操作效率：插入、查找、删除均为平均O(1)，最坏O(n)（同哈希表）

**常用方法**

|         接口          |                             功能                             |
| :-------------------: | :----------------------------------------------------------: |
|     `insert(key)`     | 插入key，若已存在则不操作，返回`pair<iterator,bool>`(bool表示是否插入成功) |
|      `find(key)`      |  查找key，存在则返回指向该元素的迭代器，不存在则返回`end()`  |
|     `count(key)`      |        统计key的个数（仅0和1,可用于判断元素是否存在）        |
| `erase(key/iterator)` |  删除指定key或迭代器指向的元素，返回删除元素的个数（0或1）   |
|       `empty()`       |                         判断是否为空                         |
|       `size()`        |                         返回元素个数                         |



2. `unordered_map`:键值对的哈希映射

`unordered_map`是“标准哈希表的实现”，存储**唯一**的key和对应的value（key不重复，value可重复），核心作用是“通过key快速查找value”.

**核心特性：**

- key唯一：若插入相同key，会覆盖原来的value
- 键值对储存：数据以pair<const key,Value>形式存储（key不可修改，value可修改）
- 无序性：键值对的插入顺序与存储顺序无关
- 操作效率：插入、查找、删除均为平均O(1)，最坏O(n)（同哈希表）

**常用方法**

|           接口            |                             功能                             |
| :-----------------------: | :----------------------------------------------------------: |
| `insert(pair<key,value>)` | 插入键值对，若 Key 已存在则不操作；<br>也可直接用`map[key] = value`（存在则覆盖）。 |
|        `find(key)`        | 查找key，存在则**返回指向pair<key,value>的迭代器**，不存在则返回end() |
|       `count(key)`        |      统计key的个数（仅 0 或 1，用于判断 Key 是否存在）       |
|      `operator[key]`      | 访问key对应的value（若key不存在会自动创建并初始化value），慎用！ |
|   `erase(key/iterator)`   | 删除指定 key 或迭代器指向的键值对，返回删除的个数（0 或 1）。 |
|         `empty()`         |                         判断是否为空                         |
|         `size()`          |                       返回键值对个数。                       |

3. unordered_set vs unordered_map：关键区别

|   对比   |         unordered_set          |               unordered_map               |
| :------: | :----------------------------: | :---------------------------------------: |
| 存储内容 |       仅 Key（无 Value）       |             Key-Value 键值对              |
| 核心用途 | 判断元素是否存在（去重、查询） | 通过 Key 快速获取 Value（映射、关联存储） |
| 插入方式 | 直接插入 Key（`insert(key)`）  |    插入`pair<Key, Value>`或用`[]`赋值     |
| 元素访问 | 仅通过迭代器或`find()`获取 Key |      可通过`[]`或`find()`获取 Value       |

## 二、哈希表的算法应用场景

哈希表的核心优势是**“O(1)查找”**，因此在算法在主要解决需要快速判断元素是否存在，或需要快速关联键值的问题，常见场景如下：

1. 两数之和（LeetCode #1）：经典映射问题

**问题**：给定数组和目标值，找到两个数的索引，使它们的和为目标值。

**常规思路**：双重循环（O (n²)），效率低。

**哈希表思路**：以元素数值为key，元素索引为value，用`unordered_map`存储 “数组元素值 → 索引”，遍历数组时，判断 `“complement=target-nums[i]”` 是否在 map 中：

- 若存在：直接返回两个索引`i`和`hashmap.find(nums[i])`；
- 若不存在：将当前元素和索引存入 hashmap。

时间复杂度：O (n)（仅遍历一次数组，每次查找 O (1)）。

2. 数组去重 / 统计频率：快速去重与计数

**问题 1（去重）**：删除数组中的重复元素，返回新数组长度。

**哈希表思路**：用`unordered_set`遍历数组，插入所有元素（自动去重），最后返回 set 的大小。

```c++
unordered_set<int> numSet(nums.begin(),nums.end());
```

**时间复杂度**：O (n),比排序去重的 O (nlogn) 更高效.



**问题 2（统计频率）**：统计数组中每个元素出现的次数。

**哈希表思路**：用`unordered_map`，Key 为元素值，Value 为出现次数，遍历数组时累加 Value。

```c++
unordered_map<int,int> hashmap;
hashmap[key]++;
```

**时间复杂度**：O(n)。



3. 最长无重复子串（LeetCode #3）：快速判断重复字符

**问题**：找到字符串中不含重复字符的最长子串长度。

**哈希表思路**：用`unordered_map`存储 “字符 → 最近出现的索引”，通过滑动窗口维护无重复子串，当遇到重复字符时，更新窗口左边界为 “重复字符的下一个索引”，避免重新遍历。

**时间复杂度**：O (n)（仅遍历一次字符串，每次查找和更新 O (1)）。



4. 查找两个数组的交集（LeetCode #349）：快速判断元素归属

**问题**：找到两个数组的交集（元素唯一）。

**哈希表思路**：用`unordered_set`存储第一个数组的所有元素（去重），再遍历第二个数组，判断元素是否在 set 中，若存在则加入结果集（并从 set 中删除，避免重复）。

**时间复杂度**：O (m+n)（m、n 为两个数组长度）。



5. LRU 缓存（LeetCode #146）：哈希表 + 链表的组合应用

**问题**：设计缓存结构，支持`get`（获取键对应值）和`put`（插入键值对），当缓存满时，删除 “最近最少使用” 的元素。

**哈希表思路**：用`unordered_map`存储 “Key → 链表节点指针”（O (1) 查找节点），用双向链表维护元素的 “使用顺序”（O (1) 删除 / 移动节点）。两者结合实现 LRU 缓存的 O (1) 操作。

## 三、哈希表的局限性与替代方案

尽管哈希表高效，但并非万能，需注意其局限性：

1. **无序性**：若需要 “有序存储”（如按 Key 排序），需用**红黑树实现的容器**（如 C++ 的`set`/`map`），但操作复杂度会上升到 O (logn)；
2. **哈希函数依赖**：若哈希函数设计不合理（如分布不均），会导致冲突激增，性能退化到 O (n)；
3. **内存消耗**：为降低冲突，哈希表需预留一定的空闲空间（负载因子 < 1），内存利用率低于数组或链表；
4. **不可直接遍历有序元素**：若需按 Key 或 Value 排序，需先将哈希表的元素存入数组，再排序（额外 O (nlogn) 时间）。



# 双指针

在数据结构与算法中，双指针是一种通过维护两个“指针”（可以是**数组/链表的索引、游标或者简单的位置标记**），协同遍历数据结构来高效解决问题的技巧，它的核心优势是将原本需要嵌套循环的**O (n²) 时间复杂度**优化为 **O (n) 或 O (n log n)**，大幅提升效率

### 一、双指针的本质与核心思想

这里的“指针”是指广义上的位置标记 （如数组的索引 `i`/`j`、链表的节点引用 `slow`/`fast`）。其核心思想是：通过**合理定义两个指针的移动规则**（如 “同向移动”“反向移动”），让两个指针在一次遍历中完成原本需要多次遍历的任务，减少冗余操作。

> 关键在于如何合理设置规则让指针在一次遍历中完成原本需要多次遍历的任务

### 二、双指针的常见类型与适用场景

根据指针的移动方向和用途，双指针主要分为以下 4 类，不同类型对应不同的典型场景：

1. 同向双指针（快慢指针）

- **特点**：两个指针从同一端（通常是起始位置）出发，沿相同方向移动，但移动速度不同（“快指针” 移动更快，“慢指针” 移动较慢或按需移动）。
- 核心用途：在线性数据结构（数组，链表）中**定位“特定元素”或“筛选元素”**，避免使用额外空间

|       典型场景       |                           问题描述                           |                         指针移动规则                         |
| :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   移除数组重复元素   |   给定有序数组，移除重复元素，返回新长度（如 LeetCode 26）   | 慢指针 `slow` 指向 “有效元素的末尾”，快指针 `fast` 遍历数组：若 `nums[fast] != nums[slow]`，则 `slow` 后移并赋值 `nums[slow] = nums[fast]`。 |
|      链表环检测      |  判断单链表是否有环，或找到环的入口（如 LeetCode 141、142）  | 慢指针 `slow` 每次走 1 步，快指针 `fast` 每次走 2 步：若相遇则有环；<br>相遇后让 `slow` 回起点，两指针再同步走 1 步，相遇点即为环入口。 |
|   找到链表中间节点   |           找到单链表的中间节点（如 LeetCode 876）            | 慢指针走 1 步，快指针走 2 步：当快指针到达末尾时，慢指针恰好指向中间节点。 |
| 数组 “原地” 筛选元素 | 移除数组中等于特定值的元素（如 LeetCode 27），或筛选出满足条件的元素 | 慢指针 `slow` 记录 “筛选后元素的位置”，快指针 `fast` 遍历数组：若 `nums[fast]` 满足条件，则赋值给 `nums[slow]` 并 `slow` 后移。 |

#### 2. 反向双指针（左右指针）

- **特点**：两个指针分别从数据结构的**两端（左端点 `left`、右端点 `right`）** 出发，沿相反方向向中间移动，直到相遇或满足特定条件。
- **核心用途**：解决 **“有序数组 / 区间”** 的匹配、求和、优化问题，利用有序性减少无效遍历。

> 需要数组/区间是有序的

|     典型场景      |                           问题描述                           |                         指针移动规则                         |
| :---------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     两数之和      | 给定有序数组和目标值，找到两个数使其和为目标值（如 LeetCode 167） | 计算 `sum = nums[left] + nums[right]`：若 `sum < target`，`left` 右移（增大和）；若 `sum > target`，`right` 左移（减小和）；若相等则返回索引。 |
|  盛最多水的容器   |     给定数组（表示柱子高度），找到两根柱子使容器装水最多     | 容器容量 = 两指针距离 × 较短柱子高度。为最大化容量，优先移动较短柱子的指针（若移动长柱子，距离减小且高度不增，容量必降）。 |
| 反转数组 / 字符串 |          将数组或字符串原地反转（如 LeetCode 344）           | 交换 `nums[left]` 和 `nums[right]`，然后 `left` 右移、`right` 左移，直到 `left >= right`。 |
|   二分查找变种    | 查找有序数组中目标值的第一个 / 最后一个位置（如 LeetCode 34） | 左指针 `left=0`，右指针 `right=n-1`，通过调整指针边界缩小范围，精准定位目标区间。 |

#### 3. 滑动窗口双指针

- **特点**：本质是 “同向双指针” 的延伸，两个指针（`left` 左边界、`right` 右边界）定义一个 “窗口”（连续子数组 / 子串），通过移动右指针扩大窗口、移动左指针缩小窗口，**动态维护**窗口内的信息（如和、长度、元素频次）。
- **核心用途**：**解决 “连续子数组 / 子串” 的优化问题**（如最短、最长、满足条件的子串），避免暴力枚举所有子串。

|       典型场景       |                           问题描述                           |                         指针移动规则                         |
| :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 无重复字符的最长子串 |    找到字符串中无重复字符的最长子串长度（如 LeetCode 3）     | 右指针 `right` 遍历字符串，用哈希表记录字符最后出现位置；若字符已在窗口内，则将 `left` 移到 **“字符上次位置 + 1”（确保窗口无重复）**，同时更新最长长度。 |
|     最小覆盖子串     | 找到字符串 `s` 中包含 `t` 所有字符的最短子串（如 LeetCode 76） | 右指针扩大窗口，直到包含 `t` 所有字符；再移动左指针缩小窗口，直到不包含 `t` 所有字符，记录过程中最短窗口。 |
|   长度最小的子数组   |   找到数组中 “和 ≥ 目标值” 的最短子数组（如 LeetCode 209）   | 右指针扩大窗口并累加和；当和 ≥ 目标值时，移动左指针减小窗口，同时更新最短长度。 |

#### 4. 交叉双指针（多数组遍历）

- **特点**：两个指针分别指向**两个不同的数组**，按规则同步或异步移动，用于处理两个数组的 “合并”“比较” 或 “匹配” 问题。
- **核心用途**：合并有序数组、寻找两个数组的交集 / 并集等。

| 典型场景         | 问题描述                                                     | 指针移动规则                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 合并两个有序数组 | 将有序数组 `nums2` 合并到有序数组 `nums1` 中，保持整体有序（如 LeetCode 88） | 用两个指针 `i`（`nums1` 有效元素末尾）、`j`（`nums2` 末尾），从后向前比较，将较大元素放入 `nums1` 末尾，同时指针前移。 |
| 两个数组的交集   | 找到两个有序数组的交集（元素可重复，如 LeetCode 350）        | 指针 `i` 指向 `nums1`，`j` 指向 `nums2`：若 `nums1[i] == nums2[j]`，加入结果并两指针同移；若 `nums1[i] < nums2[j]`，`i` 右移；否则 `j` 右移。 |



### 三、双指针的优势与局限性

**优势：**

1. 效率高：将嵌套循环的复杂度降至O(n)，适合大规模数据
2. 省空间：大多为**“原地操作”**，无需开辟数组或哈希表等空间
3. 逻辑直观：通过指针移动规则可直接映射问题逻辑，易于理解实现

**局限性：**

1. **依赖数据结构的特性**：部分场景需数据有序（如两数之和、合并数组），无序时需先排序（增加 O (n log n) 复杂度）。
2. **不适用非线性结构**：主要针对数组、链表、字符串等线性结构，树、图等非线性结构需结合其他算法（如 BFS/DFS）。



### 四、经典例题实战（以 “移除有序数组重复元素” 为例）

题目：给你一个**非严格递增排列**的数组 `nums`，请你**原地**删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。

#### 双指针解法：

```c++
class Solution:{
public:
  int removeDuplicates(vector<int>& nums){
    int n=nums.size();
    if(n==0) return 0;
    
    int slow=0;	//慢指针，指向最后一个不重复元素的位置
    for(int fast=0;fast<n;fast++){
      if(nums[fast]!=nums[slow]){	//找到新的不重复元素
        slow+=1;	//慢指针后移，指向新的不重复位置
        nums[slow]=nums[fast];
      }
    }
    return slow+1;
  }
};
```

- **复杂度**：时间 O (n)（仅遍历一次数组），空间 O (1)（原地操作）。
- **逻辑**：慢指针维护 “有效区间”，快指针探索新元素，**仅当找到不重复元素时更新有效区间**，避免冗余赋值。



# queue队列

在 C++ STL（标准模板库）中，`queue`（队列）是一种**先进先出（FIFO, First-In-First-Out）** 的容器适配器（Container Adapter）—— 它不直接存储数据，而是基于底层容器（默认是`deque`）实现队列的核心功能，仅暴露符合 “队列逻辑” 的接口，屏蔽底层容器的其他操作（如随机访问）。

## 一、queue 的核心特性

1. **FIFO 顺序**：第一个插入的元素（队尾），会第一个被取出（队头），类似现实中的 “排队”。
2. **容器适配器**：依赖底层容器实现，默认用`deque`（双端队列），也可指定`list`（链表）作为底层容器（但不能用`vector`，因为`vector`不支持高效的 “队头删除” 操作）。
3. **受限接口**：仅提供队列必需的操作（如入队、出队、访问队头 / 队尾），不支持迭代器遍历（无法直接访问中间元素），确保严格遵循 FIFO 逻辑。

## 二、queue 的定义与头文件

使用`queue`前必须包含头文件；

```cpp
#include <queue>
```

### 定义语法

```cpp
// 1. 默认底层容器（deque），存储类型为T
std::queue<T> q;

// 2. 指定底层容器（如list），需包含对应头文件（<list>）
std::queue<T, std::list<T>> q;
```

**示例**：

```cpp
#include <queue>
#include <list>

// 存储int的默认队列（底层deque）
std::queue<int> q1;

// 存储string的队列（底层list）
std::queue<std::string, std::list<std::string>> q2;
```

## 三、queue 的常用成员函数

`queue`的接口设计简洁，仅保留与 **“队列操作”** 相关的函数，核心分为**入队、出队、访问、状态查询**四类：

|         成员函数          |                           功能描述                           |
| :-----------------------: | :----------------------------------------------------------: |
|       **入队操作**        |                                                              |
|   `push(const T& val)`    | 将元素`val`插入到**队尾**（调用底层容器的`push_back()`），**无返回值**。 |
| `emplace(Args&&... args)` | 直接在队尾**构造元素**（避免拷贝 / 移动，效率更高），C++11 及以上支持。 |
|                           |                                                              |
|       **出队操作**        |                                                              |
|          `pop()`          | 删除**队头**元素（调用底层容器的`pop_front()`），无返回值，且不返回被删元素。 |
|                           |                                                              |
|       **访问操作**        |                                                              |
|         `front()`         | 返回**队头**元素的引用（可修改，如`q.front() = 10`），若队空则行为未定义。 |
|         `back()`          |    返回**队尾**元素的引用（可修改），若队空则行为未定义。    |
|                           |                                                              |
|       **状态查询**        |                                                              |
|         `empty()`         | 判断队列是否为空，返回`bool`（空为`true`，非空为`false`）。  |
|         `size()`          |     返回队列中元素的个数，类型为`size_t`（无符号整数）。     |

### 函数使用示例

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;

    // 1. 入队（push/emplace）
    q.push(10);    // 队尾插入10 → 队列：[10]
    q.emplace(20); // 队尾构造20 → 队列：[10, 20]
    q.push(30);    // 队尾插入30 → 队列：[10, 20, 30]

    // 2. 状态查询
    cout << "队列是否为空：" << (q.empty() ? "是" : "否") << endl; // 否
    cout << "队列元素个数：" << q.size() << endl;                  // 3

    // 3. 访问队头/队尾
    cout << "队头元素：" << q.front() << endl; // 10（第一个插入的元素）
    cout << "队尾元素：" << q.back() << endl;  // 30（最后插入的元素）

    // 4. 出队（pop需配合front使用，才能获取被删元素）
    q.pop(); // 删除队头10 → 队列：[20, 30]
    cout << "出队后队头：" << q.front() << endl; // 20

    q.pop(); // 删除队头20 → 队列：[30]
    q.pop(); // 删除队头30 → 队列：空
    cout << "全部出队后是否为空：" << (q.empty() ? "是" : "否") << endl; // 是

    return 0;
}
```



## 四、queue 的底层容器选择

`queue`的底层容器必须支持以下操作（STL 中`deque`双端队列和`list`链表满足，`vector`不满足）：

- `push_back()`：队尾插入（入队）。
- `pop_front()`：队头删除（出队）。
- `front()`：访问队头。
- `back()`：访问队尾。
- `empty()`/`size()`：状态查询。

### 两种常用底层容器对比

| 底层容器 |                             优势                             |                             劣势                             |                    适用场景                    |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------------------------------------------: |
| `deque`  |  ① 随机访问效率高于`list`；<br>② 内存连续（分段），缓存友好  |        队头 / 队尾操作效率略低于`list`（但仍 O (1)）         | 需兼顾 “队列操作” 和底层容器潜在的随机访问需求 |
|  `list`  | ① 队头 / 队尾插入 / 删除是纯 O (1)（无内存移动）；<br>② 节点动态分配，内存灵活 | ① 不支持随机访问；<br>② 节点存储指针，内存开销大，缓存不友好 |  频繁进行大量入队 / 出队操作，且无需随机访问   |

**默认选择`deque`的原因**：`deque`在 “队列操作效率” 和 “内存利用率” 之间平衡更好，大多数场景下无需手动指定`list`。

## 五、queue 的注意事项

1. **禁止访问空队列的 `front ()/back ()`**：若队列空时调用`front()`或`back()`，行为是**未定义的**（可能崩溃或返回垃圾值），需先通过`empty()`判断队列非空。

2. **pop () 不返回被删元素**：`queue::pop()`仅删除队头元素，不返回它。若需获取被删元素，需先通过`front()`读取，再调用`pop()`

3. **不支持迭代器和随机访问**：`queue`没有`begin()`、`end()`迭代器，无法用`for`循环遍历所有元素（若需遍历，需先出队并暂存元素，遍历后再重新入队，但会破坏原队列结构）。

  > BFS广度优先搜索用queue实现，在遍历时取出队列头节点进行操作，并将剩下节点入队，所以只进行出队及暂存元素即可，不用再重新入队

  ```cpp
queue<int> q;
q.push(10), q.push(20), q.push(30);

// 遍历：出队并打印
while (!q.empty()) {
    cout << q.front() << " "; // 10 20 30
    q.pop();
}
// 遍历后队列空
  ```

  

## 六、queue 的应用场景

`queue`的 FIFO 特性使其适合处理 **“按顺序排队”** 的问题，典型场景包括：

1. **任务调度**：如线程池的任务队列（先提交的任务先执行）。
2. **广度优先搜索（BFS）**：如二叉树的层序遍历、图的最短路径（FIFO 顺序确保每一层节点按顺序处理）。
3. **缓冲队列**：如 IO 缓冲区（先接收的数据先处理）。
4. **模拟排队场景**：如银行叫号系统、打印机任务队列。





# deque 双端队列

在 C++ STL（标准模板库）中，**deque**（双端队列，Double-Ended Queue）是一种支持在**两端快速插入和删除**的序列容器，同时也支持随机访问（但效率低于`vector`）。其核心特点是 “双端操作高效”，弥补了`vector`只能高效尾插、`queue`只能单端操作的不足。

### 一、deque 的核心特性

1. **双端高效操作**：头部（front）和尾部（back）的插入（`push_front`/`push_back`）、删除（`pop_front`/`pop_back`）均为 **O (1) 时间复杂度**。
2. **随机访问支持**：通过下标（`[]`）或`at()`访问元素，时间复杂度 **O(1)**，但底层实现比`vector`复杂（非连续内存），实际访问效率略低。
3. **动态扩容**：容量不足时自动扩容，无需手动管理（类似`vector`），但扩容策略更灵活（避免`vector`扩容时的大规模数据拷贝）。
4. **非连续内存**：底层由多个 “分段连续的缓冲区” 组成，通过内部指针数组（map）管理，既兼顾了双端操作效率，又减少了连续内存的分配压力。

### 二、deque 的常用操作（API）

使用`deque`前需包含头文件：`#include <deque>`。

#### 1. 构造与赋值

|           函数原型            |                           功能说明                           |
| :---------------------------: | :----------------------------------------------------------: |
|         `deque<T> d`          |   默认构造：创建空的 deque（T 为元素类型，如 int、string）   |
|     `deque<T> d(n, val)`      |           构造：创建含 n 个值为 val 的元素的 deque           |
|    `deque<T> d(beg, end)`     | 范围构造：用 [beg, end) 区间的元素初始化（beg/end 为迭代器，如数组指针、其他容器的迭代器），前开后闭区间 |
| `deque<T> d(const deque& d2)` |              拷贝构造：用另一个 deque d2 初始化              |
|           `d = d2`            |               赋值运算符：将 d2 的元素赋值给 d               |
|     `d.assign(beg, end)`      |       赋值：用 [beg, end) 区间的元素替换 d 的所有元素        |
|      `d.assign(n, val)`       |             赋值：用 n 个 val 替换 d 的所有元素              |

**示例**：

```cpp
#include <deque>
#include <iostream>
using namespace std;

int main() {
    // 1. 默认构造
    deque<int> d1;
    
    // 2. 初始化3个10
    deque<int> d2(3, 10);  // d2: [10, 10, 10]
    
    // 3. 用数组初始化
    int arr[] = {1,2,3,4};
    deque<int> d3(arr, arr+4);  // d3: [1,2,3,4]
    
    // 4. 拷贝构造
    deque<int> d4(d3);  // d4: [1,2,3,4]
    
    // 5. assign赋值
    d1.assign(2, 5);    // d1: [5,5]
    d1.assign(d3.begin(), d3.end());  // d1: [1,2,3,4]
    
    return 0;
}
```

#### 2. 元素访问

|  函数原型   |                           功能说明                           |
| :---------: | :----------------------------------------------------------: |
| `d.at(idx)` |   返回下标 idx 处的元素，**越界时抛异常**（比`[]`更安全）    |
|  `d[idx]`   |   返回下标 idx 处的元素，**越界时行为未定义**（效率略高）    |
| `d.front()` | 返回 deque 的**第一个元素**（不检查空否，空 deque 调用会崩溃） |
| `d.back()`  |      返回 deque 的**最后一个元素**（同上，需确保非空）       |

**示例**：

```cpp
deque<int> d = {10,20,30,40};
cout << d[1] << endl;    // 输出20（下标从0开始）
cout << d.at(2) << endl; // 输出30
cout << d.front() << endl; // 输出10
cout << d.back() << endl;  // 输出40

// d.at(10); // 越界，抛out_of_range异常
// d[10];    // 越界，行为未定义（可能崩溃或乱码）
```

#### 3. 插入与删除

deque 的核心优势体现在**双端插入 / 删除**，同时也支持中间插入（但效率较低，O (n)）。

|         函数原型          |                           功能说明                           |
| :-----------------------: | :----------------------------------------------------------: |
|   **尾部操作（O (1)）**   |                                                              |
|    `d.push_back(val)`     |               在 deque**尾部插入**一个元素 val               |
|      `d.pop_back()`       |       删除 deque**尾部的元素**（无返回值，需确保非空）       |
|                           |                                                              |
|   **头部操作（O (1)）**   |                                                              |
|    `d.push_front(val)`    |               在 deque**头部插入**一个元素 val               |
|      `d.pop_front()`      |       删除 deque**头部的元素**（无返回值，需确保非空）       |
|                           |                                                              |
|   **中间操作（O (n)）**   |                                                              |
|   `d.insert(pos, val)`    | 在迭代器 pos 指向的位置**插入一个 val**，返回指向新元素的迭代器 |
|  `d.insert(pos, n, val)`  |                   在 pos 位置插入 n 个 val                   |
| `d.insert(pos, beg, end)` |            在 pos 位置插入 [beg, end) 区间的元素             |
|      `d.erase(pos)`       |  删除 pos 指向的元素，返回指向删除后下一个元素的**迭代器**   |
|    `d.erase(beg, end)`    | 删除 [beg, end) 区间的元素，返回指向删除后下一个元素的**迭代器** |
|                           |                                                              |
|         **清空**          |                                                              |
|        `d.clear()`        |      删除 deque 中所有元素，size 变为 0（容量可能不变）      |



#### 4. 容量与状态

|      函数原型      |                           功能说明                           |
| :----------------: | :----------------------------------------------------------: |
|    `d.empty()`     |  判断 deque 是否为空（空返回 true，非空返回 false），O (1)   |
|     `d.size()`     |                返回 deque 中元素的个数，O (1)                |
|   `d.max_size()`   | 返回 deque 理论上能容纳的最大元素个数（受系统内存限制），O (1) |
|   `d.resize(n)`    | 调整 deque 大小为 n：- 若 n < 当前 size：删除多余元素；- 若 n > 当前 size：补默认值（如 int 补 0） |
| `d.resize(n, val)` |      调整大小为 n，若 n > 当前 size：补 val 而非默认值       |
|   `d.capacity()`   | 返回当前 deque 的容量（注意：部分编译器可能不支持，因 deque 底层非连续内存，容量定义不统一） |



### 三、deque 的迭代器

deque 支持完整的迭代器操作，可用于遍历、插入、删除等场景。常用迭代器类型：

- `d.begin()`：指向第一个元素的**正向迭代器**
- `d.end()`：指向最后一个元素**下一位**的正向迭代器（尾后迭代器，不可解引用）
- `d.rbegin()`：指向最后一个元素的**反向迭代器**（++ 操作指向前一个元素）
- `d.rend()`：指向第一个元素**前一位**的反向迭代器
- `d.cbegin()`/`d.cend()`：const 正向迭代器（不可修改元素）

**遍历示例**：

```cpp
deque<int> d = {10,20,30,40};

// 1. 正向遍历（迭代器）
for (auto it = d.begin(); it != d.end(); ++it) {
    cout << *it << " ";  // 输出：10 20 30 40
}

// 2. 反向遍历（反向迭代器）
for (auto rit = d.rbegin(); rit != d.rend(); ++rit) {
    cout << *rit << " ";  // 输出：40 30 20 10
}

// 3. 范围for（C++11及以上，本质是迭代器封装）
for (int val : d) {
    cout << val << " ";  // 输出：10 20 30 40
}
```

### 四、deque 与 vector、queue 的对比

| 容器     | 核心优势                              | 核心劣势                                | 适用场景                           |
| -------- | ------------------------------------- | --------------------------------------- | ---------------------------------- |
| `deque`  | 双端插入 / 删除 O (1)，随机访问 O (1) | 中间插入 / 删除 O (n)，随机访问效率略低 | 需双端操作（如滑动窗口）、队列实现 |
| `vector` | 随机访问 O (1)，尾插 O (1)            | 头部 / 中间插入 / 删除 O (n)            | 需频繁随机访问、尾插，少删除       |
| `queue`  | 单端（FIFO）操作 O (1)                | 不支持随机访问、双端操作                | 纯队列场景（如 BFS）               |

**注意**：STL 中的`queue`默认以`deque`为底层容器实现（`template <class T, class Container = deque<T>> class queue`）（也可指定用list实现）因为`deque`的双端操作能力能高效满足`queue`的`push_back`（入队）和`pop_front`（出队）需求。

### 五、常见问题与注意事项

1. **避免在中间插入 / 删除**：deque 中间操作需移动大量元素，效率为 O (n)，若需频繁中间操作，建议用`list`（双向链表）。

2. 迭代器失效问题

	- 头部 / 尾部插入 / 删除时，除`end()`迭代器外，其他迭代器通常不失效；
	- 中间插入 / 删除或扩容时，所有迭代器、指针、引用可能失效，需重新获取。

3. **空容器操作**：调用`front()`/`back()`/`pop_front()`/`pop_back()`前，务必用`empty()`判断容器非空，否则会导致未定义行为（崩溃）。







# Priority_queue 优先队列

在 C++ STL（标准模板库）中，**priority_queue（优先队列）** 是一种基于「堆（heap）」数据结构实现的容器适配器，其核心特性是：**每次访问或弹出的元素，始终是队列中「优先级最高」的元素**（默认是最大元素，可自定义优先级规则）。它**不支持随机访问**，仅支持访问和删除队首（优先级最高）元素，以及在队尾插入元素。

### 一、priority_queue 的核心特性

1. **底层实现**：默认基于 `vector` 作为底层存储容器，并用「堆算法」维护优先级（也可指定 `deque` 作为底层容器，但 `vector` 更常用）。

2. 优先级规

	- 默认是「大顶堆」：优先级最高的元素是最大值，每次弹出队首（最大元素）。
	- 可通过自定义比较函数（或仿函数）改为「小顶堆」，或按自定义规则排序（如结构体成员优先级）。

3. **不支持的操作**：不支持遍历（无迭代器）、不支持删除非队首元素、不支持随机访问（如 `[]` 或 `at()`）。

4. 时间复杂度

	- 插入元素（`push`）：`O (log n)`（堆的上浮调整）。
	- 弹出队首（`pop`）：`O (log n)`（堆的下沉调整）。
	- 访问队首（`top`）：`O (1)`（直接访问堆顶）。

### 二、priority_queue 的基本用法

#### 1. 头文件与定义

使用 `priority_queue` 需包含头文件 `<queue>`，其模板定义如下：

#### 2. 常见成员函数

| 成员函数             | 功能描述                                                     |
| -------------------- | ------------------------------------------------------------ |
| `push(const T& val)` | 向队尾插入元素，**插入后自动调整堆结构**，维持优先级规则（O (log n)）。 |
| `pop()`              | 删除队首（优先级最高）的元素，删除后自动调整堆结构（O (log n)，**无返回值**）。 |
| `top()`              | 返回队首（优先级最高）元素的引用（O (1)，仅访问不删除，需先判断非空）。 |
| `empty()`            | 判断队列是否为空，为空返回 `true`，否则返回 `false`（O(1)）。 |
| `size()`             | 返回队列中元素的个数（O (1)）。                              |

### 三、实战示例

根据元素类型（基础类型、结构体）和优先级规则（大顶堆、小顶堆），分场景演示用法。

#### 场景 1：基础类型（int）的默认大顶堆

默认情况下，`priority_queue<int>` 是大顶堆，每次 `top()` 取最大值，`pop()` 删除最大值。

```cpp
#include <iostream>
#include <queue>  // 包含 priority_queue

using namespace std;

int main() {
    // 1. 定义 int 类型的 priority_queue（默认大顶堆）
    priority_queue<int> pq;

    // 2. 插入元素（push）
    pq.push(30);
    pq.push(10);
    pq.push(50);
    pq.push(20);

    // 3. 访问与删除（需先判断非空）
    while (!pq.empty()) {
        // 访问队首（最大值）
        cout << "当前队首（最大值）：" << pq.top() << endl;
        // 删除队首
        pq.pop();
    }

    return 0;
}
```



#### 场景 2：基础类型（int）的小顶堆

若需「小顶堆」（每次取最小值），需显式指定比较函数为 `greater<T>`，且底层容器需显式写出（不能省略）。

```cpp
#include <iostream>
#include <queue>
#include <vector>  // 需包含底层容器的头文件

using namespace std;

int main() {
    // 定义 int 类型的小顶堆：指定 Container 为 vector<int>，Compare 为 greater<int>
    priority_queue<int, vector<int>, greater<int>> pq;

    // 插入元素
    pq.push(30);
    pq.push(10);
    pq.push(50);
    pq.push(20);

    // 访问与删除（每次取最小值）
    while (!pq.empty()) {
        cout << "当前队首（最小值）：" << pq.top() << endl;
        pq.pop();
    }

    return 0;
}
```



#### 场景 3：自定义类型（结构体）的优先级

若存储的是结构体（如「学生信息」，需按「分数」或「学号」排序），需自定义比较规则（通过**仿函数**或**lambda 表达式**实现）。

##### 示例：按学生分数降序（分数高的优先级高）

```cpp
#include <iostream>
#include <queue>
#include <string>
#include <vector>

using namespace std;

// 定义结构体：学生信息
struct Student {
    string name;  // 姓名
    int score;    // 分数
    int id;       // 学号

    // 构造函数：方便初始化
    Student(string n, int s, int i) : name(n), score(s), id(i) {}
};

// 自定义比较仿函数（用于大顶堆：分数高的优先级高）
struct CompareScoreDesc {
    // 重载 () 运算符，定义比较规则：a 的优先级低于 b 时返回 true
    bool operator()(const Student& a, const Student& b) {
        // 分数低的排在后面（即分数高的先出队）
        return a.score < b.score;
    }
};

int main() {
    // 定义结构体类型的 priority_queue，使用自定义仿函数
    priority_queue<Student, vector<Student>, CompareScoreDesc> pq;

    // 插入学生信息
    pq.push(Student("Alice", 95, 101));
    pq.push(Student("Bob", 88, 102));
    pq.push(Student("Charlie", 98, 103));
    pq.push(Student("David", 92, 104));

    // 输出优先级最高的学生（分数从高到低）
    while (!pq.empty()) {
        Student top_stu = pq.top();
        cout << "姓名：" << top_stu.name 
             << "，分数：" << top_stu.score 
             << "，学号：" << top_stu.id << endl;
        pq.pop();
    }

    return 0;
}
```

##### 扩展：按多个字段排序（如分数相同按学号升序）

只需修改仿函数的比较逻辑：

```cpp
struct CompareScoreDesc {
    bool operator()(const Student& a, const Student& b) {
        if (a.score != b.score) {
            // 分数不同：分数低的优先级低
            return a.score < b.score;
        } else {
            // 分数相同：学号大的优先级低（学号小的先出队）
            return a.id > b.id;
        }
    }
};
```

#### 场景 4：用 lambda 表达式自定义优先级（C++11 及以上）

对于简单的比较逻辑，可直接用 lambda 表达式替代仿函数，但需注意：lambda 表达式不能直接作为 `priority_queue` 的模板参数，需通过 `function` 包装。

示例：小顶堆（按学生分数升序）

```cpp
#include <iostream>
#include <queue>
#include <string>
#include <vector>
#include <functional>  // 包含 function 头文件

using namespace std;

struct Student {
    string name;
    int score;
    Student(string n, int s) : name(n), score(s) {}
};

int main() {
    // 用 lambda 表达式定义比较规则（小顶堆：分数低的先出队）
    auto cmp = [](const Student& a, const Student& b) {
        return a.score > b.score;  // 分数高的优先级低（排在后面）
    };

    // 定义 priority_queue：用 function 包装 lambda
    priority_queue<Student, vector<Student>, function<bool(const Student&, const Student&)>> pq(cmp);

    // 插入元素
    pq.push(Student("Alice", 95));
    pq.push(Student("Bob", 88));
    pq.push(Student("Charlie", 98));

    // 输出（按分数升序）
    while (!pq.empty()) {
        cout << pq.top().name << "：" << pq.top().score << endl;
        pq.pop();
    }

    return 0;
}
```

### 四、注意事项

1. **`pop()` 无返回值**：若需获取弹出的元素，需先调用 `top()` 访问，再调用 `pop()` 删除（顺序不可颠倒）。
2. **避免访问空队列**：调用 `top()` 或 `pop()` 前，必须用 `empty()` 判断队列是否非空，否则会触发未定义行为。
3. **底层容器的选择**：默认 `vector` 足够高效，若需频繁插入 / 删除且内存分配敏感，可尝试 `deque`，但两者时间复杂度一致。
4. **自定义类型需显式比较规则**：若存储的是自定义结构体 / 类，必须提供比较函数（仿函数或 `function` 包装的 lambda），否则编译器无法判断优先级。
5. **不支持遍历**：`priority_queue` 没有迭代器，无法用 `for` 循环遍历所有元素，只能通过 `top()` + `pop()` 逐个处理。

### 五、适用场景

priority_queue 适合需要「动态获取优先级最高元素」的场景，例如：

- 任务调度（高优先级任务先执行）。
- 最短路径算法（如 Dijkstra 算法，每次选距离起点最近的节点）。
- 海量数据中取 Top K 元素（如取前 10 个最大数，用小顶堆优化）。

通过灵活自定义优先级规则，priority_queue 可以满足各种复杂的排序需求，是 STL 中非常实用的容器适配器。



# string 字符串

C++ 标准模板库（STL）中的 `std::string` 是用于处理字符串的核心类，封装了字符串的存储、操作和管理逻辑，相比传统的 C 风格字符数组（`char[]`）更安全、便捷，支持丰富的成员函数和算法。

### 一、基础准备：包含头文件与命名空间

使用 `std::string` 前，必须包含对应的头文件，并指定 `std` 命名空间（或显式使用 `std::` 前缀）：

```cpp
#include <string>  // 必须包含的头文件
using namespace std;  // 可选，避免重复写 std::
```

### 二、核心用法：从初始化到基本操作

#### 1. 字符串初始化（多种方式）

`std::string` 支持多种初始化方式，覆盖不同场景需求：

|     初始化方式     |                 示例代码                  |                 说明                  |
| :----------------: | :---------------------------------------: | :-----------------------------------: |
|     默认初始化     |                `string s;`                |   空字符串，长度为 0，内存自动管理    |
| 字符串字面量初始化 |        `string s = "Hello World";`        |  用 C 风格字符串初始化，自动处理长度  |
|     拷贝初始化     |             `string s1 = s2;`             |     复制另一个 string 对象的内容      |
|   部分字符初始化   |          `string s("Hello", 3);`          |      取前 3 个字符，结果为 "Hel"      |
|   重复字符初始化   |            `string s(5, 'a');`            | 5 个 'a' 组成的字符串，结果为 "aaaaa" |
|  迭代器范围初始化  | `string s(s2.begin() + 2, s2.end() - 1);` | 从 s2 的第 3 个字符到倒数第 2 个字符  |

#### 2. 基本属性获取

通过成员函数获取字符串的**长度**、**容量**等核心属性：

```cpp
string s = "Hello";
cout << s.size();      // 输出 5（当前字符串长度，同 length()）
cout << s.length();    // 输出 5（与 size() 功能完全一致，历史兼容）
cout << s.capacity();  // 输出当前内存可容纳的字符数（≥ size()，避免频繁扩容）
cout << s.empty();     // 输出 false（判断是否为空，空则返回 true）
cout << s.max_size();  // 输出当前系统支持的最大字符串长度（一般非常大）
```

#### 3. 字符访问（3 种方式）

`std::string` 支持**类似数组的下标访问**，也支持安全的边界检查：

- **下标运算符 `[]`**：无边界检查，越界访问会导致未定义行为（效率高）；
- **成员函数 `at()`**：有边界检查，越界会抛出 `out_of_range` 异常（安全）；
- **迭代器**：适合遍历或修改字符（STL 算法通用）。



```cpp
string s = "Hello";
cout << s[1];          // 输出 'e'（无检查）
cout << s.at(2);       // 输出 'l'（有检查）

// 迭代器遍历
for (string::iterator it = s.begin(); it != s.end(); ++it) {
    *it = toupper(*it);  // 修改字符为大写
}
cout << s;              // 输出 "HELLO"
```

### 三、核心操作：修改与拼接

#### 1. 字符串拼接（4 种常用方式）

`std::string` 支持灵活的拼接，无需手动管理内存：

```cpp
string s1 = "Hello", s2 = "World";

// 1. 使用 += 运算符（效率高，优先推荐） 原地操作
s1 += " ";       // s1 变为 "Hello "
s1 += s2;        // s1 变为 "Hello World"

// 2. 使用 append() 成员函数（支持多种参数）
s1.append(3, '!');  // 追加 3 个 '!'，s1 变为 "Hello World!!!"
s1.append(s2, 2, 3); // 追加 s2 从索引 2 开始的 3 个字符（"rld"），s1 变为 "Hello World!!!rld"

// 3. 使用 + 运算符（会产生临时对象，效率略低，适合短字符串）
string s3 = s1 + " " + s2;  // s3 为 "Hello World!!!rld World"

// 4. 使用 insert() 插入到指定位置
s1.insert(5, ",");  // 在索引 5 处插入 ","，s1 变为 "Hello,, World!!!rld"
```

#### 2. 字符串修改（清空、替换、截取）

- **清空字符串**：`clear()` 直接清空内容（长度变为 0，容量可能保留）；
- **替换字符**：`replace()` 替换指定范围的字符；
- **截取子串**：`substr()` 获取指定范围的子串（注意：参数是**「起始索引」和「长度」**，而非结束索引）。

```cpp
string s = "Hello World";

s.clear();  // 清空，s 变为空字符串
s = "Hello World";  // 重新赋值

// 替换：从索引 6 开始的 5 个字符（"World"）替换为 "C++"
s.replace(6, 5, "C++");  // s 变为 "Hello C++"

// 截取子串：从索引 6 开始，截取 3 个字符（"C++"）
string sub = s.substr(6, 3);  // sub = "C++"

// 截取到末尾：只传起始索引（从索引 5 开始到末尾）
string sub2 = s.substr(5);  // sub2 = " C++"
```

### 四、高级功能：查找、比较与转换

#### 1. 字符串查找（`find()` 系列函数）

`std::string` 提供一套查找函数，返回匹配子串的**起始索引**（未找到则返回 `string::npos`，一个静态常量，表示 “无效索引”）：

> 字符串下标从0开始

| 函数名               | 功能描述                          | 示例                                    |
| -------------------- | --------------------------------- | --------------------------------------- |
| `find(str)`          | 从开头查找子串 str 的第一个位置   | `s.find("lo")` → 返回 3（s="Hello"）    |
| `rfind(str)`         | 从末尾查找子串 str 的最后一个位置 | `s.rfind("l")` → 返回 3（s="Hello"）    |
| `find_first_of(str)` | 查找 str 中任意字符的第一个位置   | `s.find_first_of("ow")` → 返回 4（'o'） |
| `find_last_of(str)`  | 查找 str 中任意字符的最后一个位置 | `s.find_last_of("le")` → 返回 3（'l'）  |



```cpp
string s = "Hello World";
size_t pos = s.find("World");  // pos = 6（找到）
if (pos != string::npos) {
    cout << "找到子串，起始索引：" << pos << endl;
}

pos = s.find("C++");  // pos = string::npos（未找到）
if (pos == string::npos) {
    cout << "未找到子串" << endl;
}
```

#### 2. 字符串比较（`compare()` 或运算符）

`std::string` 支持直接用关系运算符（`==`、`!=`、`<`、`>` 等）比较，也可通过 `compare()` 函数获取更精细的比较结果（按**字典序**比较）：

- 运算符比较：返回 `bool`（`s1 == s2` 判断是否相等，`s1 < s2` 判断是否字典序更小）；
- `compare()` 函数：返回 `int`（0 表示相等，正数表示 s1 更大，负数表示 s1 更小）。

示例：

```cpp
string s1 = "Apple", s2 = "Banana";

cout << (s1 == s2);  // 输出 0（不相等）
cout << (s1 < s2);   // 输出 1（'A' 字典序小于 'B'）

int res = s1.compare(s2);  // res = -1（s1 < s2）
res = s1.compare(1, 3, "ppl");  // 比较 s1 从索引1开始的3个字符（"ppl"）与 "ppl" → 返回 0
```

#### 3. 与 C 风格字符串的转换

`std::string` 与 C 风格字符数组（`char*`）的转换是高频需求，需注意安全：

- **string → char***：通过 `c_str()`或`data()`成员函数（C++17 后`data ()` 可返回非 const 指针）；
	- 注意：返回的指针指向 `string` 内部缓冲区，**不能手动释放**，且 `string` 修改后指针可能失效。

- **char\* → string**：直接用 `string` 构造函数或赋值运算符（自动处理长度，无需担心 `\0`）。

```cpp
// string → char*
string s = "Hello";
const char* c_str1 = s.c_str();  // 必须用 const 接收（C++17 前）
char* c_str2 = s.data();        // C++17 后可返回非 const 指针（修改 c_str2 会影响 s）

// char* → string
char c_arr[] = "World";
string s2 = c_arr;  // 直接转换，s2 = "World"
```

### 五、注意事项（避坑指南）

1. **`string::npos` 的类型**：`npos` 是 `size_t` 类型（无符号整数），与 `int` 比较可能出错（如 `int pos = s.find("a"); if (pos == string::npos)` 会因类型不匹配导致逻辑错误，应使用 `size_t pos`）。

2. **空字符串的处理**：`string s;` 是合法空字符串，`s.size()` 为 0，可直接拼接或赋值，无需初始化 `\0`。

3. **内存管理**：`string` 自动管理内存，无需手动 `malloc`/`free`，但频繁修改（如大量 `+=`）可能触发扩容（性能损耗），可提前用 `reserve(n)` 预分配容量（避免频繁扩容）：

	```cpp
	string s;
	s.reserve(1000);  // 预分配可容纳 1000 个字符的内存，后续拼接更高效
	```

4. **迭代器失效**：当 `string` 的容量发生变化（如 `push_back`、`insert` 导致扩容）时，之前的迭代器（`begin()`、`end()` 等）会失效，访问失效迭代器会导致未定义行为。

### 六、常用场景示例

#### 场景 1：读取整行字符串（含空格）

`cin` 默认以空格 / 换行分割，读取整行需用 `getline()`：

```cpp
string line;
getline(cin, line);  // 读取整行（包括空格），直到换行符（换行符不存入字符串）
cout << line << endl;
```

#### 场景 2：分割字符串（按指定字符）

利用 `find()` 和 `substr()` 实现简单分割（如按逗号分割）：

```cpp
string s = "apple,banana,orange";
vector<string> parts;
size_t start = 0;
size_t pos = s.find(',');

while (pos != string::npos) {
    parts.push_back(s.substr(start, pos - start));  // 截取 [start, pos)
    start = pos + 1;  // 更新起始位置
    pos = s.find(',', start);  // 从新起始位置继续查找
}
parts.push_back(s.substr(start));  // 添加最后一部分

// 输出分割结果：apple banana orange
for (auto& part : parts) {
    cout << part << " ";
}
```

综上，`std::string` 是 C++ 处理字符串的首选工具，其成员函数覆盖了绝大多数字符串操作场景，结合 STL 算法（如 `sort`、`reverse`）可进一步扩展功能，建议优先使用而非手动管理 `char[]`。



# 前缀和 prefix

## 一、前缀和的本质：什么是前缀和？

前缀和（Prefix Sum）是一种**预处理数组的技术**，核心思想是「提前计算数组中从起始位置到每个索引的累加和」，从而将后续的区间和查询从「O (n) 时间」优化为「O (1) 时间」。

### 1. 数学定义

对于一个长度为 `n` 的数组 `nums`（索引从 `0` 开始），其**前缀和数组** `prefix`（通常长度为 `n+1`，索引从 `0` 开始）的定义为：

- `prefix[0] = 0`（边界值，代表 “前 0 个元素的和”，方便计算）

- `prefix[1] = nums[0]`（前 1 个元素的和，即 `nums[0]`）
- `prefix[2] = nums[0] + nums[1]`（前 2 个元素的和）
- ...
- `prefix[k] = nums[0] + nums[1] + ... + nums[k-1]`（前 `k` 个元素的和，对应原数组 `nums[0..k-1]` 的累加）

### 2. 直观案例

以数组 `nums = [1, 2, 3, 4]` 为例，其前缀和数组 `prefix` 的计算过程如下：

| 原数组索引 |  nums[0]  |  nums[1]  |  nums[2]  |  nums[3]  |           |
| :--------: | :-------: | :-------: | :-------: | :-------: | :-------: |
|  原数组值  |     1     |     2     |     3     |     4     |           |
| 前缀和索引 | prefix[0] | prefix[1] | prefix[2] | prefix[3] | prefix[4] |
|  前缀和值  |     0     |     1     |     3     |     6     |    10     |

## 二、前缀和的核心作用：为什么要用前缀和？

前缀和的核心价值是**降维优化**—— 将 **多"次区间和查询” 的时间复杂度从 O (n) 降到 O (1)，避免重复计算**。

### 1. 快速计算任意区间和

这是前缀和最基础的应用。对于原数组 `nums` 中**从索引 `i` 到 `j` 的区间和**（即 `nums[i] + nums[i+1] + ... + nums[j]`，闭区间）

#### 对比：直接计算 vs 前缀和计算

| 计算方式     | 单次区间和时间            | 多次查询（如 100 次）时间 | 适用场景             |
| ------------ | ------------------------- | ------------------------- | -------------------- |
| 直接遍历区间 | O(j-i+1)                  | O(100*(j-i+1))            | 单次查询、小规模数组 |
| 前缀和预处理 | 预处理 O (n) + 查询 O (1) | O(n + 100*1)              | 多次查询、大规模数组 |

## 三、前缀和的实现方式

前缀和的实现非常简洁，分为「构建前缀和数组」和「使用前缀和查询区间和」两步，以下用 C++ 代码示例说明。

> 核心递推公式：prefix[i]=prefix[i-1]+nums[i-1] ;

### 1. 基础实现（数组版）

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4};
    int n = nums.size();
    
    // 1. 构建前缀和数组（长度 n+1，prefix[0] = 0）
    vector<int> prefix(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        prefix[i] = prefix[i - 1] + nums[i - 1];  // 核心递推公式
    }
    
    // 2. 查询任意区间和：nums[i..j]（i、j为原数组索引，0<=i<=j<n）
    int i = 1, j = 3;  // 对应 nums[1]到nums[3]：2+3+4
    int range_sum = prefix[j + 1] - prefix[i];
    cout << "区间和：" << range_sum << endl;  // 输出 9
    
    return 0;
}
```

### 2. 优化实现（变量版，空间 O (1)）

如果不需要保存完整的前缀和数组，仅需 “实时计算前缀和”（如你之前的最大子数组和问题），可以**用单个变量替代数组**，将空间复杂度从 O (n) 优化为 O (1)：

> 核心公式：current_prefix=current_prefix+num;

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4};
    int current_prefix = 0;  // 实时记录当前前缀和（替代数组）
    
    for (int num : nums) {
        current_prefix += num;  // 每遍历一个元素，更新前缀和
        cout << "当前前缀和（前" << &num - &nums[0] + 1 << "个元素）：" << current_prefix << endl;
    }
    // 输出：1（前1个）、3（前2个）、6（前3个）、10（前4个）
    return 0;
}
```

## 四、前缀和的典型应用场景

前缀和不仅能计算区间和，还能结合其他逻辑解决更复杂的问题，以下是 3 个高频场景：

### 1. 场景 1：最大子数组和

核心思路：**子数组和 = 当前前缀和 - 之前的最小前缀和**。通过维护 “最小前缀和”，实时计算每个位置的最大子数组和。

- 案例：

	```
	nums = [-2, 1, -3, 4]
	```

	- 前缀和序列：`0, -2, -1, -4, 0`
	- 最小前缀和变化：`0 → 0（min(0,-2)）→ 0（min(0,-1)）→ -4（min(0,-4)）→ -4（min(-4,0)）`
	- 最大子数组和：`max(-2-0, -1-0, -4-0, 0-(-4)) = max(-2,-1,-4,4) = 4`（对应子数组 `[4]`）

### 2. 场景 2：统计 “和为 k 的子数组个数”

问题描述：给定数组 `nums` 和整数 `k`，求有多少个连续子数组的和等于 `k`。

- 核心逻辑：若 `prefix[j+1] - prefix[i] = k`，则子数组 `nums[i..j]` 的和为 `k`。因此，只需统计每个 `prefix[j+1]` 对应的 `prefix[i] = prefix[j+1] - k` 出现的次数。

- 案例：

	```
	nums = [1,1,1]，k=2
	```

	- 前缀和序列：`0,1,2,3`

	- 遍历前缀和时，统计`prefix[j+1]-k`出现的次数：

		- `j=0`：`prefix[1]-2 = -1`（次数 0）
		- `j=1`：`prefix[2]-2 = 0`（次数 1，对应子数组 `[0..1]`）
		- `j=2`：`prefix[3]-2 = 1`（次数 1，对应子数组 `[1..2]`）

	- 总个数：2。

### 3. 场景 3：二维前缀和（矩阵区间和）

将前缀和扩展到二维数组（矩阵），可快速计算任意子矩阵的和。

- 定义：对于矩阵 `matrix`，二维前缀和 `prefix[i][j]` 表示 “以 `matrix[0][0]` 为左上角、`matrix[i-1][j-1]` 为右下角的子矩阵和”。
- 公式：
	1. 构建二维前缀和：`prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]`（避免重复加重叠区域）
	2. 查询子矩阵和（左上角 `(x1,y1)`，右下角 `(x2,y2)`）：`prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]`

## 五、使用前缀和的注意事项

1. **前缀和数组的长度选择**：

	必须定义为 `n+1`（而非 `n`），且 `prefix[0] = 0`—— 这是为了避免处理 `i=0` 时的边界问题。

2. **负数和溢出问题**：

	- 若原数组包含负数，前缀和可能会出现递减（如 `nums = [-2,1]`，前缀和为 `0,-2,-1`），此时需注意 “最小前缀和” 的维护（如最大子数组和问题）。
	- 若数组元素较大或长度较长，前缀和可能超出 `int` 范围（如 `nums` 有 `1e5` 个 `1e5`，总和为 `1e10`），需用 `long long` 类型存储前缀和（C++）或 `long` 类型（Java）。

3. **适用场景的局限性**：

	前缀和仅适用于「静态数组」（即数组元素不修改）。若数组元素频繁修改（如插入、删除、更新），前缀和的预处理会失效，此时需用「线段树」或「树状数组」等数据结构。

## 总结

前缀和是一种 **“以空间换时间” 的经典预处理技术**，核心价值是**将区间和查询从 O (n) 优化到 O (1)**。它的实现简单，但能解决大量数组区间相关的问题（如最大子数组和、和为 k 的子数组、矩阵区间和等），是算法入门阶段必须掌握的基础工具。

理解前缀和的关键是记住两个公式：

1. 前缀和递推公式：`prefix[i] = prefix[i-1] + nums[i-1]`
2. 区间和计算公式：`nums[i..j] 的和 = prefix[j+1] - prefix[i]`



# 矩阵 matrix

矩阵（Matrix）是**二维有序数据集合**，由 `m` 行 `n` 列元素组成（记为 `m×n` 矩阵），是数据结构中 “多维数组” 的核心应用场景，也是算法设计中处理批量结构化数据的基础工具。其本质是将线性数据按 “行 - 列” 二维逻辑组织，兼顾存储效率与访问便捷性，广泛应用于数学计算、图像处理、图论、动态规划等领域。

### 一、矩阵的核心定义与基本概念

矩阵在编程中本质是**二维数组**，但根据存储需求和底层实现，分为两种核心表示方式：

|         表示方式          |                        底层结构                        |               优点                |                   缺点                    |                      适用场景                       |
| :-----------------------: | :----------------------------------------------------: | :-------------------------------: | :---------------------------------------: | :-------------------------------------------------: |
| 稠密矩阵（Dense Matrix）  | 连续二维数组（如 C++ `int a[m][n]`、Java `int[][] a`） | 随机访问效率高（O (1)），实现简单 |      存储空间固定，稀疏数据浪费内存       |          元素密度高（如数值计算、小矩阵）           |
| 稀疏矩阵（Sparse Matrix） |               三元组表、十字链表、哈希表               |     仅存储非零元素，节省内存      | 访问 / 修改效率较低（O (logn)），实现复杂 | 非零元素占比低（如 < 5%，如图论邻接矩阵、图像处理） |

#### （1）稠密矩阵的实现

最常用的实现方式，利用二维数组的连续存储特性，支持快速索引：



```cpp
#include <iostream>
#include <vector>
using namespace std;

// 定义 m×n 稠密矩阵（vector<vector<int>> 动态二维数组，更灵活）
class DenseMatrix {
private:
    int rows;    // 行数
    int cols;    // 列数
    vector<vector<int>> data; // 存储元素的二维向量

public:
    // 构造函数：初始化 m×n 矩阵，默认元素为 0
    DenseMatrix(int m, int n) : rows(m), cols(n), data(m, vector<int>(n, 0)) {}

    // 访问第 i 行第 j 列元素（0-based 索引）
    int& operator()(int i, int j) {
        if (i < 0 || i >= rows || j < 0 || j >= cols) {
            throw out_of_range("索引越界");
        }
        return data[i][j];
    }
};
```

#### （2）稀疏矩阵的实现（三元组表法）

稀疏矩阵的核心是 “只存非零元素”，**三元组表法**是最简洁的实现：用一个一维数组存储每个非零元素的 `(行号, 列号, 值)`，适合非零元素较少的场景：

```cpp
#include <iostream>
#include <vector>
#include <tuple> // 用于存储三元组 (row, col, value)
using namespace std;

class SparseMatrix {
private:
    int rows;    // 原矩阵行数
    int cols;    // 原矩阵列数
    int non_zero; // 非零元素个数
    // 三元组列表：每个元素是 (row, col, value)，按行优先排序
    vector<tuple<int, int, int>> triples;

public:
    SparseMatrix(int m, int n) : rows(m), cols(n), non_zero(0) {}

    // 插入非零元素（若已存在则更新）
    void insert(int i, int j, int val) {
        if (i < 0 || i >= rows || j < 0 || j >= cols) throw out_of_range("索引越界");
        if (val == 0) return; // 零元素不存储

        // 查找是否已存在该位置的元素（行优先遍历）
        for (auto& t : triples) {
            if (get<0>(t) == i && get<1>(t) == j) {
                get<2>(t) = val; // 更新值
                return;
            }
        }
        // 不存在则插入（保持行优先顺序，优化后续访问）
        triples.emplace_back(i, j, val);
        non_zero++;
    }

    // 访问第 i 行第 j 列元素（需遍历三元组表）
    int get(int i, int j) const {
        for (const auto& t : triples) {
            if (get<0>(t) == i && get<1>(t) == j) {
                return get<2>(t);
            }
        }
        return 0; // 未找到则返回 0
    }

};


```

在数据结构与线性代数中，矩阵的 “交换” 本质是通过调整元素位置满足特定算法需求（如高斯消元、快速排序、稀疏矩阵优化等），核心围绕**行交换**、**列交换**及特殊结构（上 / 下三角、对称矩阵）的交换逻辑展开。

### 二、基础交换：行交换与列交换

行交换和列交换是矩阵最核心的交换操作，本质是调整矩阵的 “行序” 或 “列序”，操作时需保证矩阵维度（行数 / 列数）不变，且交换后元素的 “行内关系” 或 “列内关系” 保留（仅位置变动）。

#### 1. 行交换（Row Swap）

**定义**：交换矩阵中任意两行的所有元素，记为 `swap(row_i, row_j)`（`i ≠ j`）。

**操作逻辑**：遍历两行的每一列，交换对应列的元素（时间复杂度 `O(n)`，`n` 为矩阵列数）。

**常用场景**：

- **高斯消元法**：找到当前列（主元列）中 “非零主元” 所在行，与当前行交换，避免除数为 0（如将 `[[0,2],[1,3]]` 交换第 1、2 行得到 `[[1,3],[0,2]]`，便于后续消元）。
- **快速排序（矩阵行排序）**：以某一列元素为 “基准值”，交换行位置实现按列排序（如按第一列升序排列矩阵，交换行使基准值左侧行的第一列元素更小）。
- **稀疏矩阵优化**：交换全零行到矩阵末尾，减少无效计算（如压缩存储时忽略全零行）。

#### 2. 列交换（Column Swap）

**定义**：交换矩阵中任意两列的所有元素，记为 `swap(col_i, col_j)`（`i ≠ j`）。

**操作逻辑**：遍历矩阵的每一行，交换对应行中第 `i` 列和第 `j` 列的元素（时间复杂度 `O(m)`，`m` 为矩阵行数）。

**常用场景**：

- **矩阵转置预处理**：部分特殊矩阵（如稀疏矩阵的列优先存储）可通过列交换调整为行优先存储，简化转置操作。
- **特征工程（数据矩阵）**：交换特征列的顺序（如机器学习中调整输入特征的优先级，不改变特征本身的含义）。
- **对称矩阵修复**：若对称矩阵因误差导致 `A[i][j] ≠ A[j][i]`，可通过列交换与行交换同步，恢复对称结构。

### 三、特殊结构交换：上三角 / 下三角矩阵的交换

上三角矩阵（对角线以下元素全为 0）和下三角矩阵（对角线以上元素全为 0）的交换需**保留三角结构**，因此交换规则更严格，核心是 “仅交换对角线上 / 下的对应元素”，避免破坏全零区域。

#### 1. 上三角矩阵的交换

上三角矩阵的非零元素仅存在于 `i ≤ j`（行号 ≤ 列号）的位置，交换需满足：

- 交换**行**时：仅能交换 “非零区域无重叠” 的行（或交换后仍保持上三角结构）。例如，交换上三角矩阵的第 1 行和第 2 行，需确保交换后第 2 行的 `i > j` 位置仍为 0（实际中更常用 “对角线上元素的交换”）。
- 交换**元素**时：仅交换对角线上或对角线以上的对称位置元素（如 `A[i][j]` 和 `A[j][i]`，但因上三角矩阵中 `i > j` 时 `A[i][j] = 0`，故仅需交换 `i ≤ j` 的元素）。

**示例**：上三角矩阵交换 `(1,2)` 和 `(2,1)` 元素（但 `(2,1)` 为 0，实际无意义）；合理交换是 `(1,3)` 和 `(1,2)`（同属第 1 行的上三角区域）。

**应用场景**：上三角矩阵的 LU 分解（LU decomposition）中，交换主元列对应的上三角元素，确保分解过程中主元非零。

#### 2. 下三角矩阵的交换

下三角矩阵的非零元素仅存在于 `i ≥ j`（行号 ≥ 列号）的位置，交换规则与上三角矩阵对称：

- 交换**列**时：仅能交换 “非零区域无重叠” 的列，避免破坏下三角结构。
- 交换**元素**时：仅交换对角线上或对角线以下的对称位置元素（如 `A[i][j]` 和 `A[j][i]`，但 `i < j` 时 `A[i][j] = 0`，故仅需交换 `i ≥ j` 的元素）。

**示例**：下三角矩阵 `[[1,0,0],[2,3,0],[4,5,6]]` 中，可交换 `(2,1)`（元素 2）和 `(3,1)`（元素 4）（同属第 1 列的下三角区域），交换后仍为下三角矩阵。

**应用场景**：下三角矩阵的 Cholesky 分解（对称正定矩阵的分解）中，交换对角线下元素以优化计算效率。

### 三、扩展交换：块矩阵交换与稀疏矩阵交换

在数据结构中，矩阵常以 “块” 或 “稀疏” 形式存储（减少空间占用），其交换方法需结合存储结构优化。

#### 1. 块矩阵交换（Block Matrix Swap）

块矩阵将原矩阵划分为多个小矩阵（块），交换时直接交换 “块” 而非单个元素，时间复杂度大幅降低（从 `O(mn)` 降至 `O(1)`，仅需调整块的指针）。

**示例**：将 `4×4` 矩阵划分为 4 个 `2×2` 块 `B11, B12, B21, B22`，交换 `B11` 和 `B22` 块，等价于交换原矩阵的 `(1-2行,1-2列)` 与 `(3-4行,3-4列)` 区域。

**应用场景**：大型矩阵的并行计算（如分布式矩阵运算），通过块交换减少数据传输量。

#### 2. 稀疏矩阵交换（Sparse Matrix Swap）

稀疏矩阵（大部分元素为 0）通常用**三元组表**（`(行号, 列号, 元素值)`）或**邻接表**存储，交换时无需处理全零元素，仅需调整非零元素的 “行号” 或 “列号”：

- **行交换**：遍历三元组表，将所有行号为 `i` 的元素改为 `j`，行号为 `j` 的元素改为 `i`。
- **列交换**：同理，修改非零元素的列号。

**示例**：稀疏矩阵三元组 `[(0,1,2), (2,3,4)]` 交换第 0 行和第 2 行后，变为 `[(2,1,2), (0,3,4)]`。

**应用场景**：稀疏矩阵的高斯消元（如有限元分析中的大型线性方程组），避免无效的全零元素交换。

### 四、交换的核心性质与注意事项

1. **可逆性**：交换操作是可逆的 —— 交换两次相同的行 / 列，矩阵恢复原状（`swap(row_i, row_j)` 执行两次后，矩阵不变）。
2. **行列式影响**：行 / 列交换会改变矩阵行列式的符号（交换一次，行列式变号；交换奇数次，符号相反；交换偶数次，符号相同），这是线性代数中判断矩阵可逆性的重要依据。
3. **结构保留**：对特殊矩阵（上三角、下三角、对称、稀疏），交换需优先保证 “结构不被破坏”，否则会导致后续算法（如分解、排序）失效。

### 总结：不同场景下的交换方法选择

| 交换类型        | 核心逻辑                  | 时间复杂度              | 适用场景                     |
| --------------- | ------------------------- | ----------------------- | ---------------------------- |
| 基础行交换      | 交换整行元素              | O(n)                    | 高斯消元、行排序             |
| 基础列交换      | 交换整列元素              | O(m)                    | 特征工程、列优先存储调整     |
| 上 / 下三角交换 | 仅交换非零区域元素        | O (k)（k 为非零元素数） | 三角矩阵分解（LU、Cholesky） |
| 块矩阵交换      | 交换整块小矩阵            | O(1)                    | 大型矩阵并行计算             |
| 稀疏矩阵交换    | 仅修改非零元素的行 / 列号 | O (t)（t 为非零元素数） | 稀疏矩阵消元、压缩存储       |

通过选择合适的交换方法，可在保证算法正确性的前提下，大幅优化矩阵操作的时间与空间效率，这也是数据结构中矩阵处理的核心优化思路。





# 二叉树的遍历

二叉树的遍历是**按特定规则访问所有节点（每个节点仅访问一次）**的过程，核心分为**深度优先遍历（DFS）** 和**广度优先遍历（BFS）** 两大类。其中 DFS 根据根节点（Root）、左子树（Left）、右子树（Right）的访问顺序，细分为前序、中序、后序 3 种；BFS 最典型的实现是**层序遍历**。

```cpp
// 二叉树节点结构定义
struct TreeNode {
    int val;                // 节点值
    TreeNode* left;         // 左子节点指针
    TreeNode* right;        // 右子节点指针
    // 构造函数（简化节点初始化）
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

## 一、深度优先遍历（DFS）

DFS 的核心是 “先深后广”：优先沿一条路径访问到树的最深处（叶子节点），**再回溯访问**其他分支。实现方式分为**递归**（利用系统栈，代码简洁）和**非递归**（手动用栈模拟，避免递归栈溢出风险）。

### 1. 前序遍历（Pre-order：根 → 左 → 右）

**定义**：先访问当前根节点，再递归 / 迭代遍历左子树，最后遍历右子树。

**核心特征**：根节点的访问时机最早，是唯一能 “先拿到根” 的遍历方式。

#### 1.1 递归实现（最简洁）

```cpp
#include <iostream>
using namespace std;

// 前序遍历（递归版）
void preOrderRecursive(TreeNode* root) {
    // 终止条件：当前节点为空（子树遍历结束）
    if (root == nullptr) {
        return;
    }
    // 1. 访问当前根节点（输出值）
    cout << root->val << " ";
    // 2. 递归遍历左子树
    preOrderRecursive(root->left);
    // 3. 递归遍历右子树
    preOrderRecursive(root->right);
}
```

- **遍历结果**：`1 2 4 5 3 6 7`
- **逻辑拆解**：从根节点 1 开始，先输出 1；再深入左子树 2，输出 2 后继续深入左子树 4（输出 4，无后代）；回溯到 2 的右子树 5（输出 5）；左子树遍历完，回溯到根 1 的右子树 3，重复上述逻辑。

#### 1.2 非递归实现（栈模拟）

递归的本质是 “系统栈” 保存节点状态，非递归需手动用`stack<TreeNode*>`模拟，核心是 **“根节点先入栈，弹出时访问，再压右子树、后压左子树”**（栈是 “先进后出”，保证左子树先被处理）。

```cpp
#include <stack>
#include <iostream>
using namespace std;

// 前序遍历（非递归版）
void preOrderIterative(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    stack<TreeNode*> st;  // 手动创建栈，存储节点指针
    st.push(root);        // 根节点先入栈

    while (!st.empty()) {
        // 1. 弹出栈顶节点，访问（对应“根”的步骤）
        TreeNode* curr = st.top();
        st.pop();
        cout << curr->val << " ";

        // 2. 右子树先入栈（栈先进后出，保证左子树先处理）
        if (curr->right != nullptr) {
            st.push(curr->right);
        }
        // 3. 左子树后入栈
        if (curr->left != nullptr) {
            st.push(curr->left);
        }
    }
}
```

- **关键细节**：必须先压右子树、后压左子树，否则弹出时会先处理右子树，违背 “左→右” 的顺序。

#### 1.3 应用场景

- 复制二叉树（先复制根，再复制左右子树）；
- 生成树的前缀表达式（如波兰式，运算符在操作数前）；
- 快速获取树的 “根 - 左 - 右” 结构信息。

### 2. 中序遍历（In-order：左 → 根 → 右）

**定义**：先遍历左子树，再访问当前根节点，最后遍历右子树。

**核心特征**：对**二叉搜索树（BST）** 而言，中序遍历结果是**严格递增的有序序列**（BST 的核心性质，常用于验证 BST 合法性）。

#### 2.1 递归实现

```cpp
#include <iostream>
using namespace std;

// 中序遍历（递归版）
void inOrderRecursive(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 1. 先递归遍历左子树（深入到最左叶子）
    inOrderRecursive(root->left);
    // 2. 访问当前根节点（左子树遍历完后）
    cout << root->val << " ";
    // 3. 递归遍历右子树
    inOrderRecursive(root->right);
}
```

- **遍历结果**：`4 2 5 1 6 3 7`
- **逻辑拆解**：从根 1 开始，先深入左子树 2，再深入 2 的左子树 4（无左后代，输出 4）；回溯到 2（输出 2），遍历 2 的右子树 5（输出 5）；左子树遍历完，输出根 1；再遍历右子树 3，重复左→根→右逻辑。

#### 2.2 非递归实现（栈模拟）

核心逻辑：**先将左子树所有节点依次入栈（直到最左叶子），弹出时访问根节点，再处理右子树**。

```cpp
#include <stack>
#include <iostream>
using namespace std;

// 中序遍历（非递归版）
void inOrderIterative(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    stack<TreeNode*> st;
    TreeNode* curr = root;  // 当前节点指针，用于遍历左子树

    while (curr != nullptr || !st.empty()) {
        // 1. 遍历到左子树最深处，所有节点依次入栈
        while (curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }
        // 2. 弹出栈顶节点（左子树已处理完），访问根节点
        curr = st.top();
        st.pop();
        cout << curr->val << " ";
        // 3. 处理右子树（右子树重复“左→根→右”逻辑）
        curr = curr->right;
    }
}
```

- **关键细节**：用`curr`指针跟踪左子树遍历进度，避免重复入栈；弹出节点后，`curr`转向右子树，继续循环。

#### 2.3 应用场景

- 验证二叉搜索树（检查中序结果是否严格递增）；
- 从 BST 中获取有序数据（如升序排列的节点值）；
- 中序遍历与前序 / 后序遍历结合，可唯一重建二叉树。

### 3. 后序遍历（Post-order：左 → 右 → 根）

**定义**：先遍历左子树，再遍历右子树，最后访问当前根节点。

**核心特征**：根节点的访问时机最晚，需确保左右子树完全处理后才访问根（适合 “先处理子节点，再处理父节点” 的场景）。

#### 3.1 递归实现

```cpp
#include <iostream>
using namespace std;

// 后序遍历（递归版）
void postOrderRecursive(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 1. 递归遍历左子树
    postOrderRecursive(root->left);
    // 2. 递归遍历右子树
    postOrderRecursive(root->right);
    // 3. 最后访问当前根节点
    cout << root->val << " ";
}
```

- **遍历结果**：`4 5 2 6 7 3 1`
- **逻辑拆解**：从根 1 开始，先深入左子树 2，再深入 2 的左子树 4（无后代，输出 4）；回溯到 2 的右子树 5（输出 5）；左子树 2 的左右都处理完，输出 2；再处理根 1 的右子树 3，重复左→右→根逻辑，最后输出 1。

#### 3.2 非递归实现（栈模拟，两种思路）

后序遍历的非递归实现最复杂（需判断右子树是否已处理），常见两种思路：**双栈法**（简洁）和**标记法**（直观）。

##### 思路 1：双栈法（推荐，代码简洁）

核心逻辑：

1. 栈 1 用于按 “根→右→左” 顺序入栈（类似前序遍历的逆序）；
2. 栈 2 存储栈 1 弹出的节点，最终栈 2 的弹出顺序即为 “左→右→根”（后序）。

```cpp
#include <stack>
#include <iostream>
using namespace std;

// 后序遍历（非递归，双栈法）
void postOrderIterative1(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    stack<TreeNode*> st1, st2;
    st1.push(root);

    // 栈1按“根→右→左”弹出，存入栈2
    while (!st1.empty()) {
        TreeNode* curr = st1.top();
        st1.pop();
        st2.push(curr);  // 栈2保存弹出的节点

        // 栈1先压左子树，后压右子树（保证弹出时先右后左）
        if (curr->left != nullptr) {
            st1.push(curr->left);
        }
        if (curr->right != nullptr) {
            st1.push(curr->right);
        }
    }

    // 栈2弹出顺序即为后序遍历
    while (!st2.empty()) {
        cout << st2.top()->val << " ";
        st2.pop();
    }
}
```

##### 思路 2：标记法（直观，单栈）

核心逻辑：用`pair<TreeNode*, bool>`标记节点状态（`false`= 未处理，`true`= 已处理右子树）。首次入栈时标记`false`，弹出后若未处理，则标记`true`重新入栈，再将右子树和左子树入栈（保证左→右先处理）；若已处理，则直接访问节点。

```cpp
#include <stack>
#include <iostream>
#include <utility>  // 用于pair
using namespace std;

// 后序遍历（非递归，标记法）
void postOrderIterative2(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 栈存储：<节点指针，是否已处理右子树>
    stack<pair<TreeNode*, bool>> st;
    st.push({root, false});

    while (!st.empty()) {
        auto [curr, isProcessed] = st.top();  // C++17结构化绑定（简化代码）
        st.pop();

        if (!isProcessed) {
            // 1. 未处理：标记为已处理，重新入栈
            st.push({curr, true});
            // 2. 压入右子树（未处理）
            if (curr->right != nullptr) {
                st.push({curr->right, false});
            }
            // 3. 压入左子树（未处理）
            if (curr->left != nullptr) {
                st.push({curr->left, false});
            }
        } else {
            // 已处理右子树：访问当前节点
            cout << curr->val << " ";
        }
    }
}
```

- 兼容性说明：若编译器不支持 C++17 结构化绑定，可替换为：

	```cpp
	TreeNode* curr = st.top().first;
	bool isProcessed = st.top().second;
	st.pop();
	```


#### 3.3 应用场景

- 删除二叉树（需先删除左右子节点，再删除根节点，避免内存泄漏）；
- 计算树的高度（需先获取左右子树高度，再取最大值 + 1）；
- 生成树的后缀表达式（如逆波兰式，运算符在操作数后）。



## 二、广度优先遍历（BFS）

BFS 的核心是 “先广后深”：按树的**层级顺序**（从根到叶，同一层从左到右）访问节点，类似 “逐层扫描”。实现依赖**队列（queue）** 的 “先进先出” 特性（保证上层节点先处理）。

### 层序遍历（Level-order）

**定义**：从根节点（第 1 层）开始，依次访问第 1 层、第 2 层…… 第 k 层的所有节点，同一层内按左到右顺序访问。

#### 实现代码（队列模拟）

```cpp
#include <queue>
#include <iostream>
using namespace std;

// 层序遍历（基础版：仅输出节点值）
void levelOrderBasic(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;  // 队列存储节点指针
    q.push(root);        // 根节点先入队

    while (!q.empty()) {
        // 1. 取出队首节点，访问
        TreeNode* curr = q.front();
        q.pop();
        cout << curr->val << " ";

        // 2. 左子节点入队（先左后右，保证同一层顺序）
        if (curr->left != nullptr) {
            q.push(curr->left);
        }
        // 3. 右子节点入队
        if (curr->right != nullptr) {
            q.push(curr->right);
        }
    }
}

// 进阶版：按层输出（区分每一层，更直观）
void levelOrderWithLevel(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();  // 当前层的节点数（关键：固定当前层规模）
        cout << "第" << (q.size() ? (q.size() == 1 ? 1 : (levelSize)) : 0) << "层：";
        // 遍历当前层的所有节点
        for (int i = 0; i < levelSize; ++i) {
            TreeNode* curr = q.front();
            q.pop();
            cout << curr->val << " ";

            // 下一层节点入队
            if (curr->left != nullptr) {
                q.push(curr->left);
            }
            if (curr->right != nullptr) {
                q.push(curr->right);
            }
        }
        cout << endl;  // 每一层结束换行
    }
}
```

- **基础版遍历结果**：`1 2 3 4 5 6 7`

- 进阶版输出

	```plaintext
	第1层：1 
	第2层：2 3 
	第3层：4 5 6 7 
	```

- **关键细节**：`levelSize = q.size()` 用于固定当前层的节点数，避免下一层节点入队后干扰当前层遍历。

#### 应用场景

- 求树的最小深度（首次遇到叶子节点的层级即为最小深度）；
- 层序打印二叉树（如按 “第 1 层、第 2 层” 格式输出）；
- 二叉树的广度优先搜索（如寻找某一值的节点，优先访问上层节点）。

## 三、遍历方法对比与总结

| 遍历类型 | 访问顺序        | 实现方式       | 核心数据结构      | 关键应用场景                     | 示例结果      |
| -------- | --------------- | -------------- | ----------------- | -------------------------------- | ------------- |
| 前序遍历 | 根→左→右        | 递归 / 非递归  | 栈                | 复制二叉树、前缀表达式           | 1 2 4 5 3 6 7 |
| 中序遍历 | 左→根→右        | 递归 / 非递归  | 栈                | 验证 BST、获取有序数据           | 4 2 5 1 6 3 7 |
| 后序遍历 | 左→右→根        | 递归 / 非递归  | 栈（双栈 / 标记） | 删除二叉树、计算树高、后缀表达式 | 4 5 2 6 7 3 1 |
| 层序遍历 | 按层级（左→右） | 非递归（推荐） | 队列              | 求最小深度、层序打印             | 1 2 3 4 5 6 7 |



# 二分查找（Binary Search）

二分查找是一种**高效的查找算法**，适用于**有序的线性表**（数组 / 向量），核心思想是**分治**：通过不断缩小查找范围，将目标值与中间元素比较，每次排除一半的元素，最终找到目标或确定不存在。

### 一、核心特性

|    特性    |                             说明                             |
| :--------: | :----------------------------------------------------------: |
| 时间复杂度 | 最优 O (1)（中间元素直接命中），最坏 / 平均 O (log n)（n 为元素个数） |
| 空间复杂度 |         迭代版 O (1)，递归版 O (log n)（递归调用栈）         |
|  适用场景  | 有序数组 / 向量（静态数据，不频繁插入删除）；支持随机访问（数组适配，链表不适配） |
|   局限性   | 要求数据有序；对小规模数据，遍历（O (n)）可能更高效（无额外逻辑开销） |

### 二、基本原理

1. 初始化查找范围：左边界`left = 0`，右边界`right = n-1`（n 为数组长度）；
2. 循环条件：`left <= right`（闭区间`[left, right]`）；
3. 计算中间位置：`mid = left + (right - left) / 2`（避免`left + right`溢出）；
4. 比较中间元素与目标值：
	- 若`arr[mid] == target`：找到目标，返回 mid；
	- 若`arr[mid] > target`：目标在左半区，调整右边界`right = mid - 1`；
	- 若`arr[mid] < target`：目标在右半区，调整左边界`left = mid + 1`；
5. 循环结束未找到：返回 - 1（或其他标记）。

### 三、C++ 实现（基础版）

```cpp
#include <iostream>
#include <vector>

// 二分查找基础版：在有序数组中查找目标值，返回索引（未找到返回-1）
// arr：有序升序数组，target：目标值
int binarySearch(const std::vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1; // 闭区间 [left, right]

    while (left <= right) {
        // 计算mid：避免left+right溢出（等价于 (left+right)/2，但更安全）
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid; // 找到目标，返回索引
        } else if (arr[mid] > target) {
            right = mid - 1; // 目标在左半区，缩小右边界
        } else {
            left = mid + 1; // 目标在右半区，缩小左边界
        }
    }

    return -1; // 未找到目标
}


```

#### 四、进阶场景（处理重复元素）

二分查找的核心变种是**找边界**（第一个 / 最后一个等于 target 的元素），适用于数组含重复元素的场景。

##### 1. 找第一个等于 target 的元素

```cpp
int findFirst(const std::vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    int result = -1; // 记录第一个匹配的索引

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            result = mid;    // 暂存结果
            right = mid - 1; // 继续向左找更早的匹配
        } else if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}
```

##### 2. 找最后一个等于 target

```cpp
int findLast(const std::vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            result = mid;    // 暂存结果
            left = mid + 1;  // 继续向右找更晚的匹配
        } else if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}
```

#### 五、递归实现（理解分治思想）



```cpp
int binarySearchRecursive(const std::vector<int>& arr, int target, int left, int right) {
    // 递归终止条件：查找范围为空
    if (left > right) {
        return -1;
    }

    int mid = left + (right - left) / 2;
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] > target) {
        // 递归查找左半区
        return binarySearchRecursive(arr, target, left, mid - 1);
    } else {
        // 递归查找右半区
        return binarySearchRecursive(arr, target, mid + 1, right);
    }
}

// 封装递归调用（对外接口）
int binarySearchRecursiveWrapper(const std::vector<int>& arr, int target) {
    return binarySearchRecursive(arr, target, 0, arr.size() - 1);
}
```

#### 六、关键注意事项

1. **避免溢出**：计算`mid`时，不要用`(left + right) / 2`（当 left 和 right 接近 INT_MAX 时会溢出），改用`left + (right - left) / 2`；

2. 区间定义

  - 闭区间`[left, right]`：循环条件`left <= right`，调整边界时`right = mid - 1`/`left = mid + 1`；

  - 开区间`[left, right)`：循环条件`left < right`，调整边界时`right = mid`/`left = mid + 1`（需注意右边界初始值为`arr.size()`）；

  	> 即mid不符合条件时需要被排除在外

3. **重复元素处理**：核心是 “找到匹配后不立即返回，继续向边界方向缩小范围”；

4. STL 库支持：C++ STL 提供`std::binary_search`（判断是否存在）、`std::lower_bound`（第一个≥target 的元素）、`std::upper_bound`（第一个 > target 的元素），底层均基于二分查找实现：

	```cpp
	#include <algorithm> // 需包含头文件
	
	// 示例：使用STL的lower_bound找第一个≥target的元素
	auto it = std::lower_bound(sortedArr.begin(), sortedArr.end(), 7);
	if (it != sortedArr.end() && *it == 7) {
	    std::cout << "STL找到目标索引：" << it - sortedArr.begin() << std::endl;
	}
	```

	

#### 七、应用场景

- 有序数组的快速查找（如字典、通讯录检索）；
- 二分答案（如 “最小满足条件的值”“最大可行解”，例：木材切割、平方根求解）；
- 有序数组的边界查找（如统计目标值出现次数：`findLast - findFirst + 1`）。

总结：二分查找的核心是**有序性**和**分治缩小范围**，掌握基础版后，重点理解 “边界查找” 的变种逻辑，这是解决多数二分查找面试题的关键。



# 栈（Stack）

栈是一种**线性数据结构**，核心遵循 **后进先出（LIFO, Last In First Out）** 原则：仅允许在栈的一端（称为「栈顶」，Top）进行插入（入栈）和删除（出栈）操作，另一端（栈底，Bottom）固定不可操作。

### 一、核心特性

|    特性    |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|  操作特性  |     仅栈顶可操作（入栈 / 出栈 / 查看栈顶），栈底不可访问     |
| 时间复杂度 |         入栈、出栈、查看栈顶：O (1)（无遍历 / 移位）         |
| 空间复杂度 | 动态栈（如基于 vector）：O (n)（n 为元素个数）；静态栈（数组）：O (n) |
|  适用场景  | 逆序处理、临时数据缓存、嵌套结构匹配（括号 / 函数调用）、回溯算法等 |
|  实现方式  |        数组（静态栈 / 动态扩容数组）、链表（链式栈）         |

### 二、核心操作

栈的基础操作仅有 5 个，语义清晰且无歧义：

| 操作名称  |                             说明                             |
| :-------: | :----------------------------------------------------------: |
| `push()`  | 入栈：将元素添加到栈顶（栈满时静态栈会溢出，动态栈自动扩容） |
|  `pop()`  |       出栈：移除栈顶元素（栈空时操作无意义，需先判空）       |
|  `top()`  |    查看栈顶：返回栈顶元素的值（不修改栈，栈空时访问非法）    |
| `empty()` |              判空：返回栈是否为空（true/false）              |
| `size()`  |                   大小：返回栈中元素的个数                   |

### 三、栈的实现方式

C++ 中栈有两种常见实现思路：**基于数组（vector）**（更高效，缓存友好）和**基于链表**（灵活，无扩容开销）；同时 STL 提供了现成的`std::stack`容器适配器。（默认底层用`deque`，也可指定`vector`/`list`），封装了栈的核心操作，无需手动实现：

```cpp
#include <iostream>
#include <stack> // 需包含头文件
#include <vector>

int main() {
    // 定义栈：默认底层deque，存储int
    std::stack<int> st;

    // 自定义底层容器（如vector）
    std::stack<int, std::vector<int>> st_vec;

    // 入栈
    st.push(1);
    st.push(2);
    st.push(3);

    // 查看栈顶
    std::cout << "栈顶：" << st.top() << std::endl; // 3

    // 出栈
    st.pop();
    std::cout << "出栈后栈顶：" << st.top() << std::endl; // 2

    // 判空 & 大小
    std::cout << "是否为空：" << (st.empty() ? "是" : "否") << std::endl; // 否
    std::cout << "元素个数：" << st.size() << std::endl; // 2

    return 0;
}
```

### 四、栈的经典应用场景

##### 1. 括号匹配（算法面试高频）

判断字符串中的括号（`()[]{}`）是否成对且合法，核心思路：

- 遇到左括号入栈；
- 遇到右括号，若栈空或栈顶左括号不匹配则非法，否则出栈；
- 最终栈空则合法，否则非法。

```cpp
#include <iostream>
#include <stack>
#include <unordered_map>
#include <string>

bool isValidParentheses(const std::string& s) {
    std::stack<char> st;
    // 右括号 -> 左括号的映射
    std::unordered_map<char, char> map = {{')', '('}, {'}', '{'}, {']', '['}};

    for (char c : s) {
        // 左括号：入栈
        if (map.find(c) == map.end()) {
            st.push(c);
        } else {
            // 右括号：检查匹配
            if (st.empty() || st.top() != map[c]) {
                return false;
            }
            st.pop();
        }
    }

    return st.empty(); // 栈空才完全匹配
}

int main() {
    std::string s1 = "()[]{}";
    std::string s2 = "([)]";
    std::cout << s1 << " 是否合法：" << (isValidParentheses(s1) ? "是" : "否") << std::endl; // 是
    std::cout << s2 << " 是否合法：" << (isValidParentheses(s2) ? "是" : "否") << std::endl; // 否
    return 0;
}
```

##### 2. 函数调用栈（程序运行底层）

程序执行函数时，系统会为每个函数创建「栈帧」并压入调用栈：

- 主函数`main()`调用函数 A → A 的栈帧入栈；

- A 调用函数 B → B 的栈帧入栈；

- B 执行完毕 → B 的栈帧出栈；

- A 执行完毕 → A 的栈帧出栈；

- 回到`main()`继续执行。（栈溢出即调用栈过深，如无限递归）


##### 3. 逆序输出 / 逆序处理

```cpp
#include <iostream>
#include <stack>
#include <string>

// 字符串逆序
std::string reverseString(const std::string& s) {
    std::stack<char> st;
    for (char c : s) {
        st.push(c);
    }
    std::string res;
    while (!st.empty()) {
        res += st.top();
        st.pop();
    }
    return res;
}

int main() {
    std::string s = "hello stack";
    std::cout << "原字符串：" << s << std::endl;
    std::cout << "逆序后：" << reverseString(s) << std::endl; // kcats olleh
    return 0;
}
```

##### 4. 表达式求值（中缀转后缀 / 前缀）

计算器的核心逻辑：先将中缀表达式（如`1+2*3`）转为后缀表达式（`1 2 3 * +`），再用栈求值，避免优先级判断的复杂逻辑。

### 五、关键注意事项

1. **栈空判断**：执行`pop()`/`top()`前必须先调用`empty()`，否则会触发未定义行为（数组栈可能越界，链式栈可能访问空指针）；

2. **内存管理**：链式栈需手动释放节点（析构函数中遍历删除），避免内存泄漏；数组栈（vector）无需手动管理，vector 会自动释放；

3. **STL 栈的限制**：`std::stack`不支持随机访问（无法直接访问栈中间元素），若需遍历需先出栈并暂存；

4. 静态栈 vs 动态栈

	- 静态栈（固定大小数组）：易溢出，但无扩容开销；

- 动态栈（vector / 链表）：自动扩容，无溢出风险，但扩容时有内存拷贝开销（vector）。

### 六、栈与队列的区别

| 维度     | 栈（Stack）              | 队列（Queue）              |
| -------- | ------------------------ | -------------------------- |
| 操作原则 | 后进先出（LIFO）         | 先进先出（FIFO）           |
| 操作端   | 仅栈顶（单端操作）       | 队尾入、队头出（双端操作） |
| 核心操作 | push/pop/top             | push/pop/front/back        |
| 典型应用 | 括号匹配、函数调用、回溯 | 任务排队、BFS 遍历         |

总结：栈是极简的线性结构，核心价值在于 “限制操作顺序”，其 LIFO 特性完美适配需要 “最后处理的任务最先完成” 的场景。实际开发中优先使用 STL 的`std::stack`，手动实现（数组 / 链表）主要用于理解底层原理。



# 堆（Heap）详解

堆是一种**完全二叉树**结构的**非线性数据结构**，核心特性是「堆序性」：

- 大顶堆（Max-Heap）：每个父节点的值 ≥ 其子节点的值，堆顶（根节点）是最大值；
- 小顶堆（Min-Heap）：每个父节点的值 ≤ 其子节点的值，堆顶是最小值。

堆的底层通常用**数组**存储（完全二叉树的数组存储无空洞，效率高），是优先队列、堆排序的核心底层结构。

> 完全二叉树：按层序遍历的顺序紧凑排列，仅最后一层可能不满切所有节点靠左

### 一、核心特性

|    特性    |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|  结构特性  |                          完全二叉树                          |
|  堆序特性  | 大顶堆：父≥子；小顶堆：父≤子（仅父子关系，兄弟节点无顺序要求） |
| 时间复杂度 | 插入 / 删除堆顶：O (log n)；查找堆顶：O (1)；堆排序：O (n log n) |
| 空间复杂度 |                O (n)（数组存储，无额外开销）                 |
|  适用场景  |     优先队列（任务调度）、Top K 问题、中位数维护、堆排序     |

### 二、堆的数组存储规则

完全二叉树的数组存储（索引从 0 开始）：

- 对于索引为`i`的节点：

	- 左孩子索引：`2*i + 1`；
	- 右孩子索引：`2*i + 2`；
	- 父节点索引：`(i - 1) / 2`（整数除法，向下取整）。

示例（大顶堆）

```plaintext
        10
       /  \
      8    9
     / \  /
    5  3 7
```

数组存储：`[10, 8, 9, 5, 3, 7]`

### 三、堆的核心操作

堆的核心操作是「上浮（Sift Up）」和「下沉（Sift Down）」，分别用于插入和删除堆顶时维护堆序性。

##### 1. 上浮（Sift Up）

插入新元素时，将元素放在**数组末尾**，然后向上与父节点比较：

- 大顶堆：若当前节点 > 父节点，交换两者，重复直到堆序恢复；
- 小顶堆：若当前节点 < 父节点，交换两者，重复直到堆序恢复。

##### 2. 下沉（Sift Down）

删除堆顶时，**将最后一个元素移到堆顶**，然后向下与子节点比较：

- 大顶堆：选择左右孩子中较大的一个，若当前节点 < 该孩子，交换，重复直到堆序恢复；
- 小顶堆：选择左右孩子中较小的一个，若当前节点 > 该孩子，交换，重复直到堆序恢复。



### 四、C++ STL 中的堆（优先队列）

C++ STL 没有直接的「堆」容器，但提供了：

1. `std::priority_queue`：优先队列，底层基于堆实现（默认大顶堆）；
2. 堆算法：`std::make_heap`/`std::push_heap`/`std::pop_heap`（操作 vector 模拟堆）。

##### 1. std::priority_queue

```cpp
#include <iostream>
#include <queue>
#include <vector>

int main() {
    // 1. 默认大顶堆（存储int，底层vector）
    std::priority_queue<int> maxPQ;
    maxPQ.push(3);
    maxPQ.push(1);
    maxPQ.push(5);
    std::cout << "大顶堆顶：" << maxPQ.top() << std::endl; // 5
    maxPQ.pop();
    std::cout << "pop后堆顶：" << maxPQ.top() << std::endl; // 3

    // 2. 小顶堆（需指定比较器）
    std::priority_queue<int, std::vector<int>, std::greater<int>> minPQ;
    minPQ.push(3);
    minPQ.push(1);
    minPQ.push(5);
    std::cout << "小顶堆顶：" << minPQ.top() << std::endl; // 1

    // 3. 自定义类型（如pair，需指定比较规则）
    // 示例：优先队列存储{优先级, 任务}，按优先级小顶堆
    using PQElement = std::pair<int, std::string>;
    std::priority_queue<PQElement, std::vector<PQElement>, 
                        std::greater<PQElement>> taskPQ;
    taskPQ.emplace(2, "任务B");
    taskPQ.emplace(1, "任务A");
    taskPQ.emplace(3, "任务C");
    std::cout << "最高优先级任务：" << taskPQ.top().second << std::endl; // 任务A

    return 0;
}
```

##### 2. STL 堆算法（手动操作 vector）

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 堆算法头文件

int main() {
    std::vector<int> vec = {3, 1, 4, 1, 5, 9};

    // 1. 构建大顶堆（默认）
    std::make_heap(vec.begin(), vec.end());
    std::cout << "堆顶：" << vec[0] << std::endl; // 9

    // 2. 插入元素（先push_back，再push_heap）
    vec.push_back(6);
    std::push_heap(vec.begin(), vec.end());
    std::cout << "插入后堆顶：" << vec[0] << std::endl; // 9

    // 3. 删除堆顶（先pop_heap，再pop_back）
    std::pop_heap(vec.begin(), vec.end()); // 堆顶移到末尾
    vec.pop_back();
    std::cout << "删除后堆顶：" << vec[0] << std::endl; // 6

    // 4. 小顶堆（指定比较器）
    std::make_heap(vec.begin(), vec.end(), std::greater<int>());
    std::cout << "小顶堆顶：" << vec[0] << std::endl; // 1

    return 0;
}
```

### 五、堆的经典应用

##### 1. Top K 问题（找数组中前 K 大 / 小的元素）

**思路（找前 K 大）**：用小顶堆存储前 K 个元素，遍历数组时：

- 若堆大小 < K，直接入堆；
- 若当前元素 > 堆顶（小顶堆的最小值），弹出堆顶，插入当前元素；
- 最终堆中元素即为前 K 大。

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

std::vector<int> topK(const std::vector<int>& arr, int k) {
    if (k <= 0 || arr.empty()) return {};
    if (k >= arr.size()) return arr;

    // 小顶堆
    std::priority_queue<int, std::vector<int>, std::greater<int>> minPQ;

    for (int num : arr) {
        if (minPQ.size() < k) {
            minPQ.push(num);
        } else if (num > minPQ.top()) {
            minPQ.pop();
            minPQ.push(num);
        }
    }

    // 转换为vector
    std::vector<int> res;
    while (!minPQ.empty()) {
        res.push_back(minPQ.top());
        minPQ.pop();
    }
    // 逆序（前K大按降序输出）
    std::reverse(res.begin(), res.end());
    return res;
}

```

##### 2. 堆排序

**思路**：

1. 将数组构建为大顶堆；
2. 反复将堆顶（最大值）与最后一个元素交换，然后对前 n-1 个元素下沉，直到堆为空。

```cpp
#include <iostream>
#include <vector>

// 下沉函数（堆排序专用）
template <typename T>
void heapSortSiftDown(std::vector<T>& arr, int n, int idx) {
    while (true) {
        int left = 2 * idx + 1;
        int right = 2 * idx + 2;
        int largest = idx;

        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }

        if (largest == idx) break;

        std::swap(arr[idx], arr[largest]);
        idx = largest;
    }
}

// 堆排序（升序）
template <typename T>
void heapSort(std::vector<T>& arr) {
    int n = arr.size();
    // 1. 构建大顶堆
    for (int i = (n - 2) / 2; i >= 0; --i) {
        heapSortSiftDown(arr, n, i);
    }

    // 2. 逐个取出堆顶
    for (int i = n - 1; i > 0; --i) {
        std::swap(arr[0], arr[i]); // 堆顶（最大）移到末尾
        heapSortSiftDown(arr, i, 0); // 对前i个元素下沉
    }
}

int main() {
    std::vector<int> arr = {5, 2, 9, 3, 7, 6, 1, 8};
    heapSort(arr);
    std::cout << "堆排序结果：";
    for (int num : arr) {
        std::cout << num << " "; // 1 2 3 5 6 7 8 9
    }
    std::cout << std::endl;
    return 0;
}
```

##### 3. 优先队列调度（任务优先级处理）

如操作系统的进程调度、电商订单优先级处理，核心是用堆维护 “最高优先级先执行”。

### 六、关键注意事项

1. 堆的构建（堆化）

	- 时间复杂度：O (n)（而非 O (n log n)，因为底层节点无需多次下沉）；
	- 起始点：从最后一个非叶子节点（`(n-2)/2`）开始，倒序下沉。

2. **索引越界**：下沉时需检查左 / 右孩子索引是否小于堆大小，避免访问数组越界。

3. STL priority_queue 的特性

	- 默认大顶堆，小顶堆需指定`std::greater<T>`；
	- 不支持随机访问，仅能访问堆顶；
	- 底层容器默认是`deque`，也可指定`vector`。

4. 堆 vs 二叉搜索树（BST）

	| 维度        | 堆                    | BST（如红黑树） |
	| ----------- | --------------------- | --------------- |
	| 核心特性    | 堆序性（父≥/≤子）     | 左 < 根 < 右    |
	| 查找        | O (n)（仅堆顶 O (1)） | O(log n)        |
	| 插入 / 删除 | O(log n)              | O(log n)        |
	| 适用场景    | 优先队列、Top K       | 有序遍历、查找  |

### 七、总结

堆的核心价值在于「快速获取极值」（堆顶 O (1)）和「动态维护有序」（插入 / 删除 O (log n)），是解决 “极值相关” 问题的最优数据结构。实际开发中：

- 优先使用`std::priority_queue`（简洁高效）；
- 需手动控制堆结构时，用`std::make_heap`等算法操作 vector；
- 手动实现堆主要用于理解上浮 / 下沉的核心逻辑（算法面试高频考点）。



# 动态规划（Dynamic Programming, DP）

动态规划是一种**解决多阶段决策最优解**的算法思想，核心是：将复杂问题拆解为**重叠子问题**，通过记录子问题的最优解（「状态」），避免重复计算，最终推导出全局最优解。

与**贪心算法 “局部最优→全局最优” 的短视决策**不同，动态规划会**枚举所有可能的子问题解**，并通过「状态转移方程」整合子问题结果，确保全局最优；与暴力递归相比，DP 通过 **“记忆化”** 消除重复计算，时间复杂度大幅降低。

### 一、核心特性

|    特性    |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|  核心思想  |       分解问题→记录子问题解→推导全局解（以空间换时间）       |
|  适用前提  | 1. 最优子结构：全局最优解包含子问题的最优解；<br>2. 重叠子问题：子问题重复出现 |
|  核心要素  |          状态定义、状态转移方程、初始条件、边界条件          |
| 时间复杂度 | 通常 O (n²) / O (nk)（n 为问题规模，k 为子问题维度），远优于暴力递归的 O (2ⁿ) |
|  实现方式  |         自顶向下（记忆化递归）、自底向上（迭代填表）         |
|  典型应用  |    背包问题、最长公共子序列、最短路径、零钱兑换、编辑距离    |

### 二、动态规划的解题步骤

1. **问题建模**：识别问题的「最优子结构」和「重叠子问题」；
2. **状态定义**：定义`dp[i]`/`dp[i][j]`的含义（核心步骤，决定 DP 的成败）；
3. **状态转移方程**：推导子问题之间的关系（如`dp[i] = f(dp[i-1], dp[i-2])`）；
4. **初始条件**：确定最小子问题的解（如`dp[0] = 0`）；
5. **边界条件**：处理特殊情况（如数组越界、空输入）；
6. **计算顺序**：自底向上（从最小子问题开始）或自顶向下（记忆化递归）。

> **最优子结构**：问题的最优解可以由其子问题的最优解推导而来，并通过子问题的最优解组合得到全局最优解。动态规划的状态转移方程就是对最优子结构的数学表达
>
> **重叠子问题：**在递归/迭代求解子问题的过程中，大量相同的子问题会被重复计算，动态规划通过“记忆化存储”（如数组，哈希表）缓存子问题的解，避免重复计算，从而将时间复杂度从暴力递归的指数级降到多项式级
>
> **本质**：子问题的重复出现是动态规划 “优化” 的前提 —— 若子问题无重叠，动态规划与普通递归 / 分治无区别。

### 三、经典案例

##### 案例 1：斐波那契数列（入门级 DP）

**问题描述**：求斐波那契数列第 n 项。

**暴力递归问题**：子问题重复计算（如 F (5) 需计算 F (4) 和 F (3)，F (4) 又需计算 F (3) 和 F (2)），时间复杂度 O (2ⁿ)。

1. 自顶向下（记忆化递归）

```cpp
#include <iostream>
#include <vector>

// 记忆化数组：存储已计算的子问题解
std::vector<int> memo;

int fibMemo(int n) {
    // 递归终止条件
    if (n == 0) return 0;
    if (n == 1) return 1;
    // 已计算过，直接返回
    if (memo[n] != -1) return memo[n];
    // 计算并存储子问题解
    memo[n] = fibMemo(n-1) + fibMemo(n-2);
    return memo[n];
}

int fib(int n) {
    if (n < 0) return -1;
    memo.resize(n+1, -1); // 初始化记忆数组
    return fibMemo(n);
}

int main() {
    std::cout << "斐波那契第10项：" << fib(10) << std::endl; // 55
    return 0;
}
```

2. 自底向上（迭代填表）

```cpp
int fibDP(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    // dp[i] 表示第i项斐波那契数
    std::vector<int> dp(n+1);
    // 初始条件
    dp[0] = 0;
    dp[1] = 1;
    // 状态转移：从子问题推导父问题
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}

// 空间优化：仅保留前两项（O(1)空间）
int fibDPOpt(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    int a = 0, b = 1, res;
    for (int i = 2; i <= n; ++i) {
        res = a + b;
        a = b;
        b = res;
    }
    return res;
}
```

##### 案例 2：零钱兑换（DP 经典，贪心失效场景）

**问题描述**：给定不同面额的硬币`coins`和总金额`amount`，求凑成总金额所需的最少硬币数（无法凑出返回 - 1）。

**状态定义**：`dp[i]`表示凑成金额`i`所需的最少硬币数。

**状态转移方程**：`dp[i] = min(dp[i - coin] + 1) `（遍历所有`coin ≤ i`的硬币）。

**初始条件**：`dp[0] = 0`（金额 0 无需硬币），其余`dp[i] = amount + 1`（初始化为无穷大）。

```cpp
#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>

int coinChange(std::vector<int>& coins, int amount) {
    // 初始化dp数组：dp[i] = 最少硬币数，初始为无穷大
    std::vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0; // 初始条件

    // 自底向上计算每个金额的最少硬币数
    for (int i = 1; i <= amount; ++i) {
        // 遍历所有硬币面额
        for (int coin : coins) {
            // 硬币面额 ≤ 当前金额，才可能凑出
            if (coin <= i) {
                dp[i] = std::min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    // 若dp[amount]仍为无穷大，说明无法凑出
    return dp[amount] > amount ? -1 : dp[amount];
}

int main() {
    std::vector<int> coins = {1, 3, 4};
    int amount = 6;
    // 最优解：3+3（2枚），贪心会选4+1+1（3枚）
    std::cout << "最少硬币数：" << coinChange(coins, amount) << std::endl; // 2
    return 0;
}
```

##### 案例 3：最长公共子序列（LCS，二维 DP）

**问题描述**：给定两个字符串`s1`和`s2`，求它们的最长公共子序列长度（子序列不要求连续）。

**状态定义**：`dp[i][j]`表示`s1[0..i-1]`和`s2[0..j-1]`的最长公共子序列长度。

**状态转移方程**：

- 若`s1[i-1] == s2[j-1]`：`dp[i][j] = dp[i-1][j-1] + 1`（字符匹配，子序列长度 + 1）；

- 否则：`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（取去掉 s1 第 i 个字符或 s2 第 j 个字符的最大值）。

	初始条件：`dp[0][j] = 0`，`dp[i][0] = 0`（空字符串的 LCS 长度为 0）。

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

int longestCommonSubsequence(std::string s1, std::string s2) {
    int m = s1.size(), n = s2.size();
    // 二维DP数组，多开一行一列方便处理边界
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = std::max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }

    return dp[m][n];
}

int main() {
    std::string s1 = "abcde", s2 = "ace";
    std::cout << "最长公共子序列长度：" << longestCommonSubsequence(s1, s2) << std::endl; // 3（ace）
    return 0;
}
```

##### 案例 4：01 背包问题（DP 核心应用）

**问题描述**：有`n`件物品，每件物品的重量为`w[i]`，价值为`v[i]`，背包容量为`C`，求能装入背包的最大价值（每件物品只能选 0 或 1 次）。

**状态定义**：`dp[i][j]`表示前`i`件物品，背包容量为`j`时的最大价值。

**状态转移方程**：

- 不选第`i`件物品：`dp[i][j] = dp[i-1][j]`；

- 选第`i`件物品（需`j ≥ w[i]`）：`dp[i][j] = dp[i-1][j - w[i]] + v[i]`；

- 最终：`dp[i][j] = max(不选, 选)`

	初始条件：`dp[0][j] = 0`（无物品时价值为 0），`dp[i][0] = 0`（背包容量为 0 时价值为 0）。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int knapsack01(std::vector<int>& weights, std::vector<int>& values, int capacity) {
    int n = weights.size();
    // 二维DP数组
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(capacity + 1, 0));

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= capacity; ++j) {
            // 不选第i件物品
            dp[i][j] = dp[i-1][j];
            // 选第i件物品（需容量足够）
            if (j >= weights[i-1]) {
                dp[i][j] = std::max(dp[i][j], dp[i-1][j - weights[i-1]] + values[i-1]);
            }
        }
    }

    return dp[n][capacity];
}

// 空间优化：一维DP数组（O(C)空间）
int knapsack01Opt(std::vector<int>& weights, std::vector<int>& values, int capacity) {
    int n = weights.size();
    std::vector<int> dp(capacity + 1, 0);

    for (int i = 0; i < n; ++i) {
        // 逆序遍历：避免重复选同一物品
        for (int j = capacity; j >= weights[i]; --j) {
            dp[j] = std::max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }

    return dp[capacity];
}

int main() {
    std::vector<int> weights = {2, 3, 4, 5};
    std::vector<int> values = {3, 4, 5, 6};
    int capacity = 8;
    std::cout << "01背包最大价值：" << knapsack01Opt(weights, values, capacity) << std::endl; // 10（3+7？实际是4+6=10）
    return 0;
}
```

### 四、动态规划的核心类型

| 类型        | 特点                          | 典型问题                   |
| ----------- | ----------------------------- | -------------------------- |
| 一维 DP     | 状态仅依赖一个维度            | 斐波那契、零钱兑换、爬楼梯 |
| 二维 DP     | 状态依赖两个维度              | LCS、01 背包、编辑距离     |
| 区间 DP     | 状态定义为区间`[i,j]`的最优解 | 最长回文子序列、矩阵链乘法 |
| 状态压缩 DP | 用二进制表示状态（降低维度）  | 旅行商问题、集合覆盖       |
| 树形 DP     | 状态定义在树上（后序遍历）    | 树的最大独立集、二叉树直径 |

### 五、DP vs 贪心 vs 暴力递归

| 维度       | 动态规划                   | 贪心算法                         | 暴力递归               |
| ---------- | -------------------------- | -------------------------------- | ---------------------- |
| 核心思想   | 记录子问题解，避免重复计算 | 局部最优→全局最优                | 枚举所有可能，无优化   |
| 时间复杂度 | O (n²)/O (nk)（低）        | O (n)/O (n log n)（极低）        | O (2ⁿ)/O (n!)（极高）  |
| 空间复杂度 | O (n)/O (nk)（需存储状态） | O (1)/O (n)（无额外存储）        | O (n)（递归栈）        |
| 适用条件   | 最优子结构 + 重叠子问题    | 贪心选择性质 + 最优子结构        | 无（小规模问题）       |
| 结果       | 全局最优解                 | 可能是近似解（不满足贪心性质时） | 全局最优解（但效率低） |

### 六、动态规划的关键技巧

1. 状态压缩

	- 一维 DP 替代二维 DP（如 01 背包），减少空间复杂度；
	- 滚动数组（如斐波那契仅保留前两项）。

2. 初始条件设置

	- 避免溢出：用`amount + 1`代替`INT_MAX`（零钱兑换）；
	- 边界处理：多开一行 / 一列（如 LCS 的`dp[0][j] = 0`）。

3. 状态转移方程推导

	- 从 “最后一步” 反推（如零钱兑换的最后一步是选某枚硬币）；
	- 分类讨论（如 LCS 的字符匹配 / 不匹配）。

4. 记忆化递归 vs 迭代填表

	- 记忆化递归：代码简洁，适合递归思维，但有递归栈开销；

- 迭代填表：效率更高，适合大规模问题，易做空间优化。

### 七、动态规划的常见陷阱

1. **状态定义错误**：如将 LCS 的状态定义为 “连续子序列”，导致转移方程错误；
2. **初始条件遗漏**：如零钱兑换未初始化`dp[0] = 0`，导致所有结果错误；
3. **转移方程边界错误**：如 01 背包正序遍历导致重复选物品；
4. **空间溢出**：二维 DP 数组过大（如 n=1e4 时，`dp[1e4][1e4]`会超出内存）。

### 八、总结

动态规划的核心是「状态」和「状态转移」：

- 状态定义是 DP 的灵魂：需准确描述子问题的最优解；
- 状态转移方程是 DP 的核心：需正确推导子问题之间的关系；
- 实现时优先选择 “自底向上”（迭代），并尽可能做空间优化。

掌握 DP 的关键是：

1. 理解经典问题的状态定义和转移方程；
2. 学会将新问题拆解为 “重叠子问题”；
3. 验证状态转移的正确性（通过小例子手动推导）。

DP 是算法面试的重点和难点，需通过大量练习（如背包、LCS、编辑距离、最长递增子序列等）掌握其思维方式。



# 贪心算法（Greedy Algorithm）详解（C++ 实现）

贪心算法是一种**启发式算法**，核心思想是：在每一步决策中，都选择**当前局部最优**的方案，期望通过一系列局部最优选择最终得到**全局最优解**。

与动态规划（DP）关注 “全局最优子结构” 不同，**贪心不回溯、不考虑未来，仅依赖当前的最优选择** —— 这使得贪心算法效率极高（通常线性 / 线性对数时间），但仅适用于满足「贪心选择性质」和「最优子结构」的问题。

#### 一、核心特性

|    特性    |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|  核心思想  |   局部最优 → 全局最优（每一步只选当前最好的，无后悔机制）    |
|  适用前提  | 1. 贪心选择性质：局部最优选择能导出全局最优；<br>2. 最优子结构：全局最优包含子问题最优 |
| 时间复杂度 | 通常 O (n) 或 O (n log n)（无重复子问题计算，比 DP 更高效）  |
|   局限性   | 多数问题不满足贪心选择性质，此时贪心只能得到近似解（如背包问题） |
|  典型应用  | 哈夫曼编码、活动选择、最短路径（Dijkstra）、最小生成树（Prim/Kruskal） |

#### 二、贪心算法的解题步骤

1. **问题拆解**：将问题分解为**若干个逐步决策的子问题**；
2. **确定贪心策略**：定义 “局部最优” 的判断标准（如选最小 / 最大、最早结束、性价比最高等）；
3. **验证贪心性质**：证明当前局部最优能推导出全局最优（关键步骤，否则贪心结果可能错误）；
4. **编码实现**：按贪心策略逐步执行，累积结果。

#### 三、经典案例

### 案例 1：活动选择问题（经典贪心）

**问题描述**：给定若干个活动的开始时间`start[i]`和结束时间`end[i]`，在同一时间段只能参加一个活动，求最多能参加的活动数量。

**贪心策略**：优先选择**结束时间最早**的活动（留出更多时间给后续活动）。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 定义活动结构体
struct Activity {
    int start;
    int end;
    Activity(int s, int e) : start(s), end(e) {}
};

// 贪心选择：按结束时间升序排序
bool compareActivity(const Activity& a, const Activity& b) {
    return a.end < b.end;
}

int maxActivities(std::vector<Activity>& activities) {
    if (activities.empty()) return 0;

    // 步骤1：按结束时间排序（贪心策略）
    std::sort(activities.begin(), activities.end(), compareActivity);

    int count = 1; // 至少选第一个活动
    int lastEnd = activities[0].end; // 上一个选中活动的结束时间

    // 步骤2：遍历选择后续活动
    for (size_t i = 1; i < activities.size(); ++i) {
        // 当前活动开始时间 ≥ 上一个结束时间 → 可选
        if (activities[i].start >= lastEnd) {
            count++;
            lastEnd = activities[i].end;
        }
    }

    return count;
}

```

**验证贪心正确性**：

假设存在更优解包含比 “最早结束” 更晚的活动，则可替换为最早结束的活动，总数量不会减少，因此贪心策略有效。

##### 案例 2：零钱兑换（贪心适用场景）

**问题描述**：给定面额为`[1, 5, 10, 25]`的硬币（美元硬币），求兑换金额`amount`所需的最少硬币数。

**贪心策略**：优先选**面额最大**的硬币，直到金额为 0。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 贪心策略：从大到小选硬币
int coinChangeGreedy(std::vector<int>& coins, int amount) {
    if (amount == 0) return 0;
    // 步骤1：硬币按面额降序排序
    std::sort(coins.rbegin(), coins.rend());

    int count = 0;
    int remaining = amount;

    // 步骤2：依次选最大面额
    for (int coin : coins) {
        if (remaining == 0) break;
        int num = remaining / coin; // 最多能选的当前面额数量
        count += num;
        remaining -= num * coin;
    }

    // 若剩余金额不为0，说明无法兑换（本题硬币面额保证可兑换）
    return remaining == 0 ? count : -1;
}

int main() {
    std::vector<int> coins = {1, 5, 10, 25};
    int amount = 41;
    std::cout << "最少硬币数：" << coinChangeGreedy(coins, amount) << std::endl; // 4（25+10+5+1）
    return 0;
}
```

**注意**：若硬币面额不满足 “贪心性质”（如`[1, 3, 4]`兑换 6），贪心会选`4+1+1`（3 枚），而最优解是`3+3`（2 枚），此时贪心失效，需用动态规划。

> 

##### 案例 3：哈夫曼编码（贪心的经典应用）

**问题描述**：给字符的出现频率，构造哈夫曼树，生成最短的前缀编码（总编码长度最小）。

**贪心策略**：每次选择**频率最小的两个节点**合并，直到只剩一个根节点。

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>

// 哈夫曼树节点
struct HuffmanNode {
    int freq;        // 频率
    char ch;         // 字符（非叶子节点为'\0'）
    HuffmanNode* left;
    HuffmanNode* right;

    HuffmanNode(int f, char c) : freq(f), ch(c), left(nullptr), right(nullptr) {}
};

// 优先队列比较器：小顶堆（频率小的优先）
struct CompareNode {
    bool operator()(HuffmanNode* a, HuffmanNode* b) {
        return a->freq > b->freq;
    }
};

// 递归生成哈夫曼编码
void generateCodes(HuffmanNode* root, std::string code, 
                   std::unordered_map<char, std::string>& codes) {
    if (!root) return;
    // 叶子节点（字符）
    if (root->ch != '\0') {
        codes[root->ch] = code;
        return;
    }
    // 左子树加0，右子树加1
    generateCodes(root->left, code + "0", codes);
    generateCodes(root->right, code + "1", codes);
}

// 构建哈夫曼树并生成编码
std::unordered_map<char, std::string> huffmanCode(std::unordered_map<char, int>& freqMap) {
    // 步骤1：初始化小顶堆
    std::priority_queue<HuffmanNode*, std::vector<HuffmanNode*>, CompareNode> pq;
    for (auto& pair : freqMap) {
        pq.push(new HuffmanNode(pair.second, pair.first));
    }

    // 步骤2：合并最小的两个节点
    while (pq.size() > 1) {
        HuffmanNode* left = pq.top(); pq.pop();
        HuffmanNode* right = pq.top(); pq.pop();

        // 合并节点（频率为两者之和，无字符）
        HuffmanNode* parent = new HuffmanNode(left->freq + right->freq, '\0');
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    // 步骤3：生成编码
    std::unordered_map<char, std::string> codes;
    HuffmanNode* root = pq.top();
    generateCodes(root, "", codes);

    // 释放内存（省略，实际需递归释放）
    return codes;
}

int main() {
    // 字符频率：a(5), b(9), c(12), d(13), e(16), f(45)
    std::unordered_map<char, int> freqMap = {
        {'a',5}, {'b',9}, {'c',12}, {'d',13}, {'e',16}, {'f',45}
    };

    std::unordered_map<char, std::string> codes = huffmanCode(freqMap);
    std::cout << "哈夫曼编码：" << std::endl;
    for (auto& pair : codes) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    // 输出示例：f:0, c:100, d:101, a:1100, b:1101, e:111
    return 0;
}
```

**贪心正确性**：哈夫曼编码的最优子结构证明了 “合并最小频率节点” 能得到全局最短编码长度。

##### 案例 4：区间覆盖问题

**问题描述**：给定一个目标区间`[start, end]`和若干子区间，求覆盖目标区间所需的最少子区间数量。

**贪心策略**：在当前覆盖范围内，选择**能延伸到最右侧**的子区间。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 区间结构体
struct Interval {
    int start;
    int end;
    Interval(int s, int e) : start(s), end(e) {}
};

// 按区间起始位置升序排序
bool compareInterval(const Interval& a, const Interval& b) {
    return a.start < b.start;
}

int minIntervalsToCover(Interval target, std::vector<Interval>& intervals) {
    // 步骤1：排序
    std::sort(intervals.begin(), intervals.end(), compareInterval);

    int count = 0;       // 选中的区间数
    int currentEnd = target.start; // 当前覆盖的最右端
    int nextEnd = currentEnd;      // 下一步能覆盖的最右端
    int idx = 0;
    int n = intervals.size();

    while (currentEnd < target.end) {
        // 步骤2：在当前覆盖范围内找能延伸最远的区间
        while (idx < n && intervals[idx].start <= currentEnd) {
            nextEnd = std::max(nextEnd, intervals[idx].end);
            idx++;
        }

        // 无法延伸，覆盖失败
        if (nextEnd == currentEnd) return -1;

        count++;
        currentEnd = nextEnd; // 更新覆盖范围
    }

    return count;
}

int main() {
    Interval target(1, 10);
    std::vector<Interval> intervals = {
        {1, 3}, {2, 5}, {4, 7}, {6, 9}, {8, 10}
    };

    std::cout << "最少需要的区间数：" << minIntervalsToCover(target, intervals) << std::endl; // 3（1-3→4-7→8-10）
    return 0;
}
```

#### 四、贪心 vs 动态规划（DP）

|    维度    |             贪心算法             |              动态规划              |
| :--------: | :------------------------------: | :--------------------------------: |
|  决策方式  |      每步选局部最优，不回溯      |     枚举所有子问题，选全局最优     |
|  适用条件  |    贪心选择性质 + 最优子结构     |      最优子结构 + 重叠子问题       |
| 时间复杂度 |    低（O (n) / O (n log n)）     |      较高（O (n²) / O (nk)）       |
|    结果    | 可能是近似解（不满足贪心性质时） |            一定是最优解            |
|  典型问题  |  活动选择、哈夫曼编码、Dijkstra  | 零钱兑换、最长公共子序列、背包问题 |

#### 五、贪心算法的常见陷阱

1. **局部最优≠全局最优**：如零钱兑换（非标准面额）、背包问题（分数背包贪心有效，01 背包贪心失效）；
2. **贪心策略的选择**：同一问题可能有多种贪心策略，**需验证正确性**（如活动选择选 “最早开始” 会失效）；
3. **边界条件**：需处理 “无法覆盖”“无法兑换” 等边界情况（如区间覆盖中`nextEnd == currentEnd`）。

#### 六、贪心算法的验证方法

1. **交换论证**：假设存在最优解，将其中的选择替换为贪心选择，结果不会变差；
2. **数学归纳法**：证明贪心选择后，剩余子问题仍满足贪心性质，最终得到全局最优。

#### 七、总结

贪心算法是 “以局部换全局” 的高效策略，核心是**选对贪心规则**：

- 若问题满足 “每一步的局部最优能推导出全局最优”，贪心是最优解；
- 若不满足，贪心可作为近似算法（如旅行商问题）；
- 实际应用中，需先验证贪心性质，再编码实现（否则易出错）。

掌握贪心算法的关键是理解经典案例的贪心策略，并能区分 “贪心有效” 和 “贪心失效” 的场景，结合动态规划等算法灵活解决问题。

### 

# 迭代器 

迭代器（Iterator）是 C++ 标准库的核心组件之一，本质是**对象**，用于遍历容器（如`vector`、`list`、`map`等）中的元素，提供了统一的访问接口，屏蔽了不同容器底层实现的差异（如数组、链表、红黑树）。迭代器的设计遵循**STL 的泛型编程思想**，使得算法（如`sort`、`find`）可以独立于容器类型工作。

------

### 一、迭代器的核心作用

1. **统一遍历接口**：无论容器是数组（`vector`）、链表（`list`）还是树（`map`），都可以通过`begin()`/`end()`获取迭代器，用`++`/`*`等操作访问元素。
2. **解耦算法与容器**：STL 算法（如`std::for_each`、`std::sort`）接收迭代器作为参数，无需关心容器具体类型。
3. **支持不同访问方式**：迭代器分为不同类别（如随机访问、双向、前向），适配不同容器的特性（如`vector`支持随机访问，`list`仅支持双向遍历）。

------

## 二、迭代器的基本语法与操作

### 1. 迭代器的定义

迭代器的类型与容器绑定，语法为：

```cpp
容器类型::iterator 迭代器名;       // 可变迭代器（可修改元素）
容器类型::const_iterator 迭代器名; // 常量迭代器（只读，不可修改元素）
```



```cpp
#include <vector>
using namespace std;

vector<int> vec = {1, 2, 3};
vector<int>::iterator it;          // 可变迭代器
vector<int>::const_iterator cit;   // 常量迭代器
```

### 2. 核心操作

|           操作            |                  含义                   |   支持的迭代器类型   |
| :-----------------------: | :-------------------------------------: | :------------------: |
|           `*it`           |      解引用，访问迭代器指向的元素       |      所有迭代器      |
|          `it->`           | 访问元素的成员（适用于对象 / 指针元素） |      所有迭代器      |
|       `++it`/`it++`       |      迭代器后移（前置 / 后置自增）      |      所有迭代器      |
|       `--it`/`it--`       |      迭代器前移（前置 / 后置自减）      | 双向、随机访问迭代器 |
|     `it + n`/`it - n`     |             迭代器移动 n 步             |    随机访问迭代器    |
|        `it1 - it2`        |          计算两个迭代器的距离           |    随机访问迭代器    |
| `it1 == it2`/`it1 != it2` |           比较迭代器是否相等            |      所有迭代器      |
|  `it1 < it2`/`it1 > it2`  |             比较迭代器位置              |    随机访问迭代器    |

### 3. 基础使用示例



```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> vec = {10, 20, 30, 40};

    // 1. 可变迭代器遍历+修改元素
    vector<int>::iterator it;
    for (it = vec.begin(); it != vec.end(); ++it) {
        *it *= 2; // 修改元素值
        cout << *it << " "; // 输出：20 40 60 80
    }
    cout << endl;

    // 2. 常量迭代器（只读）
    vector<int>::const_iterator cit;
    for (cit = vec.cbegin(); cit != vec.cend(); ++cit) {
        // *cit *= 2; // 错误：常量迭代器不可修改元素
        cout << *cit << " "; // 输出：20 40 60 80
    }

    return 0;
}
```

------

## 三、迭代器的分类（按能力）

C++ 标准将迭代器分为 5 类，能力从弱到强，容器适配对应类型的迭代器：

|     迭代器类型     |                核心能力                |          支持的容器 / 场景           |
| :----------------: | :------------------------------------: | :----------------------------------: |
|   **输入迭代器**   | 只读、单向遍历（仅`++`），不可重复遍历 |     `istream_iterator`（读取流）     |
|   **输出迭代器**   | 只写、单向遍历（仅`++`），不可重复遍历 |     `ostream_iterator`（写入流）     |
|   **前向迭代器**   |     可读可写、单向遍历，可重复遍历     |       `forward_list`、无序容器       |
|   **双向迭代器**   |    可读可写、双向遍历（`++`/`--`）     |   `list`、`map`、`set`、`multimap`   |
| **随机访问迭代器** |  双向遍历 + 随机访问（`+`/`-`/`[]`）   | `vector`、`deque`、`array`、原生数组 |

### 关键特性说明：

- **输入 / 输出迭代器**：最基础，仅支持单次遍历（如从流中读取 / 写入数据，无法回头）。
- **前向迭代器**：可重复遍历同一区间（如`forward_list`的迭代器）。
- **随机访问迭代器**：性能最优，支持 O (1) 时间访问任意位置（如`vector`的迭代器本质是指针封装）。

------

## 四、特殊迭代器

### 1. 反向迭代器（`reverse_iterator`）

反向遍历容器，`rbegin()`指向最后一个元素，`rend()`指向第一个元素的前一个位置：

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> vec = {1, 2, 3, 4};
    // 反向迭代器遍历
    for (vector<int>::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it) {
        cout << *it << " "; // 输出：4 3 2 1
    }
    return 0;
}
```

### 2. 常量迭代器（`const_iterator`/`const_reverse_iterator`）

只读迭代器，适用于`const`容器或不希望修改元素的场景，C++11 后可通过`cbegin()`/`cend()`直接获取：



```cpp
const vector<int> vec = {1, 2, 3};
// 必须用const_iterator
for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
    cout << *it << " ";
}
```

### 3. 空迭代器 / 尾后迭代器

- `end()`/`rend()`返回的迭代器是**尾后迭代器**，不指向任何元素，仅作为遍历结束的标志，解引用会导致未定义行为。
- 空迭代器（如默认构造的迭代器）不可直接使用，需先指向有效元素。

------

## 五、迭代器的失效问题（重点）

迭代器失效是指迭代器指向的容器位置失效（如内存被释放、元素位置改变），此时使用迭代器会导致程序崩溃或未定义行为。**不同容器的迭代器失效规则不同**：

### 1. 顺序容器（`vector`/`deque`/`list`）

| 容器     | 操作                   | 迭代器失效情况                                               |
| -------- | ---------------------- | ------------------------------------------------------------ |
| `vector` | `push_back()`          | 若扩容（重新分配内存），所有迭代器失效；否则仅`end()`失效。  |
|          | `insert()`/`erase()`   | 插入 / 删除位置后的迭代器失效；若扩容，所有失效。            |
|          | `resize()`/`reserve()` | 扩容则所有失效，否则仅`end()`失效。                          |
| `deque`  | 头部 / 尾部插入 / 删除 | 仅`end()`失效；中间插入 / 删除则所有迭代器失效。             |
| `list`   | 任意插入 / 删除        | 仅指向被删除元素的迭代器失效，其余迭代器仍有效（链表特性）。 |

### 2. 关联容器（`map`/`set`）

插入 / 删除元素时，仅指向被删除元素的迭代器失效，其余迭代器（包括指向其他元素的）仍有效（红黑树特性）。

### 3. 无序容器（`unordered_map`/`unordered_set`）

插入时若触发扩容（负载因子超过阈值），所有迭代器失效；删除时仅指向被删除元素的迭代器失效。

### 避免迭代器失效的技巧：

- 遍历删除时，用迭代器的返回值更新（如`erase`返回下一个有效迭代器）：

	

	```cpp
	vector<int> vec = {1, 2, 3, 4};
	for (auto it = vec.begin(); it != vec.end();) {
	    if (*it % 2 == 0) {
	        it = vec.erase(it); // erase返回下一个有效迭代器，无需++
	    } else {
	        ++it;
	    }
	}
	```

	

- 对`vector`频繁插入时，先`reserve()`预分配内存，避免扩容导致迭代器失效。

------

## 六、迭代器的底层实现

迭代器本质是**模板类**，封装了对容器底层数据结构的访问逻辑：

- 对于`vector`/`array`，迭代器通常是**原生指针的封装**（随机访问迭代器），`operator *`直接解引用指针，`operator ++`等价于指针 ++。
- 对于`list`（双向链表），迭代器封装了链表节点指针，`operator++`/`operator--`实际是移动到下一个 / 上一个节点。
- 对于`map`（红黑树），迭代器封装了树节点指针，`operator++`/`operator--`对应红黑树的后继 / 前驱节点遍历。



```cpp
template <typename T>
class VectorIterator {
private:
    T* ptr; // 底层指针
public:
    VectorIterator(T* p) : ptr(p) {}
    // 解引用
    T& operator*() { return *ptr; }
    // 自增
    VectorIterator& operator++() {
        ++ptr;
        return *this;
    }
    // 比较
    bool operator!=(const VectorIterator& other) {
        return ptr != other.ptr;
    }
};
```

------

## 七、C++11 及以上的迭代器增强

### 1. `auto`简化迭代器定义

C++11 后可通过`auto`自动推导迭代器类型，避免冗长的类型声明：



```cpp
vector<int> vec = {1, 2, 3};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    cout << *it << " ";
}
```

### 2. 范围 for 循环（基于迭代器）

范围 for 循环本质是编译器自动转换为迭代器遍历，语法更简洁：



```cpp
vector<int> vec = {1, 2, 3};
for (auto& num : vec) { // 引用可修改元素，值传递则只读
    num *= 2;
    cout << num << " "; // 输出：2 4 6
}
```

### 3. `std::begin()`/`std::end()`（全局函数）



```cpp
int arr[] = {1, 2, 3};
// 遍历原生数组
for (auto it = std::begin(arr); it != std::end(arr); ++it) {
    cout << *it << " ";
}
```

------

## 八、迭代器的使用注意事项

1. **不要解引用尾后迭代器**：`end()`/`rend()`**不指向有效元素**，解引用会导致崩溃。
2. **常量容器只能用常量迭代器**：`const vector<int>`的`begin()`返回`const_iterator`，无法修改元素。
3. **迭代器失效后禁止使用**：如`vector`扩容后，旧迭代器必须重新获取。
4. **优先使用前置自增（`++it`）**：后置自增（`it++`）会产生临时对象，效率低于前置（尤其对非指针迭代器）。
5. **算法对迭代器的要求**：如`std::sort`要求随机访问迭代器，不能用于`list`（需用`list::sort()`）。

------

## 总结

迭代器是 C++ STL 的 “粘合剂”，通过统一的接口实现了算法与容器的解耦。核心要点：

- 迭代器分 5 类，能力从输入 / 输出迭代器到随机访问迭代器递增；
- 不同容器适配不同迭代器类型，需注意迭代器失效规则；
- C++11 后可通过`auto`、范围 for 简化迭代器使用；
- 避免解引用尾后迭代器、使用失效迭代器等常见错误。

掌握迭代器是灵活使用 STL 容器和算法的关键，也是 C++ 泛型编程思想的核心体现。



在 C++ 中，使用迭代器遍历容器元素是最基础也最核心的操作，不同容器的迭代器遍历方式本质统一（仅迭代器类型 / 能力有差异），主要分为**基础迭代器遍历**、**简化版遍历（C++11+）**、**反向遍历**和**特殊容器遍历**四类场景。以下是详细的实现方法、示例和注意事项：

### 一、核心遍历方式（通用版，适配所有容器）

#### 1. 基础语法（显式迭代器类型）

适用于所有 C++ 版本，步骤为：

1. 通过容器的 `begin()` 获取指向第一个元素的迭代器；
2. 通过 `end()` 获取尾后迭代器（遍历结束标志，不指向有效元素）；
3. 循环条件：迭代器！= 尾后迭代器；
4. 循环内通过 `++it` 移动迭代器，`*it` 访问元素。

**通用模板**：



```cpp
容器类型::iterator it; // 可变迭代器（可修改元素）
// 或 容器类型::const_iterator it; // 常量迭代器（只读）
for (it = 容器.begin(); it != 容器.end(); ++it) {
    // 访问元素：*it
    // 修改元素（仅可变迭代器）：*it = 新值;
}
```

**示例 1：遍历 vector（随机访问迭代器）**



```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> vec = {10, 20, 30, 40};
    
    // 1. 可变迭代器（可修改元素）
    for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        *it *= 2; // 修改元素值
        cout << *it << " "; // 输出：20 40 60 80
    }
    cout << endl;

    // 2. 常量迭代器（只读，适用于const容器）
    const vector<int> const_vec = {1, 2, 3};
    for (vector<int>::const_iterator it = const_vec.cbegin(); it != const_vec.cend(); ++it) {
        cout << *it << " "; // 输出：1 2 3
        // *it = 10; // 错误：常量迭代器不可修改
    }
    return 0;
}
```

**示例 2：遍历 map（双向迭代器）**

map 的迭代器指向`pair<const Key, T>`，需通过`->first`（键）、`->second`（值）访问：



```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<string, int> score = {{"Alice", 90}, {"Bob", 85}, {"Charlie", 95}};
    
    // 遍历map的键值对
    for (map<string, int>::iterator it = score.begin(); it != score.end(); ++it) {
        cout << "Name: " << it->first << ", Score: " << it->second << endl;
    }
    return 0;
}
```

#### 2. C++11 + 简化版（auto 推导迭代器类型）

冗长的迭代器类型（如`map<string, int>::iterator`）可通过`auto`自动推导，大幅简化代码：



```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    unordered_set<int> us = {5, 2, 8, 1};
    
    // auto自动推导为unordered_set<int>::iterator
    for (auto it = us.begin(); it != us.end(); ++it) {
        cout << *it << " "; // 输出：1 2 5 8（无序，取决于哈希值）
    }
    return 0;
}
```

### 二、反向遍历（reverse_iterator）

通过`rbegin()`（指向最后一个元素）和`rend()`（指向第一个元素的前一个位置）实现反向遍历，语法与正向遍历一致，仅迭代器类型为`reverse_iterator`。

**通用模板**：



```cpp
// 可变反向迭代器
for (容器类型::reverse_iterator it = 容器.rbegin(); it != 容器.rend(); ++it) {
    // *it 访问元素（++it 等价于正向遍历的 --it）
}

// 常量反向迭代器
for (容器类型::const_reverse_iterator it = 容器.crbegin(); it != 容器.crend(); ++it) {
    // 只读访问
}
```

**示例：反向遍历 list**



```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    list<char> lst = {'a', 'b', 'c', 'd'};
    
    // 反向遍历（auto推导reverse_iterator）
    for (auto it = lst.rbegin(); it != lst.rend(); ++it) {
        cout << *it << " "; // 输出：d c b a
    }
    return 0;
}
```

### 三、C++11 + 范围 for 循环（迭代器的语法糖）

范围 for 循环本质是编译器自动转换为迭代器遍历，语法最简洁，无需手动处理`begin()`/`end()`。

**语法**：



```cpp
// 只读遍历（值拷贝）
for (auto 元素变量 : 容器) {
    // 访问元素变量
}

// 可修改遍历（引用）
for (auto& 元素变量 : 容器) {
    // 修改元素变量（会同步到容器）
}

// 只读遍历（const引用，避免拷贝，效率更高）
for (const auto& 元素变量 : 容器) {
    // 只读访问
}
```

**示例 1：范围 for 遍历 vector（修改元素）**



```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> vec = {1, 2, 3, 4};
    
    // 引用遍历，修改元素
    for (auto& num : vec) {
        num += 10;
    }
    
    // const引用遍历，只读
    for (const auto& num : vec) {
        cout << num << " "; // 输出：11 12 13 14
    }
    return 0;
}
```

**示例 2：范围 for 遍历 map**



```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<int, string> student = {{1, "Alice"}, {2, "Bob"}, {3, "Charlie"}};
    
    // 遍历map的pair（const auto& 避免拷贝）
    for (const auto& p : student) {
        cout << "ID: " << p.first << ", Name: " << p.second << endl;
    }
    return 0;
}
```

### 四、特殊容器的遍历

#### 1. 适配器容器（stack/queue/priority_queue）

适配器容器**无公开迭代器**（设计为仅访问首尾 / 栈顶），若需遍历，需通过「封装底层容器」实现（非标准，但多数编译器支持）：

cpp



运行









```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
    // 指定stack的底层容器为vector
    stack<int, vector<int>> st;
    st.push(1); st.push(2); st.push(3);
    
    // 访问底层容器（注意：_Get_container()是非标准接口，不同编译器可能不同）
    vector<int>& vec = (vector<int>&)st._Get_container();
    
    // 遍历底层容器（栈的存储顺序：1 2 3，栈顶是3）
    for (const auto& num : vec) {
        cout << num << " "; // 输出：1 2 3
    }
    return 0;
}
```

#### 2. 原生数组（非 STL 容器，但支持迭代器）

C++11 后可通过全局`std::begin()`/`std::end()`获取数组的迭代器（本质是指针）：

cpp



运行









```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {100, 200, 300, 400};
    
    // 迭代器遍历原生数组
    for (auto it = begin(arr); it != end(arr); ++it) {
        cout << *it << " "; // 输出：100 200 300 400
    }
    return 0;
}
```

### 五、遍历的关键注意事项

1. **避免解引用尾后迭代器**：`end()`/`rend()`不指向有效元素，解引用会导致程序崩溃（未定义行为）。

2. **优先使用前置自增（++it）**：后置自增（it++）会生成临时迭代器对象，效率低于前置（尤其对非指针迭代器，如 list 的迭代器）。

3. 迭代器失效问题：遍历过程中若修改容器（如插入 / 删除元素），需注意迭代器失效：

	- 遍历删除时，用`erase()`的返回值更新迭代器（以 vector 为例）：

		```cpp
		vector<int> vec = {1, 2, 3, 4, 5};
		for (auto it = vec.begin(); it != vec.end();) { // 注意：无++it
		 if (*it % 2 == 0) {
		        it = vec.erase(it); // erase返回下一个有效迭代器
		 } else {
		        ++it;
		 }
		}
		```

```
		

4. **const 容器只能用 const 迭代器**：`const vector<int>`的`begin()`返回`const_iterator`，无法修改元素。

5. **范围 for 的限制**：范围 for 遍历过程中不能修改容器的大小（如插入 / 删除元素），否则迭代器失效，程序崩溃。

### 六、遍历方式选择建议

| 场景                   | 推荐方式                      | 优势               |
| ---------------------- | ----------------------------- | ------------------ |
| 兼容 C++98/03          | 显式迭代器类型 + 普通 for     | 兼容性好           |
| C++11+，代码简洁优先   | auto + 普通 for / 范围 for    | 代码短，可读性高   |
| 反向遍历               | reverse_iterator + 普通 for   | 唯一标准方式       |
| 遍历过程中修改元素     | 可变迭代器 / 范围 for（引用） | 直接修改容器元素   |
| 遍历大容器（避免拷贝） | const auto& + 范围 for        | 效率高，无拷贝开销 |

### 总结

迭代器遍历的核心是「统一接口」：无论容器是数组、链表、红黑树还是哈希表，都能通过`begin()`/`end()`+ 迭代器操作实现遍历。C++11 + 的`auto`和范围 for 大幅简化了代码，是现代 C++ 的首选方式；反向遍历需用`reverse_iterator`；特殊容器（适配器）需通过底层容器间接遍历。掌握迭代器遍历是灵活使用 STL 容器的基础。
```



# 递归

要理解**递归（Recursion）**，首先可以用一句通俗的话概括：**“函数自己调用自己，同时逐步缩小问题规模，直到遇到‘停止信号’（Base Case）后回溯求解”**。它是计算机科学中解决复杂问题的核心思想之一，本质是将 “大问题” 拆解为结构相同的 “小问题”，最终通过小问题的解组合出大问题的解。

### 一、递归的核心要素

递归并非 “无限套娃”，必须同时满足以下两个条件，否则会导致**无限递归（栈溢出错误）**：

#### 1. 基线条件（Base Case）：递归的 “停止信号”

这是递归的终止条件，当问题规模缩小到某个阈值时，不再调用自身，直接返回明确的结果。

例如：计算 `n!`（n 的阶乘）时，基线条件是 `n=0` 或 `n=1`，此时 `0! = 1`、`1! = 1`（无需再拆解）。

#### 2. 递归条件（Recursive Case）：问题的 “拆解逻辑”

将当前问题拆解为**规模更小、结构相同**的子问题，通过调用自身求解子问题，再用子问题的结果构建当前问题的解。

例如：计算 `n!` 时，递归条件是 `n! = n * (n-1)!`（将 “求 n 的阶乘” 拆解为 “求 n-1 的阶乘”，再乘以 n）。



### 二、递归的工作原理：“调用栈” 与 “回溯”

计算机通过**调用栈（Call Stack）** 管理递归函数的执行过程，分为两个阶段：

#### 1. 递推阶段（Recursive Phase）：“层层拆解，压栈记录”

函数每次调用自身时，会将当前的 “上下文信息”（如参数、局部变量、返回地址）压入调用栈，然后进入子问题的求解。

以 `n=3` 计算 `3!` 为例，递推阶段的调用栈变化：

- 调用 `fact(3)`，压栈记录（参数 3、返回地址：需计算 `3 * fact(2)`）；
- 调用 `fact(2)`，压栈记录（参数 2、返回地址：需计算 `2 * fact(1)`）；
- 调用 `fact(1)`，触发基线条件（`1! = 1`），停止递推，开始回溯。

#### 2. 回溯阶段（Backtracking Phase）：“层层返回，出栈计算”

当遇到基线条件后，函数开始从调用栈的顶层（最后压入的子问题）逐步返回结果，同时弹出栈中记录，直到回到最初的调用。

延续 `3!` 的例子，回溯阶段的计算过程：

- `fact(1)` 返回 1，弹出栈；
- `fact(2)` 执行 `2 * 1 = 2`，返回 2，弹出栈；
- `fact(3)` 执行 `3 * 2 = 6`，返回 6，弹出栈；
- 最终得到 `3! = 6`。

### 三、经典案例：用递归解决实际问题

通过具体案例理解递归的应用，感受 “拆解问题” 的思路：

#### 案例 1：计算阶乘（Factorial）

阶乘的数学定义：`n! = n × (n-1) × (n-2) × ... × 1`，且 `0! = 1`。

```python
def factorial(n):
    # 基线条件：n=0或1时，直接返回1
    if n == 0 or n == 1:
        return 1
    # 递归条件：n! = n * (n-1)!
    else:
        return n * factorial(n - 1)

# 测试：计算3!
print(factorial(3))  # 输出：6
```

#### 案例 2：斐波那契数列（Fibonacci Sequence）

斐波那契数列的定义：第 1 项为 1，第 2 项为 1，从第 3 项起，每一项等于前两项之和（`F(n) = F(n-1) + F(n-2)`）。

```python
def fibonacci(n):
    # 基线条件：第1项和第2项均为1
    if n == 1 or n == 2:
        return 1
    # 递归条件：F(n) = F(n-1) + F(n-2)
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# 测试：计算第5项斐波那契数（1,1,2,3,5）
print(fibonacci(5))  # 输出：5
```

#### 案例 3：二叉树的前序遍历（Pre-order Traversal）

二叉树的每个节点都包含 “左子树” 和 “右子树”，前序遍历的规则是：**根节点 → 左子树 → 右子树**。由于左 / 右子树也是二叉树（结构相同），适合用递归实现。

```python
# 定义二叉树节点
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 递归实现前序遍历
def preorder_traversal(root):
    result = []
    # 基线条件：当前节点为空（无数据可遍历），返回空列表
    if not root:
        return result
    # 递归条件：根节点 → 左子树 → 右子树
    result.append(root.val)  # 访问根节点
    result += preorder_traversal(root.left)  # 遍历左子树
    result += preorder_traversal(root.right)  # 遍历右子树
    return result

# 测试：构建一棵简单二叉树（根1，左2，右3）
root = TreeNode(1, left=TreeNode(2), right=TreeNode(3))
print(preorder_traversal(root))  # 输出：[1, 2, 3]
```

### 四、递归的优缺点：何时该用，何时不该用？

**优点：**

1. **代码简洁直观**：无需手动管理循环和状态，直接映射问题的数学定义（如阶乘、斐波那契）。
2. **适合处理 “嵌套结构”**：如**树形结构（遍历、搜索）**、**嵌套列表（扁平化）**、**括号匹配**等，问题天然具有 “自相似” 特性。
3. **降低思维复杂度**：只需关注 “当前问题如何拆解为子问题” 和 “基线条件”，无需陷入循环的细节。

**缺点：**

1. **栈溢出风险**：递归依赖调用栈，若问题规模过大（如计算 `n=10000` 的阶乘），会导致调用栈深度超过系统限制，触发 `StackOverflowError`。
2. **重复计算问题**：部分递归（如朴素斐波那契）会反复计算相同的子问题（如 `fib(5)` 需计算 `fib(4)` 和 `fib(3)`，`fib(4)` 又需计算 `fib(3)`），时间复杂度高达 `O(2^n)`。
3. **空间开销较大**：调用栈会保存每次递归的上下文信息，空间复杂度为 `O(n)`（n 为递归深度），比迭代（`O(1)` 空间）更耗内存。



### 五、递归的优化技巧

针对上述缺点，可通过以下方式优化：

#### 1. 尾递归（Tail Recursion）：减少栈空间占用

尾递归是指**递归调用是函数的最后一步操作**，此时编译器 / 解释器可优化为 “复用当前栈帧”，避免栈深度增长（空间复杂度降至 `O(1)`）。

例如，用尾递归优化阶乘计算：

```python
def factorial_tail(n, accumulator=1):
    # 基线条件：返回累加器（已计算好的结果）
    if n == 0 or n == 1:
        return accumulator
    # 递归条件：最后一步仅调用自身，累加器记录中间结果
    return factorial_tail(n - 1, n * accumulator)

print(factorial_tail(3))  # 输出：6（栈帧仅1个）
```

⚠️ 注意：Python 解释器默认不支持尾递归优化，需借助第三方库或手动转换为迭代；Java、C++ 等语言的编译器可能支持。

#### 2. 记忆化（Memoization）：避免重复计算

将递归过程中已计算的子问题结果缓存起来，下次遇到相同子问题时直接返回缓存值，减少重复计算。

例如，用记忆化优化斐波那契数列（时间复杂度降至 `O(n)`）

```c++
#include <iostream>
#include <unordered_map>
#include <map>
#include <functional>

// ==================== 方法1：手动缓存（类似Python字典） ====================
class FibonacciMemo {
private:
    // 用unordered_map作为缓存（哈希表，查找O(1)）
    std::unordered_map<int, long long> memo;

public:
    FibonacciMemo() {
        // 初始化基础案例
        memo[1] = 1;
        memo[2] = 1;
    }

    long long fibonacci(int n) {
        // 检查缓存中是否存在
        if (memo.find(n) != memo.end()) {
            return memo[n];
        }
        // 计算并存入缓存
        long long result = fibonacci(n - 1) + fibonacci(n - 2);
        memo[n] = result;
        return result;
    }
};

```

#### 3. 递归转迭代：彻底避免栈溢出

对于不支持尾递归优化的语言（如 Python），可手动将递归逻辑改写为迭代（用循环 + 栈 / 队列模拟调用栈），完全控制内存占用。

例如，用迭代优化斐波那契数列：

```python
def fibonacci_iter(n):
    if n == 1 or n == 2:
        return 1
    a, b = 1, 1  # 初始化前两项
    for _ in range(3, n + 1):
        c = a + b  # 计算当前项
        a = b      # 更新前两项
        b = c
    return b

print(fibonacci_iter(5))  # 输出：5
```

### 六、递归与迭代的对比

递归和迭代是解决重复问题的两种核心方式，选择时需结合场景：

|      维度      |           递归（Recursion）            |      迭代（Iteration）       |
| :------------: | :------------------------------------: | :--------------------------: |
| **代码复杂度** |          简洁，适合自相似问题          | 较繁琐，需手动管理循环和状态 |
| **空间复杂度** | 通常 `O(n)`（调用栈），尾递归可 `O(1)` | 通常 `O(1)`（仅需局部变量）  |
|  **时间效率**  |        可能有重复计算（需优化）        |     无重复计算，效率稳定     |
|  **适用场景**  |    树形结构、嵌套问题、数学定义问题    | 线性问题（如遍历数组、阶乘） |
|    **风险**    |            栈溢出、重复计算            |  逻辑错误（如循环条件写错）  |

### 总结

递归的本质是 “**拆解问题 + 终止条件**”，它不是一种算法，而是一种 “思维模式”。掌握递归的关键在于：

1. 明确**基线条件**（避免无限递归）；
2. 设计**递归条件**（确保问题规模缩小且结构不变）；
3. 结合场景优化（尾递归、记忆化、转迭代），规避栈溢出和重复计算。

在实际开发中，递归常用于处理树形结构、深度优先搜索（DFS）、分治算法等场景，是理解动态规划、回溯法等高级算法的基础。



# 图论 Graph Theory

在数据结构与算法中，**图论（Graph Theory）** 是研究 “图” 这种非线性数据结构的核心理论，它通过抽象化现实中的 “关联关系”（如社交网络中的好友关系、地图中的路线连接），提供了一套描述、分析和解决复杂关系问题的方法论。图论不仅是数据结构的重要分支，更是解决**网络优化、路径规划、拓扑排序**等实际问题的关键工具。

### 一、图的基本定义与核心概念

#### 1. 图的形式化定义

从数学角度，图可定义为 **G = (V, E)**，其中：

- **V（Vertex）**：非空的顶点集合（也叫 “节点”，如社交网络中的用户、地图中的城市）；
- **E（Edge）**：边的集合，每条边是两个顶点的无序对（或有序对），表示顶点间的关联关系（如用户间的好友关系、城市间的公路）。

#### 2. 图的核心分类

根据 “边是否有方向”“边是否有权重”，图可分为以下几类，不同类型对应不同的应用场景：

|  分类维度  |          具体类型          |                             定义                             |                   典型应用场景                   |
| :--------: | :------------------------: | :----------------------------------------------------------: | :----------------------------------------------: |
| 边的方向性 | 无向图（Undirected Graph） |       边是无序对（如 (u, v) = (v, u)），表示双向关联。       |               社交网络、无向公路网               |
|            |  有向图（Directed Graph）  |       边是有序对（如 <u, v> ≠ <v, u>），表示单向关联。       |         任务依赖、网页跳转链接、水流方向         |
|            |                            |                                                              |                                                  |
|  边的权重  | 无权图（Unweighted Graph） |      边仅表示 “是否关联”，无额外信息（权重默认为 1）。       |                统计两点间是否连通                |
|            |  带权图（Weighted Graph）  | 边附带一个数值（权重，如距离、成本、时间），表示关联的 “强度” 或 “代价”。 |        路径规划（最短路径）、网络成本计算        |
|            |                            |                                                              |                                                  |
|  特殊结构  |  完全图（Complete Graph）  | 任意两个顶点间都存在边（无向完全图有 n (n-1)/2 条边，n 为顶点数）。 |       全连接网络、社交网络的 “全好友” 场景       |
|            |      稀疏图 / 稠密图       | 边数远小于 n² 为稀疏图（如社交网络），接近 n² 为稠密图（如全连接网络）。 |   存储优化（稀疏图用邻接表，稠密图用邻接矩阵）   |
|            |      有环图 / 无环图       | 存在从某顶点出发回到自身的路径为 “有环图”；反之则为 “无环图”。 |       有环图：电路设计<br>无环图：任务调度       |
|            |     连通图 / 非连通图      | 无向图中任意两顶点都能到达为 “连通图”；反之则为 “非连通图”。 | 连通图：互联网拓扑<br>非连通图：多个独立社交圈子 |

#### 3. 图的关键术语

- **顶点的度（Degree）**：无向图中，顶点关联的边数；有向图中分为 **入度（In-degree，指向该顶点的边数）** 和 **出度（Out-degree，从该顶点出发的边数）**。
- **路径（Path）**：从顶点 u 到 v 的边的序列（如 “从北京到上海的路线”），路径的 “长度” 可定义为边数（无权图）或边的权重和（加权图）。
- **环（Cycle）**：起点和终点相同的路径（如 “北京→天津→北京” 的路线）；无环的有向图称为 **DAG（Directed Acyclic Graph，有向无环图）**，是拓扑排序的核心场景。
- **子图（Subgraph）**：从原图中选取部分顶点和边构成的新图（如 “社交网络中的某个兴趣小组”）。
- **连通分量（Connected Component）**：无向图中最大的连通子图（如 “多个独立社交圈子中的每个圈子”）；有向图中类似概念是 **强连通分量（SCC）**—— 任意两顶点可双向到达的子图（如 “公司内部的管理层循环汇报关系”）。

### 二、图的存储结构

图的存储需要高效表达 “顶点” 和 “边” 的关联关系，常见的存储方式有 **邻接矩阵** 和 **邻接表**，两者各有优劣，需根据图的稀疏 / 稠密程度选择。

#### 1. 邻接矩阵（Adjacency Matrix）

用一个 **n×n 的二维数组** 存储图（n 为顶点数），其中 `matrix[i][j]` 表示顶点 i 和 j 的关联关系：

- 无向无权图：`matrix[i][j] = 1` 表示有边，`0` 表示无边（且 `matrix[i][j] = matrix[j][i]`）；
- 有向无权图：`matrix[i][j] = 1` 表示有从 i 到 j 的边，`0` 表示无；
- 加权图：`matrix[i][j] = 权重值`（无边时用 `∞` 或 `-1` 表示）。

**优缺点**：

- 优点：查询两顶点是否有边（`O(1)`）、计算顶点度（无向图直接求和行 / 列，`O(n)`）效率高；
- 缺点：空间复杂度 `O(n²)`（即使是稀疏图，也需存储所有 n² 个位置），添加 / 删除顶点需重构数组（效率低）。

**适用场景**：稠密图（如全连接网络）、顶点数较少的图。

#### 2. 邻接表（Adjacency List）

用一个 **数组（或哈希表）+ 链表（或动态数组）** 存储图：

- 数组下标（或哈希表的键）对应顶点编号；
- 每个数组元素对应一个链表（或动态数组），存储该顶点直接关联的所有顶点（及边的权重，加权图）。

例如，无向图中顶点 0 关联 1、2，则邻接表中 `adj[0] = [1, 2]`；有向图中顶点 0 指向 1、2，则 `adj[0] = [1, 2]`（反向边需单独存储）。

**优缺点**：

- 优点：空间复杂度 `O(n + m)`（m 为边数，稀疏图中 m 远小于 n²，空间更优），添加 / 删除边效率高（直接操作链表）；
- 缺点：查询两顶点是否有边需遍历链表（`O(k)`，k 为该顶点的度），效率低于邻接矩阵。

**适用场景**：稀疏图（如社交网络、互联网拓扑）、顶点数较多的图。

#### 3. 其他存储方式

- **邻接多重表**：优化无向图的邻接表，解决 “删除边需同时修改两个顶点的链表” 的问题（每条边仅存储一次，关联两个顶点的指针）；
- **十字链表**：优化有向图的邻接表，同时存储 “出边” 和 “入边”，便于计算入度和处理反向边。

### 三、图的核心算法（遍历与应用）

图论的核心价值在于通过算法解决 “关系问题”，如 “如何遍历所有节点”“如何找最短路径”“如何确定任务顺序” 等。以下是最基础且常用的算法：

#### 1. 图的遍历：深度优先（DFS）与广度优先（BFS）

遍历是指从某个顶点出发，访问图中所有可达顶点的过程，是后续所有图算法的基础。

##### （1）深度优先搜索（DFS，Depth-First Search）

- **核心思想**：“一条路走到黑”—— 从起点出发，优先访问当前顶点的未访问邻接顶点，直到无法前进时回溯，再探索其他路径。
- **实现方式**：递归（利用函数栈）或栈（手动维护访问栈）。
- **应用场景**：检测图中的环、寻找连通分量、拓扑排序（基于 DFS 的逆后序）、迷宫求解。



##### （2）广度优先搜索（BFS，Breadth-First Search）

- **核心思想**：“逐层扩散”—— 从起点出发，先访问起点的所有未访问邻接顶点（第一层），再依次访问第一层顶点的未访问邻接顶点（第二层），直到遍历结束。
- **实现方式**：队列（手动维护访问队列，先进先出）。
- **关键特性**：BFS 是 **无权图中找 “最短路径”（边数最少）** 的唯一方法（因为逐层扩散确保首次到达顶点的路径是最短的）。
- **应用场景**：无权图最短路径、社交网络 “一度好友 / 二度好友” 统计、迷宫的最短出口。



#### 2. 最短路径算法（加权图核心）

当图为加权图时（边有成本 / 距离），需寻找 “权重和最小” 的路径，常用算法有 **Dijkstra 算法**、**Floyd-Warshall 算法** 和 **Bellman-Ford 算法**。

##### （1）Dijkstra 算法

- **适用场景**：**带非负权重的加权图**（无负边，如公路距离、时间），求 “单源最短路径”（**从一个起点到所有其他顶点的最短路径**）。

- **核心思想**：**贪心策略** —— 维护一个 “已确定最短路径的顶点集”，每次从 “未确定集” 中选当前距离起点最近的顶点，更新其邻接顶点的距离（**松弛操作**），直到所有顶点都加入 “已确定集”。

- 步骤简

	1. 初始化：起点距离为 0，其他顶点距离为 ∞；
	2. 用优先队列（最小堆）存储顶点及当前距离，每次取出距离最小的顶点 u；
	3. 对 u 的每个邻接顶点 v，若 `u 的距离 + u→v 的权重 < v 的当前距离`，则更新 v 的距离（松弛）；
	4. 重复步骤 2-3，直到优先队列为空。

- **时间复杂度**：用优先队列优化后为 `O(m log n)`（m 为边数，n 为顶点数），适用于**稀疏图**。



##### （2）Floyd-Warshall 算法

- **适用场景**：**任意权重的图**（可含负边，但不能有负环），求 “**所有顶点对之间的最短路径**”（多源最短路径）。

- 核心思想：**动态规划** —— 定义`dp[k][i][j]`为 “经过前 k 个顶点（作为中间节点）时，i 到 j 的最短路径长度”，递推公式为：

	```
	dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])
	```

	（即 “不经过 k” 和 “经过 k” 两种情况取最小值）。

- **优化**：可压缩空间，用二维数组 `dp[i][j]` 直接更新（因为 `k` 层仅依赖 `k-1` 层）。

- **时间复杂度**：`O(n³)`（n 为顶点数），适用于顶点数较少的图（如 n < 1000）。



##### （3）Bellman-Ford 算法

- **适用场景**：**含负边的图**（可检测负环），求 “单源最短路径”（弥补 Dijkstra 算法无法处理负边的缺陷）。
- **核心思想**：松弛操作 —— 对所有边重复进行 n-1 次松弛（n 为顶点数），因为最短路径最多包含 n-1 条边（无环）；若第 n 次仍能松弛，则说明图中存在负环（负环会导致路径长度无限减小，无最短路径）。
- **时间复杂度**：`O(nm)`，效率低于 Dijkstra 算法，通常用于检测负环或处理含负边的小规模图。



#### 3. 拓扑排序（DAG 的核心应用）

- **适用场景**：**有向无环图（DAG）**，解决 “依赖关系的先后顺序” 问题（如任务调度、课程选修顺序 —— 必须先修 “高数” 才能修 “线代”）。

- **定义**：对 DAG 的顶点进行排序，使得对于每一条有向边 <u, v>，顶点 u 在排序结果中都位于 v 之前（即 “先完成依赖，再执行后续”）。

- 实现方法

	1. Kahn 算法（基于入度）

		- 初始化：计算所有顶点的入度，将入度为 0 的顶点入队（无依赖的初始任务）；
		- 循环：出队一个顶点 u，加入拓扑序列；遍历 u 的所有邻接顶点 v，将 v 的入度减 1（删除 u→v 的依赖）；若 v 的入度变为 0，入队；
		- 结束：若拓扑序列长度等于顶点数，则排序成功；否则图中存在环（无法拓扑排序）。

	2. DFS 逆后序

		- 对 DAG 进行 DFS，记录每个顶点的 “后序时间”（即递归结束时的顺序）；

	- 将后序序列反转，得到拓扑序列（因为 DFS 会先遍历完所有依赖顶点，再记录当前顶点的后序）。

- **应用**：编译依赖（先编译被依赖的库）、项目排期（先完成前置任务）。



#### 4. 最小生成树（MST，无向加权图的核心应用）

- **适用场景**：**无向加权连通图**，寻找一个 “子图”—— 包含所有顶点，边的权重和最小，且无环（即 “用最少的成本连接所有节点”，如电网铺设、网络布线）。

- **核心性质**：**MST 有且仅有 n-1 条边（n 为顶点数），删除任意一条边会导致图不连通，添加任意一条边会形成环。**

- 常用算法

	1. Prim 算法（类似 Dijkstra 算法，贪心）：

		- 从任意顶点出发，维护一个 “已加入 MST 的顶点集”；
		- 每次选 “连接已加入集和未加入集的边中权重最小的边”，将对应的未加入顶点加入 MST；
		- 重复直到所有顶点加入，时间复杂度 `O(m log n)`（用优先队列优化），适用于稠密图。

	2. Kruskal 算法（基于边排序，贪心）：

		- 将所有边按权重从小到大排序；
		- 依次选权重最小的边，若该边连接的两个顶点不在同一连通分量（用并查集检测），则将边加入 MST；
		- 重复直到选够 n-1 条边，时间复杂度 `O(m log m)`（排序边的时间），适用于稀疏图。



### 四、图论的实际应用场景

图论的价值在于 “抽象现实问题为图模型，用算法解决”，以下是典型应用：

1. **路径规划**：地图导航（如高德 / 百度地图的最短路径，用 Dijkstra 或其优化版 A* 算法）；
2. **社交网络**：好友推荐（基于连通分量、最短路径，如 “好友的好友”）、社群检测（基于强连通分量）；
3. **任务调度**：项目排期（拓扑排序，确定任务先后顺序）、CPU 进程调度（避免循环依赖）；
4. **网络设计**：通信网络铺设（最小生成树，用最少成本连接所有节点）、路由算法（如 OSPF 协议基于最短路径）；
5. **其他领域**：电路设计（检测环）、自然语言处理（语义网络）、生物信息学（蛋白质相互作用网络）。
6. 

### 五、学习图论的关键要点

1. **先理解模型**：遇到问题时，先明确 “顶点是什么”“边是什么”“边的方向 / 权重是否需要”，再选择合适的存储结构；
2. **掌握基础算法**：DFS/BFS 是所有图算法的基础，需熟练掌握其递归 / 迭代实现；最短路径、拓扑排序、最小生成树需理解 “贪心 / 动态规划” 的核心思想，而非死记代码；
3. **关注边界情况**：如图是否有环、是否有负边、是否连通，这些会直接影响算法选择（如 Dijkstra 不能处理负边，拓扑排序仅适用于 DAG）；
4. **结合实际场景**：通过案例（如导航、调度）理解算法的应用价值，避免单纯记忆理论。



# 回溯 Backtracking

在数据结构与算法中，**回溯（Backtracking）** 是一种基于 “试错” 思想的暴力搜索算法，核心逻辑是：**逐步构建解空间，若当前路径无法通向有效解，则回溯到上一步，尝试其他可能路径**。它本质是 “深度优先搜索（DFS）+ 剪枝” 的结合，常用于解决 “组合、排列、子集、切割、棋盘” 等需枚举所有可能解的问题。

> 回溯是一种基于试错思想的暴力搜索算法，本质是“深度优先搜索+剪枝”的结合

### 一、回溯的核心原理

回溯的本质是对 **“解空间树”** 的遍历：

- **解空间树**：将问题的所有可能解抽象为一棵树，每个节点代表 “当前已做出的选择”，叶子节点代表 “完整的解” 或 “无效的尝试”。
- **遍历逻辑**：从根节点出发，沿某一分支深度优先探索（构建解）；若发现当前节点无法通向有效解（如违反约束条件），则 “剪枝”（停止该分支探索），并回溯到父节点，尝试其他分支。

**回溯的三要素（必明确）**

1. **路径（Path）**：当前已选择的元素集合（即已构建的解的一部分）。
2. **选择列表（Choice List）**：当前可选择的元素集合（下一步能尝试的选项）。
3. **终止条件（Termination Condition）**：当路径满足问题要求时（如路径长度达到目标、覆盖所有必要元素），将路径加入结果集，并回溯。

### 二、回溯的通用代码框架（C++）

回溯算法的代码高度模板化，无论问题场景如何变化，核心结构均围绕 “递归探索 + 回溯撤销” 展开。以下是通用框架：

> 1. 定义结果集，存储所有解；定义路径，存储正在构建的解
>
> 2. 定义回溯函数：参数通常包含“选择列表”和“约束条件的相关参数”
>
> 	- 终止条件判断：当前路径满足要求则加入结果集
>
> 	- 遍历选择列表：尝试所有可能的选择（可用if+contnue实现剪枝操作）
> 	- 做出选择：将当前元素加入路径（或其他操作）
> 	- 递归搜索：深入下一层，继续构建当前解，再次调用backtrack（更新的参数列表）
> 	- 回溯撤销：撤销上一步选择，回到上一层，尝试其他选项

```cpp
#include <vector>
using namespace std;

// 结果集：存储所有有效解
vector<vector<int>> result;
// 路径：存储当前正在构建的解
vector<int> path;

// 回溯函数：参数通常包含“选择列表”和“约束条件相关参数”
void backtracking(/* 选择列表相关参数，如nums、startIndex等 */) {
    // 1. 终止条件：路径满足要求，加入结果集
    if (/* 终止条件，如path.size() == k */) {
        result.push_back(path); // 复制当前路径到结果集
        return;
    }

    // 2. 遍历选择列表：尝试所有可能的选择
    for (/* 遍历选择列表，如int i = startIndex; i < nums.size(); i++ */) {
        // （可选）剪枝：提前排除无效选择，减少遍历次数
        if (/* 剪枝条件，如当前元素已使用、不符合约束 */) {
            continue; // 跳过该选择，剪枝
        }

        // 3. 做出选择：将当前元素加入路径
        path.push_back(/* 当前选择的元素，如nums[i] */);

        // 4. 递归探索：深入下一层，继续构建解
        backtracking(/* 更新后的选择列表参数，如i+1（避免重复选） */);

        // 5. 回溯撤销：撤销上一步选择，回到上一层，尝试其他选项
        path.pop_back();
    }
}

// 调用入口：初始化参数，启动回溯
vector<vector<int>> solveProblem(/* 问题输入，如nums、k等 */) {
    result.clear(); // 清空结果集（避免多组测试用例干扰）
    path.clear();   // 清空路径
    backtracking(/* 传入初始化参数 */);
    return result;
}
```

### 三、回溯的典型应用场景（C++ 实例）

回溯的应用场景可归纳为 5 类，核心差异在于 “选择列表的范围” 和 “剪枝条件”，以下为每类场景的经典问题与代码实现。

#### 1. 组合问题（无重复元素，选 k 个元素）

**问题描述**：给定无重复元素的数组 `nums`，返回所有长度为 `k` 的组合（如 `nums=[1,2,3], k=2`，结果为 `[[1,2],[1,3],[2,3]]`）。

**关键约束**：组合不考虑顺序（如 `[1,2]` 和 `[2,1]` 是同一组合），需通过 `startIndex` 控制选择范围（避免重复）。

```cpp
#include <vector>
using namespace std;

vector<vector<int>> result;
vector<int> path;

// startIndex：控制下一次选择的起始位置，避免重复组合
void backtracking(vector<int>& nums, int k, int startIndex) {
    // 终止条件：路径长度达到k，加入结果
    if (path.size() == k) {
        result.push_back(path);
        return;
    }

    // 遍历选择列表：从startIndex开始，避免回头选
    // 剪枝优化：剩余元素不足时，无需继续遍历（i <= nums.size() - (k - path.size())）
    for (int i = startIndex; i <= nums.size() - (k - path.size()); i++) {
        path.push_back(nums[i]);   // 选当前元素
        backtracking(nums, k, i+1); // 下一轮从i+1开始（不重复选同一元素）
        path.pop_back();           // 回溯撤销
    }
}

vector<vector<int>> combine(vector<int>& nums, int k) {
    result.clear();
    path.clear();
    backtracking(nums, k, 0);
    return result;
}
```



#### 2. 排列问题（无重复元素，全排列）

**问题描述**：给定无重复元素的数组 `nums`，返回所有可能的全排列（如 `nums=[1,2,3]`，结果为 `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`）。

**关键约束**：排列考虑顺序（需选所有元素），需通过 “used 数组” 标记元素是否已使用（避免同一元素在路径中重复出现）。

```cpp
#include <vector>
using namespace std;

vector<vector<int>> result;
vector<int> path;

// used：标记元素是否已加入当前路径（大小与nums一致）
void backtracking(vector<int>& nums, vector<bool>& used) {
    // 终止条件：路径长度等于nums长度（全排列完成）
    if (path.size() == nums.size()) {
        result.push_back(path);
        return;
    }

    // 遍历选择列表：从0开始（排列需考虑所有未使用元素）
    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) { // 剪枝：跳过已使用的元素
            continue;
        }
        used[i] = true;        // 标记为已使用
        path.push_back(nums[i]);// 选当前元素
        backtracking(nums, used); // 递归探索
        path.pop_back();       // 回溯撤销选择
        used[i] = false;       // 回溯撤销标记
    }
}

vector<vector<int>> permute(vector<int>& nums) {
    result.clear();
    path.clear();
    vector<bool> used(nums.size(), false); // 初始化used数组
    backtracking(nums, used);
    return result;
}
```

#### 3. 子集问题（无重复元素，所有子集）

**问题描述**：给定无重复元素的数组 `nums`，返回所有可能的子集（包括空集和全集，如 `nums=[1,2,3]`，结果为 `[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]`）。

**关键约束**：子集不考虑顺序，且每个元素只能选一次，需通过 `startIndex` 控制选择范围（空集通过初始回溯直接加入）。

```cpp
#include <vector>
using namespace std;

vector<vector<int>> result;
vector<int> path;

// startIndex：控制下一次选择的起始位置，避免重复子集
void backtracking(vector<int>& nums, int startIndex) {
    // 终止条件：无显式终止（startIndex越界时自然退出）
    // 每一步路径都是一个子集，直接加入结果
    result.push_back(path);

    // 遍历选择列表：从startIndex开始
    for (int i = startIndex; i < nums.size(); i++) {
        path.push_back(nums[i]);   // 选当前元素
        backtracking(nums, i+1);   // 下一轮从i+1开始
        path.pop_back();           // 回溯撤销
    }
}

vector<vector<int>> subsets(vector<int>& nums) {
    result.clear();
    path.clear();
    backtracking(nums, 0);
    return result;
}
```

#### 4. 切割问题（字符串分割，满足特定条件）

**问题描述**：给定字符串 `s`，将其分割为若干子串，使每个子串都是回文串（如 `s="aab"`，结果为 `[["a","a","b"],["aa","b"]]`）。

**关键约束**：切割不重复，需通过 `startIndex` 控制切割起点（每次切割从 `startIndex` 到 `i` 的子串，判断是否为回文）。

```cpp
#include <vector>
#include <string>
using namespace std;

vector<vector<string>> result;
vector<string> path;

// 判断子串s[left..right]是否为回文
bool isPalindrome(string& s, int left, int right) {
    while (left < right) {
        if (s[left] != s[right]) return false;
        left++;
        right--;
    }
    return true;
}

// startIndex：切割的起始位置（避免重复切割）
void backtracking(string& s, int startIndex) {
    // 终止条件：startIndex达到字符串末尾（切割完成）
    if (startIndex == s.size()) {
        result.push_back(path);
        return;
    }

    // 遍历切割范围：从startIndex到s.size()-1
    for (int i = startIndex; i < s.size(); i++) {
        // 剪枝：若当前子串不是回文，跳过
        if (!isPalindrome(s, startIndex, i)) {
            continue;
        }
        // 截取子串s[startIndex..i]，加入路径
        path.push_back(s.substr(startIndex, i - startIndex + 1));
        backtracking(s, i + 1); // 下一轮从i+1开始切割
        path.pop_back();        // 回溯撤销
    }
}

vector<vector<string>> partition(string s) {
    result.clear();
    path.clear();
    backtracking(s, 0);
    return result;
}
```

#### 5. 棋盘问题（N 皇后）

**问题描述**：在 `n×n` 的棋盘上放置 `n` 个皇后，使它们不能互相攻击（同一行、同一列、同一对角线无多个皇后），返回所有合法的放置方案。

**关键约束**：需通过 “列标记数组”“正对角线标记数组”“反对角线标记数组” 剪枝（避免无效尝试）。

```cpp
#include <vector>
#include <string>
using namespace std;

vector<vector<string>> result;

// 检查当前位置(row, col)是否可放皇后
bool isValid(int row, int col, int n, 
             vector<bool>& usedCol,        // 标记列是否已使用
             vector<bool>& usedDiag1,      // 标记正对角线（row-col固定）
             vector<bool>& usedDiag2) {    // 标记反对角线（row+col固定）
    if (usedCol[col]) return false;
    if (usedDiag1[row - col + n - 1]) return false; // 偏移量：避免负索引
    if (usedDiag2[row + col]) return false;
    return true;
}

// row：当前处理的行（每行只放一个皇后，避免行冲突）
void backtracking(int n, int row, 
                   vector<bool>& usedCol, 
                   vector<bool>& usedDiag1, 
                   vector<bool>& usedDiag2, 
                   vector<string>& board) {
    // 终止条件：所有行都放完皇后
    if (row == n) {
        result.push_back(board);
        return;
    }

    // 遍历当前行的所有列，尝试放皇后
    for (int col = 0; col < n; col++) {
        // 剪枝：跳过无效位置
        if (!isValid(row, col, n, usedCol, usedDiag1, usedDiag2)) {
            continue;
        }

        // 做出选择：放皇后，标记约束
        board[row][col] = 'Q';
        usedCol[col] = true;
        usedDiag1[row - col + n - 1] = true;
        usedDiag2[row + col] = true;

        // 递归探索下一行
        backtracking(n, row + 1, usedCol, usedDiag1, usedDiag2, board);

        // 回溯撤销：移除皇后，取消标记
        board[row][col] = '.';
        usedCol[col] = false;
        usedDiag1[row - col + n - 1] = false;
        usedDiag2[row + col] = false;
    }
}

vector<vector<string>> solveNQueens(int n) {
    result.clear();
    vector<string> board(n, string(n, '.')); // 初始化棋盘（全为'.'）
    vector<bool> usedCol(n, false);          // 列约束
    vector<bool> usedDiag1(2 * n - 1, false); // 正对角线约束（共2n-1条）
    vector<bool> usedDiag2(2 * n - 1, false); // 反对角线约束
    backtracking(n, 0, usedCol, usedDiag1, usedDiag2, board);
    return result;
}
```

### 四、回溯的时间与空间复杂度

回溯的复杂度与 “解空间树的规模” 直接相关，通常为指数级（暴力搜索的本质），但剪枝可显著降低实际运行时间。

| 复杂度类型 | 分析                                                         |
| ---------- | ------------------------------------------------------------ |
| 时间复杂度 | 最坏情况：*O*(*N*×*N*!)（如全排列，需遍历 *N*! 个解，每个解需 *N* 步构建）；剪枝后：复杂度会降低（如 N 皇后的实际复杂度远低于 *N*!）。 |
| 空间复杂度 | *O*(*N*)（递归栈深度为问题的 “深度”，如全排列递归栈深为 *N*；路径和辅助数组的空间也为 *O*(*N*)）。 |

### 五、回溯的核心技巧：剪枝

剪枝是回溯算法的 “灵魂”，可大幅减少无效遍历，提升效率。常见剪枝场景：

1. **提前终止分支**：如组合问题中，剩余元素不足时（`i <= nums.size() - (k - path.size())`），直接跳过后续循环。
2. **约束排除**：如 N 皇后问题中，通过 `usedCol` `usedDiag` 数组提前排除冲突位置，避免无效递归。
3. **重复元素处理**：若问题含重复元素（如 “组合总和 II”），需先排序，再跳过相同元素（`if (i > startIndex && nums[i] == nums[i-1]) continue`），避免重复解。

### 总结

回溯是解决 “枚举类问题” 的通用工具，其核心是 “递归构建解 + 回溯撤销 + 剪枝优化”。在 C++ 实现中，需重点关注：

- 明确 “路径、选择列表、终止条件” 三要素；
- 利用 `startIndex`（组合、子集、切割）或 `used` 数组（排列）避免重复；
- 合理设计剪枝条件，降低时间复杂度。

掌握回溯的模板后，可灵活适配各类问题，只需根据具体场景调整 “选择列表的遍历范围” 和 “剪枝条件” 即可。



# 读取字符串

在 C++ 中读取一行字符串有多种方法，核心是区分**带空格 / 换行的整行读取**和**按空格分割的读取**，以下是最常用的方式及详细说明：

### 一、核心方法：`getline()`（读取整行，包含空格）

`getline()` 是 C++ 标准库中专门用于读取一行字符串的函数，会读取从当前输入位置到换行符（`\n`）的所有字符（换行符本身会被丢弃，不会存入字符串）。

#### 1. 基础用法（`cin.getline()`，字符数组版）

适用于字符数组（C 风格字符串），语法：

```C++
cin.getline(字符数组名, 数组长度, 终止符);
```

- 参数 1：存储字符串的字符数组；
- 参数 2：数组最大长度（避免越界，实际读取 `长度-1` 个字符，末尾自动加 `\0`）；
- 参数 3：可选终止符（默认是 `\n`，遇到该字符停止读取）。

```c++
#include <iostream>
using namespace std;

int main() {
    char str[100]; // 定义字符数组
    cout << "请输入一行字符串（含空格）：" << endl;
    cin.getline(str, 100); // 读取整行，最多99个字符+1个'\0'
    cout << "你输入的是：" << str << endl;
    return 0;
}
```

#### 2. 更推荐：`getline(cin, string)`（string 类版）

适用于 C++ 的 `string` 类（无需指定长度，更灵活），语法：

```c++
getline(cin, 字符串变量, 终止符);
```

- 参数 1：标准输入流 `cin`；
- 参数 2：`string` 类型变量，用于存储读取的内容；
- 参数 3：可选终止符（默认 `\n`）。

```c++
#include <iostream>
#include <string> // 必须包含string头文件
using namespace std;

int main() {
    string str;
    cout << "请输入一行字符串（含空格）：" << endl;
    getline(cin, str); // 读取整行，自动适配长度
    cout << "你输入的是：" << str << endl;
    return 0;
}
```



### 二、注意：`cin >> 字符串` 与 `getline()` 的冲突

如果先用 `cin >>` 读取数字 / 单个单词，再用 `getline()`，会出现`getline()` 读取到空行的问题（因为 `cin >>` 会留下换行符 `\n` 在输入缓冲区）。

#### 解决方法：读取数字后，用 `cin.ignore()` 清空缓冲区的换行符

```c++
#include <iostream>
#include <string>
#include <limits> // 用于numeric_limits
using namespace std;

int main() {
    int n;
    cout << "请输入一个数字：" << endl;
    cin >> n; // 读取数字，缓冲区留下'\n'
    
    // 清空缓冲区的换行符（关键！）
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    
    string str;
    cout << "请输入一行字符串：" << endl;
    getline(cin, str); // 正常读取整行
    cout << "数字：" << n << "，字符串：" << str << endl;
    return 0;
}
```

- `numeric_limits<streamsize>::max()`：表示忽略尽可能多的字符，直到遇到 `\n`，需包含头文件 `<limits>`。



### 三、补充：按空格分割读取（`cin >> string`）

如果只需读取**无空格的单个单词**，直接用 `cin >> string` 即可（自动跳过空格 / 换行 / 制表符）：

```c++
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str;
    cout << "请输入一个无空格的字符串：" << endl;
    cin >> str; // 遇到空格/换行停止读取
    cout << "你输入的是：" << str << endl;
    return 0;
}
```

### 总结

| 场景                 | 推荐方法                  | 注意事项                           |
| -------------------- | ------------------------- | ---------------------------------- |
| 读取含空格的整行     | `getline(cin, string)`    | 避免与 `cin >>` 混用（需清缓冲区） |
| 读取字符数组的整行   | `cin.getline(数组, 长度)` | 注意数组长度，防止越界             |
| 读取无空格的单个单词 | `cin >> string`           | 自动跳过空白符                     |





# 结构体

### 一、结构体（struct）的核心概念

结构体（`struct`）是 C++ 中**用户自定义的复合数据类型**，用于将**不同类型**的变量（成员）封装在一起，描述一个 “实体” 的多个属性。

- 本质：把相关联的数据打包，让代码更模块化、易维护；
- 与 C 的区别：C++ 的结构体支持**成员函数、访问控制（public/private）、继承、重载**等面向对象特性（可看作 “轻量级类”，默认成员为`public`，而类`class`默认`private`）。

### 二、结构体的基本语法

#### 1. 定义结构体

```c++
// 语法：struct 结构体名 { 成员列表; };（末尾分号不可少）
struct Student {
    // 数据成员（不同类型）
    int id;         // 学号
    string name;    // 姓名
    float score;    // 成绩
    // 成员函数（C++特有，可直接定义）
    void showInfo() {
        cout << "学号：" << id << "，姓名：" << name << "，成绩：" << score << endl;
    }
};
```

- 结构体名（如`Student`）是**自定义类型名**，可用于声明变量；
- 成员可以是：基本类型（int/float）、自定义类型（string / 其他结构体）、函数。

#### 2. 声明结构体变量

```c++
// 方式1：定义结构体后声明
Student s1; // 声明单个变量
Student s2, s3; // 声明多个变量

// 方式2：定义结构体时直接声明
struct Teacher {
    string name;
    int age;
} t1, t2; // t1、t2是Teacher类型的变量

// 方式3：匿名结构体（无结构体名，仅能在定义时声明变量，不可复用）
struct {
    int x;
    int y;
} point1, point2; // 仅能声明point1、point2，无法再定义其他变量
```



#### 3. 初始化结构体变量

C++ 支持多种初始化方式，推荐 “统一初始化”（C++11 及以上）：

```
// 方式1：默认初始化（成员为随机值，不推荐）
Student s1; 

// 方式2：按成员顺序初始化（C风格，易出错，成员顺序变了会出问题）
Student s2 = {101, "张三", 95.5}; 

// 方式3：统一初始化（C++11，推荐，顺序无关，可缺省）
Student s3{.id=102, .name="李四", .score=88.0}; 

// 方式4：构造函数初始化（C++特有，下文详解）
```



#### 4. 访问结构体成员

用**成员访问运算符 `.`**（普通变量）或 `->`（指针变量）：

```c++
// 普通变量：变量名.成员名
s1.id = 1001;
s1.name = "王五";
s1.score = 92.0;
s1.showInfo(); // 调用成员函数

// 指针变量：指针名->成员名（等价于 (*指针).成员名）
Student* p = &s1;
p->id = 1002; // 等价于 (*p).id = 1002
p->showInfo();
```



### 三、结构体的进阶用法



#### 1. 结构体的构造函数

构造函数是**无返回值、与结构体同名**的成员函数，用于初始化成员（解决 “默认初始化成员为随机值” 的问题）。

```c++
struct Student {
    int id;
    string name;
    float score;

    // 无参构造函数（默认构造）
    Student() {
        id = 0;
        name = "未知";
        score = 0.0;
    }

    // 有参构造函数（自定义初始化）
    Student(int i, string n, float s) {
        id = i;
        name = n;
        score = s;
    }

    void showInfo() {
        cout << id << " " << name << " " << score << endl;
    }
};

// 使用构造函数初始化
int main() {
    Student s1; // 调用无参构造：id=0, name=未知, score=0.0
    Student s2(103, "赵六", 90.5); // 调用有参构造
    s1.showInfo(); // 输出：0 未知 0
    s2.showInfo(); // 输出：103 赵六 90.5
    return 0;
}
```



#### 2. 结构体的访问控制

C++ 结构体支持`public`/`private`（默认`public`），用于控制成员的访问权限：

```C++
struct Person {
private: // 私有成员：仅结构体内部/友元可访问
    int age;
public: // 公有成员：外部可访问（默认）
    string name;
    // 公有函数（接口）：用于访问私有成员
    void setAge(int a) {
        if (a >= 0) age = a; // 可加合法性校验
    }
    int getAge() {
        return age;
    }
};

int main() {
    Person p;
    p.name = "小明"; // 公有成员可直接访问
    // p.age = 18; // 报错：private成员不可直接访问
    p.setAge(18); // 通过公有函数设置私有成员
    cout << p.getAge(); // 输出：18
    return 0;
}
```



#### 3. 结构体数组

结构体常用来定义数组，描述一组同类型实体：

```c++
struct Book {
    string title;
    float price;
};

int main() {
    // 定义结构体数组并初始化
    Book books[3] = {
        {"C++ Primer", 89.0},
        {"算法导论", 128.0},
        {"Python编程", 79.0}
    };
    // 遍历数组
    for (int i = 0; i < 3; i++) {
        cout << "书名：" << books[i].title << "，价格：" << books[i].price << endl;
    }
    return 0;
}
```



#### 4. 结构体嵌套

结构体的成员可以是另一个结构体（描述更复杂的实体）：

```c++
// 定义坐标结构体
struct Point {
    int x;
    int y;
};
// 定义矩形结构体（嵌套Point）
struct Rect {
    Point leftTop; // 左上角坐标
    Point rightBottom; // 右下角坐标
    // 计算矩形面积
    int getArea() {
        int width = rightBottom.x - leftTop.x;
        int height = rightBottom.y - leftTop.y;
        return width * height;
    }
};

int main() {
    Rect r{{1, 3}, {5, 1}}; // 嵌套初始化
    cout << "矩形面积：" << r.getArea(); // 输出：8（宽4，高2）
    return 0;
}
```



#### 5. 结构体作为函数参数 / 返回值

- 传值：拷贝整个结构体（效率低，适合小结构体）；
- 传引用 / 指针：仅传递地址（效率高，适合大结构体）。

```c++
struct Student {
    string name;
    int score;
};

// 传引用：修改原结构体
void updateScore(Student& s, int newScore) {
    s.score = newScore;
}

// 返回结构体
Student createStudent(string name, int score) {
    return {name, score};
}

int main() {
    Student s = createStudent("小红", 85);
    updateScore(s, 90);
    cout << s.name << " " << s.score; // 输出：小红 90
    return 0;
}
```



### 四、结构体与类（class）的区别

| 特性         | 结构体（struct）         | 类（class）                        |
| ------------ | ------------------------ | ---------------------------------- |
| 默认访问权限 | public                   | private                            |
| 设计初衷     | 侧重封装数据（C 兼容）   | 侧重面向对象（封装 + 继承 + 多态） |
| 用法         | 可当类用，也可仅封装数据 | 纯面向对象设计                     |

### 五、常见使用场景

1. 描述实体属性（如学生、图书、坐标）；
2. 封装函数参数（多个参数打包成结构体，简化函数签名）；
3. 数据存储（如结构体数组、链表节点）；
4. 与 STL 容器结合（如`vector<Student>`、`map<int, Book>`）。



# 分割字符串

### 一、按指定字符分割字符串（替代空格分割）

要实现**按任意指定字符（如逗号、竖线、分号）分割字符串**，需基于 `stringstream` 结合 `getline` 实现（核心是指定 `getline` 的终止符）。以下是通用分割函数及示例：

#### 1. 通用分割函数（按指定字符分割）

```c++
#include <iostream>
#include <vector>
#include <string>
#include <sstream> // 必须包含该头文件
using namespace std;

// 按指定分隔符delim分割字符串s，返回分割后的字符串数组
vector<string> split(const string& s, char delim) {
    vector<string> res;
    stringstream ss(s); // 将字符串s存入stringstream
    string token;
    // 按delim分割：每次读取到delim为止，不包含delim本身
    while (getline(ss, token, delim)) {
        // 可选：过滤空字符串（如连续分隔符导致的空值）
        if (!token.empty()) {
            res.push_back(token);
        }
    }
    return res;
}

// 测试示例
int main() {
    // 示例1：按逗号分割
    string s1 = "apple,banana,pear,orange";
    vector<string> res1 = split(s1, ',');
    cout << "按逗号分割：";
    for (const auto& str : res1) cout << str << " "; // 输出：apple banana pear orange

    // 示例2：按竖线分割（含连续分隔符）
    string s2 = "a||b|c";
    vector<string> res2 = split(s2, '|');
    cout << "\n按竖线分割：";
    for (const auto& str : res2) cout << str << " "; // 输出：a b c（过滤了空值）

    // 示例3：按空格分割（等价于你原有的split函数）
    string s3 = "hello world c++";
    vector<string> res3 = split(s3, ' ');
    cout << "\n按空格分割：";
    for (const auto& str : res3) cout << str << " "; // 输出：hello world c++
    return 0;
}
```



#### 2. 关键说明

- `getline(ss, token, delim)`：从 `stringstream` 中读取字符，直到遇到 `delim` 停止，读取的内容存入 `token`（**不包含 delim 本身**）；
- 若省略第三个参数 `delim`，默认按换行符 `\n` 分割；
- 过滤空字符串：避免连续分隔符（如 `a||b`）产生空元素，根据业务需求可选。



### 二、`sstream` 头文件详解

`<sstream>` 是 C++ 标准库中**字符串流**的头文件，核心是将字符串作为 “流” 处理（类似 `cin`/`cout` 对控制台的处理），支持字符串与基本数据类型的相互转换、字符串分割等操作。

#### 1. 核心类

`<sstream>` 包含 3 个核心类，均继承自标准流类：

| 类名            | 功能                           | 常用场景                 |
| --------------- | ------------------------------ | ------------------------ |
| `istringstream` | 输入字符串流（从字符串读数据） | 字符串分割、字符串转数值 |
| `ostringstream` | 输出字符串流（向字符串写数据） | 数值转字符串、拼接字符串 |
| `stringstream`  | 双向字符串流（可读可写）       | 同时需要读写字符串的场景 |

#### 2. 核心方法（以 `stringstream` 为例）

##### （1）构造与赋值

```c++
// 1. 空构造，后续赋值
stringstream ss;
ss.str("hello world"); // 将字符串"hello world"存入流

// 2. 构造时直接传入字符串
string s = "123 456";
stringstream ss2(s);
```

##### （2）读取数据（输入操作）

- 用 `>>` 运算符：按**空白符（空格 / 换行 / 制表符）** 分割读取（与 `cin` 行为一致）；
- 用 `getline`：按指定分隔符读取（支持非空白符分割）。

```c++
stringstream ss("123 abc 45.6");
int a; string b; double c;
ss >> a >> b >> c; // a=123, b="abc", c=45.6
```



##### （3）写入数据（输出操作）

用 `<<` 运算符：将数据写入字符串流，支持多类型拼接。

```
ostringstream oss; // 输出流更高效
oss << "年龄：" << 18 << "，分数：" << 95.5;
string res = oss.str(); // 提取拼接后的字符串："年龄：18，分数：95.5"
```



##### （4）提取字符串

用 `str()` 方法：获取流中存储的完整字符串（无参数），或覆盖流中的字符串（传参数）。

```
stringstream ss("test");
cout << ss.str(); // 输出：test
ss.str("new test"); // 覆盖流内容
cout << ss.str(); // 输出：new test
```

##### （5）状态重置（复用流）

若需重复使用 `stringstream`，需清空状态和内容：

```
stringstream ss;
ss << "123";
// 重置：清空内容 + 重置流状态
ss.str(""); // 清空内容
ss.clear(); // 重置流状态（如eofbit/failbit）
ss << "456";
cout << ss.str(); // 输出：456
```



#### 3. 常用场景示例

##### （1）字符串转数值

```c++
string s = "12345";
istringstream iss(s);
int num;
iss >> num; // num=12345

string s2 = "3.1415";
istringstream iss2(s2);
double pi;
iss2 >> pi; // pi=3.1415
```



##### （2）数值转字符串

```c++
int a = 100;
double b = 2.5;
ostringstream oss;
oss << a << "_" << b;
string res = oss.str(); // res="100_2.5"
```



##### （3）拼接多类型数据

```
ostringstream oss;
oss << "姓名：" << "张三" << "，年龄：" << 20 << "，成绩：" << 88.0;
string info = oss.str(); // info="姓名：张三，年龄：20，成绩：88"
```



### 三、原空格分割函数的等价替换

你原有的 `split` 函数（按空格分割），本质是 `stringstream` 的 `>>` 运算符（自动跳过空白符），等价于：运行

```
vector<string> split(const string& s) {
    vector<string> res;
    istringstream iss(s);
    string token;
    // >> 自动跳过空格/换行/制表符，读取到下一个空白符为止
    while (iss >> token) {
        res.push_back(token);
    }
    return res;
}
```



### 总结

| 操作             | 方法                                       | 适用场景                    |
| ---------------- | ------------------------------------------ | --------------------------- |
| 按空格分割字符串 | `stringstream + >>`                        | 空白符分隔的简单场景        |
| 按指定字符分割   | `stringstream + getline(ss, token, delim)` | 任意分隔符（逗号 / 竖线等） |
| 字符串↔数值转换  | `istringstream/ostringstream`              | 类型转换                    |
| 多类型字符串拼接 | `ostringstream + <<`                       | 避免频繁字符串拼接（高效）  |



### 四、进阶 split 函数（支持多分隔符）

该函数支持传入**多个分隔符**（如逗号、空格、竖线等），只要字符串中出现任意一个分隔符，就会分割字符串，同时过滤空字符串（避免连续分隔符产生无效元素）。

#### 完整代码实现

```c++
#include <iostream>
#include <vector>
#include <string>
#include <cctype> // 用于isspace（可选，若需兼容空格分类）
using namespace std;

/**
 * 按多分隔符分割字符串
 * @param s: 待分割的原字符串
 * @param delimiters: 分隔符集合（如 ", " 表示逗号和空格都是分隔符）
 * @return: 分割后的字符串数组（过滤空字符串）
 */
vector<string> split(const string& s, const string& delimiters) {
    vector<string> res;
    string token; // 存储当前分割出的子串

    // 遍历原字符串的每个字符
    for (char c : s) {
        // 判断当前字符是否是分隔符
        bool is_delimiter = false;
        for (char delim : delimiters) {
            if (c == delim) {
                is_delimiter = true;
                break;
            }
        }

        if (is_delimiter) {
            // 遇到分隔符：若当前token非空，存入结果并清空
            if (!token.empty()) {
                res.push_back(token);
                token.clear();
            }
        } else {
            // 非分隔符：追加到当前token
            token += c;
        }
    }

    // 处理最后一个token（字符串末尾无分隔符的情况）
    if (!token.empty()) {
        res.push_back(token);
    }

    return res;
}

// 测试示例
int main() {
    // 示例1：按逗号+空格分割
    string s1 = "apple, banana  pear | orange";
    vector<string> res1 = split(s1, ", |"); // 分隔符：逗号、空格、竖线
    cout << "示例1（分隔符：, |）分割结果：" << endl;
    for (const auto& str : res1) {
        cout << "\"" << str << "\" ";
    }
    cout << "\n\n";

    // 示例2：按分号+换行符分割（含连续分隔符）
    string s2 = "a;;b\nc||d";
    vector<string> res2 = split(s2, ";\n|"); // 分隔符：分号、换行符、竖线
    cout << "示例2（分隔符：;\\n|）分割结果：" << endl;
    for (const auto& str : res2) {
        cout << "\"" << str << "\" ";
    }
    cout << "\n\n";

    // 示例3：兼容纯空格分隔（等价于原split函数）
    string s3 = "hello   world c++";
    vector<string> res3 = split(s3, " "); // 仅空格为分隔符
    cout << "示例3（分隔符：空格）分割结果：" << endl;
    for (const auto& str : res3) {
        cout << "\"" << str << "\" ";
    }

    return 0;
}
```



#### 输出结果

```plaintext
示例1（分隔符：, |）分割结果：
"apple" "banana" "pear" "orange" 

示例2（分隔符：;\n|）分割结果：
"a" "b" "c" "d" 

示例3（分隔符：空格）分割结果：
"hello" "world" "c++" 
```



### 五、核心逻辑解析

1. 遍历字符 + 判断分隔符
	- 逐个遍历原字符串的字符，对每个字符检查是否属于传入的 “分隔符集合”；
	- 若属于分隔符：若当前已拼接的 `token` 非空，则存入结果并清空 `token`；
	- 若不属于分隔符：将字符追加到 `token` 中。
2. **处理末尾 token**：字符串遍历结束后，若最后一个 `token` 非空（即末尾无分隔符），需手动存入结果；
3. **过滤空字符串**：连续分隔符（如 `a;;b`）只会触发一次 “清空 token”，不会产生空元素。

### 六、灵活扩展说明

1. 支持任意多分隔符：只需在调用时传入包含所有分隔符的字符串，例如：
	- 分隔符为 `,;:|` → 传入 `" ,;:|"`；
	- 分隔符为换行符 + 制表符 → 传入 `"\n\t"`。
2. **兼容原单分隔符场景**：若仅需按单个分隔符分割（如逗号），调用 `split(s, ",")` 即可，等价于单分隔符版本。
3. **大小写不敏感（可选扩展）**：若需忽略分隔符大小写（如同时识别 `,` 和 `，`），可在判断分隔符时统一转换为小写 / 大写。

### 七、性能说明

该实现的时间复杂度为 `O(n*m)`（`n` 是原字符串长度，`m` 是分隔符数量），在分隔符数量较少（如 10 个以内）的场景下效率足够；若需极致性能，可将分隔符存入 `unordered_set`，将判断分隔符的时间复杂度降至 `O(1)`，优化版本如下：

#### 优化版（基于 unordered_set，更高性能）

```c++
#include <iostream>
#include <vector>
#include <string>
#include <unordered_set>
using namespace std;

vector<string> split(const string& s, const string& delimiters) {
    vector<string> res;
    string token;
    // 将分隔符存入unordered_set，O(1)查找
    unordered_set<char> delim_set(delimiters.begin(), delimiters.end());

    for (char c : s) {
        if (delim_set.count(c)) { // O(1)判断是否是分隔符
            if (!token.empty()) {
                res.push_back(token);
                token.clear();
            }
        } else {
            token += c;
        }
    }

    if (!token.empty()) {
        res.push_back(token);
    }

    return res;
}
```





# 分层图BFS

分层图 BFS 是一种**处理 “带状态约束的最短路径问题” 的 BFS 扩展算法**，核心是把 “状态” 作为 “层”，在不同层之间 / 层内部进行 BFS，从而同时维护 “节点位置” 和 “状态信息”，找到满足约束的最短路径。

### 一、为什么需要分层图 BFS？

普通 BFS 只能处理**无状态约束**的无权图最短路径（比如 “从 A 到 B 的最少步数”），但如果问题中存在**额外约束**（比如 “最多使用 k 次道具”“最多经过 m 个特殊节点”），普通 BFS 就无法直接记录这些约束的消耗情况。

而分层图 BFS 通过**把 “约束的消耗程度” 作为 “层”**，将原问题转化为 “多层图” 上的 BFS，每一层对应一种 “约束消耗状态”，从而同时追踪 “节点位置” 和 “约束消耗”。

### 二、分层图 BFS 的核心思想

假设约束是 “最多使用 k 次某道具”，那么分层图的设计是：

1. **分层**：将图分为`k+1`层（对应 “使用了 0 次道具”“使用了 1 次道具”……“使用了 k 次道具”）。
2. **同层边**：在同一层内移动，代表 “不消耗道具” 的操作（比如走普通路径）。
3. **跨层边**：从第`t`层移动到第`t+1`层，代表 “消耗 1 次道具” 的操作（比如使用道具走特殊路径）。
4. **目标**：找到从 “起点（第 0 层）” 到 “终点（任意≤k 层）” 的最短路径。

### 三、分层图 BFS 的直观例子

以 “最多增设 k 个路由器” 的问题为例：

- **层的定义**：第`t`层对应 “已经使用了`t`个新增路由器” 的状态。
- **同层 BFS**：在第`t`层内移动 → 只走**原路由器**（不新增，所以不消耗 k 的配额）。
- **跨层 BFS**：从第`t`层跳到第`t+1`层 → 走**新增路由器**（消耗 1 次 k 的配额）。
- **状态表示**：每个状态是`(层t, 节点u)`，代表 “在第`t`层（用了 t 个新增），当前位于节点 u”。

### 四、分层图 BFS 的执行流程（步骤）

以 “最多用 k 次道具” 为例，步骤如下：

1. **状态初始化**：定义`dist[t][u]`表示 “在第`t`层，到达节点`u`的最短路径长度”，初始化为无穷大；起点状态`dist[0][起点] = 0`（或 1，依路径长度定义）。
2. **队列初始化**：将起点状态`(t=0, u=起点)`加入队列。
3. BFS 遍历
	- 取出队首状态`(t, u)`。
	- **同层扩展**：遍历所有 “不消耗道具” 的可达节点`v`，若`dist[t][v]`可更新，则更新并将`(t, v)`入队。
	- **跨层扩展**：若`t < k`，遍历所有 “消耗 1 次道具” 的可达节点`v`，若`dist[t+1][v]`可更新，则更新并将`(t+1, v)`入队。
4. **结果计算**：遍历所有`dist[t][终点]`（`t ≤ k`），取最小值即为满足约束的最短路径。

### 五、分层图 BFS 的特点

1. **适用场景**：无权图 + 有 “最多使用 X 次某操作” 的约束（如最多用 k 个道具、最多走 m 条特殊边）。
2. **优势**：相比普通 BFS，能同时维护 “节点位置” 和 “约束消耗”；相比迪杰斯特拉，在无权图中效率更高（时间复杂度更低）。
3. **本质**：是 “状态 BFS” 的一种形式，将 “约束状态” 显式分层，让 BFS 的队列天然按 “路径长度” 有序遍历。
