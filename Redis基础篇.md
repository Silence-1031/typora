## 基础篇

### 第一章 初识redis

#### 第一节 认识NoSQL

##### 一、核心概念辨析

1. **SQL 与关系型数据库**
   - **SQL 的本质**：SQL 是`Structured Query Language`（结构化查询语言）的缩写
   - **关系型数据库的定位**：以 SQL 为核心操作语言的数据库，核心特征是 “结构化存储”，是传统数据存储的主流方案（如 MySQL、Oracle 等）。
2. **NoSQL 与非关系型数据库**
   - NoSQL 的两种常见解读
     - 字面直译：“No SQL” 即 “非 SQL”，对应 “非关系型数据库”，强调其与传统 SQL 数据库的存储、操作逻辑差异；
     - 扩展解读：“Not Only SQL”（不仅仅是 SQL），强调其并非完全替代 SQL 数据库，而是作为补充，适用于特定场景；
   - **NoSQL 的核心定位**：属于数据库范畴，最终目标与 SQL 数据库一致（均为数据的增删改查），差异仅体现在 “数据存储方式” 和 “增删改查操作方式” 上。

##### 二、SQL与 NoSQL的核心差异

|         对比维度         |                     SQL（关系型数据库）                      |             NoSQL（非关系型数据库）（隐含对比）              |
| :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     数据存储格式要求     | **强结构化**：数据必须遵循固定格式，格式通过 “表结构 + 约束” 定义 | **弱结构化 / 无结构化**：无固定表结构约束，可灵活存储不同格式数据（如键值对、文档、列族等） |
|       结构定义方式       | 依赖 “表” 和 “约束”：需预先定义表的字段、数据类型、长度及约束规则（如主键、唯一、无符号等） |      无需预先定义固定结构，数据格式可随业务需求动态调整      |
| 典型示例（用户信息存储） | 需创建 “用户表”，定义字段（如`id`：BIGINT 类型、长度≤20、主键约束；`name`：VARCHAR 类型、长度≤32、唯一约束；`age`：INT 类型、长度≤3、无符号约束） | 可直接以键值对（如`user:1 {id:1, name:"张三", age:25}`）或文档形式存储，无需预先定义字段规则 |
|     数据插入校验逻辑     | 严格校验：插入数据必须符合表结构约束（如`age`为负数、`name`重复均会报错，拒绝插入） | 无强制校验：数据格式可灵活调整（如同一类数据中，部分记录含`gender`字段、部分不含，均能正常存储） |
|      结构修改的影响      | 结构修改成本高、风险大：表结构（如字段类型、约束）不建议随便修改；若数据量庞大（如千万级），修改字段可能导致 “锁表”（表长时间不可用），且可能联动影响业务逻辑 | 结构修改灵活：无需修改 “固定表结构”，可直接通过数据本身动态扩展格式，无锁表风险，对业务影响极小 |

##### 三、关系型数据库 “结构化” 的优势与局限

1. **结构化的优势**：
   - 数据格式统一，便于规范化管理，避免数据混乱；
   - 约束规则（如主键、唯一键）保障数据完整性，减少脏数据；
   - 适合存储格式固定、业务逻辑稳定的数据（如用户基本信息、订单核心字段等）。
2. **结构化的局限（NoSQL 的补充场景）**：
   - **前期设计成本高**：需在项目初期明确表结构，若后期业务变更（如新增字段），调整难度大；
   - **数据量庞大时不灵活**：千万级以上数据量下，修改表结构易导致锁表，影响服务可用性；
   - **无法适配非结构化数据**：对于格式多变的数据（如用户行为日志、商品详情富文本），结构化存储会导致大量 “空字段” 或 “字段冗余”，效率低下。

![image-20251014131520219](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251014131520219.png)

#### 第二节 认识Redis

##### 一、Redis 的基础信息

1. **诞生背景**
   - 开发者团队所开发的网站初期使用 MySQL 数据库，随着用户量增长，高并发场景下 MySQL 性能不足，无法满足业务需求（需**高吞吐、高响应能力及特殊业务场景**支持），因此自主开发 Redis。
2. **名称与本质**
   - 全称：**Remote Dictionary Server（远程词典服务器）**。
   - 核心本质：键值型（Key-Value）数据库，因 “根据 Key 查找 Value” 的模式与词典查询逻辑高度相似，故得名 “远程词典服务器”。

##### 二、Redis 的核心特性

1. **键值型存储，支持多数据结构**

- 存储结构：采用简单的 Key-Value 键值对存储，操作便捷。
- Value 数据类型丰富：支持字符串、集合（有序集合、无序集合）、哈希等近十种数据类型，能满足多样化业务需求（如缓存、计数、排行榜等场景）。

2. **核心命令执行为单线程**

- 基础特性：Redis 核心的命令执行模块是单线程，所有命令串行执行，不存在 “命令执行到一半被其他命令插入” 的情况，因此命令具备原子性，线程安全。
- 对 “Redis 6.0 + 多线程” 的澄清：Redis 6.0 及以上版本仅在 “网络请求处理” 环节引入多线程，核心的命令执行模块仍保持单线程，因此仍可认为 Redis 是单线程模型（核心逻辑未变）。

3. **Redis 单线程却高性能的原因**

尽管 Redis 核心命令执行是单线程，但以 “低延迟、速度快” 著称，核心原因有三点：

- 基于内存存储
  - Redis 的数据全部存储在内存中，避免了传统数据库（如 MySQL）频繁的磁盘读写操作。这是 Redis 高性能的最核心原因之一。
- 采用 IO 多路复用机制
  - 单线程模型下，通过 IO 多路复用技术，Redis 可同时监听多个网络连接的 IO 事件（如连接请求、数据读取 / 写入），无需为每个连接创建独立线程。
  - 该机制大幅减少了线程切换开销，提升了服务的整体吞吐能力，是单线程支撑高并发的关键。
- 优秀的编码实现
  - Redis 基于 C 语言编写，代码开源且编码风格、编程习惯得到业界公认，代码质量高（被称为 “标杆级编码”），底层逻辑高效，减少了不必要的性能损耗。

4. **支持数据持久化**
5. **支持主从集群、分片集群**

![image-20251014133250823](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251014133250823.png)

- **redis的日志界面**



### 第二章 redis常见命令

#### 第一节 redis数据结构

- redis是一个key-value的数据库，key一般是string类型，不过value类型多种多样

![image-20251018121826402](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018121826402.png)



#### 第二节 redis通用命令

##### 一、通用指令

   是部分数据类型的，都可以使用的指令

1. keys：查看符合模板的所有key

![image-20251018124055779](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018124055779.png)

- 命令格式：`KEYS pattern`

- pattern：匹配模板，支持 Redis 内置的通配符（非正则表达式），常用通配符如下：

| 通配符 | 含义                        | 示例            | 效果（假设存在 key：name1、name2、age、user:name） |
  | ------ | --------------------------- | --------------- | -------------------------------------------------- |
  | `*`    | 匹配任意个字符（包括 0 个） | `KEYS *`        | 返回所有 key：name1、name2、age、user:name         |
  | `?`    | 匹配 1 个任意字符           | `KEYS name?`    | 返回 name1、name2（“?” 匹配 “1”“2” 这 1 个字符）   |
  | `[]`   | 匹配括号内任意 1 个字符     | `KEYS name[13]` | 仅返回 name1（匹配 “1”，不匹配 “2”）               |

- 底层逻辑是模糊匹配，效率不高，只在数据量小的范围内查询

2. DEL：删除一个指定的key

![image-20251018124814153](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018124814153.png)

- 若删除的 key 不存在，Redis 会自动忽略该操作，不会报错。

- 命令格式：`DEL key [key ...]`

  - **key [key ...]**：表示 “要删除的 key”，支持同时传入多个 key（用空格分隔），实现批量删除。

  - **返回值**：整数（`integer`），代表 “成功删除的 key 数量”（不存在的 key 会被计数为 0）。



3. exists：判断key是否存在

#### 1. 核心作用

- 检查 Redis 中一个或多个 key 是否存在，返回 “存在的 key 数量”（而非布尔值，便于批量判断）。
- 用途：避免对不存在的 key 执行无效操作（如删除不存在的 key、修改不存在的 value），或用于业务中 “判断数据是否已缓存”。

#### 2. 基础语法

##### （1）命令格式

redis







```redis
EXISTS key [key ...]
```

- **key [key ...]**：支持传入 1 个或多个 key（空格分隔），批量判断。

- 返回值

  ：整数（

  ```
  integer
  ```

  ），代表 “存在的 key 数量”：

  - 返回`0`：所有传入的 key 都不存在。
  - 返回`N`（N≥1）：有 N 个 key 存在（例如传入 3 个 key，返回 2 代表其中 2 个存在）。

#### 关键特性

- **性能极高**：Redis 的 key 存储在哈希表中，`EXISTS`本质是哈希表的 “键查询”，时间复杂度为`O(1)`（无论数据量多大，都能瞬间返回结果）。
- **忽略数据类型**：只要 key 存在，无论其对应的值是 String、List 还是 Hash，`EXISTS`均返回 1（仅判断 key 是否存在，不关心值的类型和内容）。

3. expire：给一个key设置有效期，有效期到期时该key会被自动删除

#### 1. 核心作用

- 为已存在的 key 设置 “生存时间（TTL，Time To Live）”，过期后 Redis 会**自动删除**该 key 及对应的值。
- 用途：实现 “临时缓存” 场景（如验证码 10 分钟过期、会话信息 2 小时失效），避免无效数据长期占用 Redis 内存。

#### 2. 基础语法

##### （1）命令格式

redis







```redis
EXPIRE key seconds
```

- **key**：需要设置过期时间的 key（必须已存在，否则命令无效）。

- **seconds**：过期时间，单位为 “秒”（需为正整数，若为 0 或负数，会直接删除 key，等同于`DEL`）。

- 返回值

  ：整数（

  ```
  integer
  ```

  ），代表 “设置是否成功”：

  - 返回`1`：设置成功（key 存在且过期时间已生效）。
  - 返回`0`：设置失败（key 不存在，或 key 已被设置为 “永久有效” 且无法修改过期时间，如通过`PERSIST`命令取消过期时间后）。



#### 4. 关键注意事项

- **key 必须已存在**：`EXPIRE`无法给不存在的 key 设置过期时间（若需 “创建 key 并设置过期时间”，可直接用`SET`命令的扩展参数，如`SET user:token "abc123" EX 3600`，无需先`SET`再`EXPIRE`）。
- **过期时间的 “覆盖” 规则**：若 key 已存在过期时间，再次执行`EXPIRE`会**覆盖原过期时间**（例如 key 原本剩余 20 秒过期，执行`EXPIRE key 60`后，剩余时间变为 60 秒）。
- **过期 key 的删除机制**：Redis 不会 “实时监听” 过期 key，而是通过 “惰性删除”（访问 key 时才检查是否过期）和 “定期删除”（每隔一段时间批量检查部分过期 key）两种机制自动删除，确保性能稳定。
- **不支持 “负数过期时间”**：若`seconds`为负数（如`EXPIRE key -5`），Redis 会直接删除该 key（等同于`DEL key`），需避免误操作。



5. TTL：查看一个key的剩余有效期

### 一、核心作用

查询已设置过期时间的 key “距离自动删除还剩多少秒”，若 key 未设置过期时间或已过期 / 不存在，会返回特定标识值。

用途：判断 key 的 “有效剩余时长”，例如验证验证码是否还在有效期、会话是否即将失效等。

### 二、基础语法

#### 1. 命令格式

redis







```redis
TTL key
```

- **key**：需要查询剩余时间的 key（对所有数据类型的 key 都生效）。
- **返回值**：整数（`integer`），分三种情况，这是`TTL`命令的核心重点（视频中会强调 “区分返回值含义”）：

| 返回值 | 含义                                              | 场景示例                                             |
| ------ | ------------------------------------------------- | ---------------------------------------------------- |
| 正数   | 剩余生存时间，单位为 “秒”                         | 返回`60` → 该 key 还有 60 秒过期                     |
| `-1`   | key 存在，但**未设置过期时间**（永久有效）        | 执行`SET name "zhangsan"`后，`TTL name`返回`-1`      |
| `-2`   | key**不存在**（已过期被自动删除，或原本就不存在） | 执行`EXPIRE name 10`后等待 10 秒，`TTL name`返回`-2` |

#### 第三节 String类型

- string类型，也就是字符串类型，是redis中最简单的存储类型
- 其value是是字符串，不过根据字符串格式不同，又可分为三类
  ● string:普通字符串
  ● int:整数类型，可以做自增、自减操作
  ● float：浮点类型，可以做自增、自减操作
- 不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512兆。

|  key  | value       |
| :---: | ----------- |
|  msg  | hello world |
|  num  | 10          |
| score | 92.5        |

1. SET：添加或者修改已经存在的一个String类型的键值对

2. GET：根据key获取String类型的value

3. MSET：批量添加多个String类型的键值对

4. MGET：根据多个key获取多个String类型的value

5. INCR：让一个整型的key自增1

6. INCRBY：让一个整型的key自增并指定步长，例如：incrby num 2

   让num值自增2

7. INCRBYfloat：让一个浮点类型的数字自增并指定步长

8. SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行

9. SETEX：添加一个String类型的键值对，并且指定有效期



##### key的层级关系

Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？

 核心痛点：Key 冲突与数据混乱

Redis 作为**键值型数据库**，Key 必须唯一，但 Redis 没有类似 MySQL 的 “表（Table）” 概念，所有数据存储在同一空间。当不同业务（如用户、商品）存在相同 ID 时（如用户 ID=1 和商品 ID=1），直接用 ID 作为 Key 会导致冲突，数据被覆盖。

![image-20251018130715888](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018130715888.png)



#### 第四节 Hash类型

- Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。
- String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：

![image-20251018131432640](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018131432640.png)

Hash的常见命令有：
HSET key field value:添加或者修改hash类型key的field的值（多了一个field）
HGET key field:获取一个hash类型key的field的值
HMSET:批量添加多个hash类型key的field的值
HGET:批量获取多个hash类型key的field的值
HGETALL:获取一个hash类型的key中的所有的field和value
HKEYS:获取一个hash类型的key中的所有的field
HVALS:获取一个hash类型的key中的所有的value
HINCRBY：让一个hash类型key的字段值自增并指定步长
HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行

![image-20251018131842916](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018131842916.png)

#### 第五节 LIst类型

Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。
特征也与LinkedList类似：
有序
元素可以重复
插入和删除快
查询速度一般

| 特性       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 底层结构   | 可理解为**双向链表**（实际底层会结合 ZipList 等结构优化，原理篇会深入），支持正向 / 反向检索 |
| 有序性     | 元素顺序与插入顺序一致，而非按值排序                         |
| 元素可重复 | 不会检查元素唯一性，相同值可多次插入                         |
| 操作效率   | 插入 / 删除速度快（仅需修改链表节点指向），查询速度较慢（需逐个节点遍历） |

常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。

List的常见命令有：
LPUSH key element…：向列表左侧插入一个或多个元素
LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil
RPUSH key element…：向列表右侧插入一个或多个元素
RPOP key：移除并返回列表右侧的第一个元素

![image-20251018132512447](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018132512447.png)LRANGE key star end：返回一段角标范围内的所有元素
BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil（block)

##### 四、基于 List 实现栈、队列、阻塞队列

利用 List 的`push/pop`命令组合，可轻松模拟数据结构中的栈、队列和阻塞队列，核心逻辑通过 “**操作位置是否相同**” 区分：

| 数据结构         | 实现命令组合                   | 核心原理（对应生活场景）                                     |
| ---------------- | ------------------------------ | ------------------------------------------------------------ |
| 栈（先进后出）   | LPUSH + LPOP 或 RPUSH + RPOP   | 插入和移除都在**同一侧**                                     |
| 队列（先进先出） | LPUSH + RPOP 或 RPUSH + LPOP   | 插入和移除在**不同侧**                                       |
| 阻塞队列         | LPUSH + BRPOP 或 RPUSH + BLPOP | 基于队列逻辑，移除时若为空则阻塞等待（避免频繁轮询空列表，减少资源消耗）。 |

##### 五、关键注意点

1. 索引规则：LRANGE 的`start`和`end`均为 “闭区间”，且支持负索引（`-1`= 最后一个元素，`-2`= 倒数第二个元素）。
2. 空列表处理：LPOP/RPOP 操作空列表会返回`nil`，而 BLPOP/BRPOP 会阻塞到超时或有元素插入。

#### 第六节 Set类型

Redis的Set结构与Java中的HashMap类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashMap类似的特征：
无序
元素不可重复
查找快
支持交集、并集、差集等功能



string的常见命令有：
● SADD key member ...: 向set中添加一个或多个元素
● SREM key member ...: 移除set中的指定元素
● SCARD key: 返回set中元素的个数
● SISMEMBER key member: 判断一个元素是否存在于set中
● SMEMBERS: 获取set中的所有元素
● SINTER key1 key2…: 求key1与key2的交集
● SDIFF key1 key2…: 求key1与key2的差集
● SUNION key1 key2…: 求key1和key2的并集



##### 、Set 类型数据结构特性

Redis 的 Set 类型与 Java 中的`HashSet`原理相似，底层基于 “value 为 null 的哈希表” 实现，因此具备以下 4 个核心特性：

1. **无序性**：元素存储顺序由哈希算法计算的下标决定，与插入顺序无关；
2. **元素唯一性**：相同元素重复插入会被覆盖，集合内无重复值；
3. **高效查询**：基于哈希表实现，查找元素的时间复杂度为 O (1)，速度极快；
4. **支持集合运算**：相比 Java 的`HashSet`，额外提供交集、并集、差集等操作，适用于社交、数据对比场景。

##### 二、Set 类型核心操作命令（单个集合）

针对单个 Set 集合的 “增删查” 操作，核心命令及用法如下表所示：

| 命令语法                      | 命令功能                 | 关键说明                                                     |
| ----------------------------- | ------------------------ | ------------------------------------------------------------ |
| `SADD key member [member...]` | 向集合中添加元素         | 支持一次性添加 1 个或多个元素；若元素已存在，不会重复添加（无报错） |
| `SREM key member [member...]` | 从集合中删除元素         | 支持一次性删除 1 个或多个元素；若元素不存在，不会报错（视为 “删除 0 个元素”） |
| `SCARD key`                   | 统计集合中元素的总个数   | 返回值为整数，若集合不存在，返回 0                           |
| `SISMEMBER key member`        | 判断指定元素是否在集合中 | 返回值为`1`（存在）或`0`（不存在），类似 Java 的`contains()`方法 |
| `SMEMBERS key`                | 获取集合中的所有元素     | 返回结果为无序列表（与插入顺序无关），若集合为空，返回空列表 |

##### 三、Set 类型集合交互命令（多个集合）

Set 类型的核心优势是支持多集合间的数学运算，常用 3 类命令如下：

| 命令语法                    | 命令功能               | 逻辑说明                                                     |
| --------------------------- | ---------------------- | ------------------------------------------------------------ |
| `SINTER key1 key2 [key...]` | 计算多个集合的**交集** | 返回 “所有集合中都存在的元素”；例如：集合 A={a,b,c}、B={b,c,d}，交集为 {b,c} |
| `SDIFF key1 key2 [key...]`  | 计算多个集合的**差集** | 返回 “在 key1 中存在，但在其他集合中不存在的元素”；例如：A-B={a} |
| `SUNION key1 key2 [key...]` | 计算多个集合的**并集** | 返回 “所有集合的元素合并后去重的结果”；例如：A∪B={a,b,c,d}   |

##### 五、关键总结

- Set 类型的核心价值在于 “**去重**” 和 “**集合运算**”，尤其适合社交场景（好友、关注、共同兴趣）；
- 所有命令均围绕 “单个集合操作” 和 “多集合交互” 展开，需注意`SDIFF`的 “顺序依赖性”（key1 在前，结果以 key1 为基准）；
- 结合`SCARD`（计数）、`SISMEMBER`（判断）可快速实现数据统计与存在性校验，效率远高于列表（List）类型。

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018133421307.png" alt="image-20251018133421307" style="zoom:50%;" />

#### 第七节 SortedSet类型

Redis的 sorted Set是一个可排序的 set集合，与 java中的 Tree Set有些类似，但底层数据结构却差别很大。 sorted Set中的每一个元素都带有一个 score属性，可以基于 score属性对元素排序，底层的实现是一个跳表(SkipList)加 hash表。 sorted Set具备下列特性：
●可排序
●元素不重复
●查询速度快
因为 sorted Set的可排序特性，经常被用来实现排行榜这样的功能。



sorted Set的常见命令有:
● ZADD key score member:添加一个或多个元素到 sorted set,如果已经存在则更新其 score值
● ZREM key member:删除 sorted set中的一个指定元素
● ZSCORE key member:获取 sorted set中的指定元素的 score值
● ZRANK key member:获取 sorted set中的指定元素的排名
● ZCARD key:获取 sorted set中的元素个数
● ZCOUNT key min max:统计 score值在给定范围内的所有元素的个数
● ZINCRBY key increment member:让 sorted set中的指定元素自增，步长为指定的 increment值
● ZRANGE key min max:按照 score排序后，获取指定排名范围内的元素
● ZRANGEBYSCORE key min max:按照 score排序后，获取指定 score范围内的元素
● ZDIFF、ZINTER、ZUNION:求差集、交集、并集

注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可



##### 一、核心特性：3 大关键能力

SortedSet 结合了 “Set 的去重性” 和 “排序能力”，同时兼顾查询效率，核心特性如下：

1. **可排序**：基于元素的`score`（分数）字段自动排序，默认按`score`升序排列，支持降序反转；
2. **元素唯一**：继承 Set 特性，元素（`member`）不可重复，若重复添加相同`member`，会更新其`score`；
3. **高效查询**：底层结构优化，无论是按`member`查`score`、按排名查元素，还是按`score`范围统计，效率均接近 O (logN)。

##### 二、底层结构：跳表（SkipList）+ 哈希表（Hash）

SortedSet 通过 “双结构组合” 实现功能，两者分工明确：

| 结构类型         | 核心作用        | 对应功能                                                     |
| ---------------- | --------------- | ------------------------------------------------------------ |
| 跳表（SkipList） | 排序 + 范围查询 | 按`score`排序、获取指定排名 / 分数范围的元素（如 Top N）     |
| 哈希表（Hash）   | 映射存储        | 存储`member`与`score`的键值对，支持快速通过`member`查`score`（O(1)） |

> 对比 Java 的`TreeSet`：两者均为 “有序集合”，但`TreeSet`底层是红黑树，依赖自定义比较器排序；而 SortedSet 依赖固定`score`排序，且底层双结构更适配 Redis 的高效读写场景。

##### 三、常用命令：7 类核心操作（含升 / 降序差异）

SortedSet 命令前缀统一为`Z`，核心命令可按 “增删改查、统计、范围查询” 分类，且**与排名相关的命令均支持 “降序反转”（加`REV`前缀）**：

| 命令分类         | 具体命令        | 语法示例                                           | 功能说明                                                     | 关键注意点                                                   |
| ---------------- | --------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 新增元素         | `ZADD`          | `ZADD key score1 member1 [score2 member2 ...]`     | 向有序集合添加 1 个 / 多个元素（`member`）及对应`score`      | 若`member`已存在，会覆盖其`score`                            |
| 删除元素         | `ZREM`          | `ZREM key member1 [member2 ...]`                   | 删除集合中的 1 个 / 多个`member`                             | 只需指定`member`，无需指定`score`                            |
| 查分数           | `ZSCORE`        | `ZSCORE key member`                                | 查询指定`member`的`score`                                    | 若`member`不存在，返回`nil`                                  |
| 查排名           | `ZRANK`         | `ZRANK key member`                                 | 按`score`升序，返回`member`的排名（从 0 开始计数）           | 降序用`ZREVRANK`，排名同样从 0 开始（如`ZREVRANK stu rose`查 Rose 的降序排名） |
| 统计总数         | `ZCARD`         | `ZCARD key`                                        | 查询有序集合的总元素个数                                     | 类似 Set 的`SCARD`命令                                       |
| 分数范围统计     | `ZCOUNT`        | `ZCOUNT key minScore maxScore`                     | 统计`score`在`[minScore, maxScore]`范围内的元素个数          | 示例：`ZCOUNT stu 0 80`统计 80 分以下的学生数                |
| 范围查询元素     | `ZRANGE`        | `ZRANGE key start end [WITHSCORES]`                | 按`score`升序，获取 “排名从 start 到 end” 的元素（start/end 从 0 开始） | 1. 降序用`ZREVRANGE`（如`ZREVRANGE stu 0 2`查前三名）；2. 加`WITHSCORES`可同时返回元素的`score` |
| 分数范围查询元素 | `ZRANGEBYSCORE` | `ZRANGEBYSCORE key minScore maxScore [WITHSCORES]` | 按`score`升序，获取`score`在`[min, max]`内的元素             | 降序用`ZREVRANGEBYSCORE`，示例：`ZRANGEBYSCORE stu 0 80`查 80 分以下的学生 |
| 分数自增         | `ZINCRBY`       | `ZINCRBY key increment member`                     | 给指定`member`的`score`增加`increment`（可负，即减分）       | 示例：`ZINCRBY stu 2 amy`给 Amy 加 2 分，`ZINCRBY stu -3 tom`给 Tom 减 3 分 |

##### 四、典型应用场景：排行榜是核心

SortedSet 的 “有序 + 范围查询” 特性，最适配需要 “按数值排序” 的场景，典型如下：

1. **各类排行榜**：如游戏战力榜（按战力`score`降序取 Top 100）、商品销量榜（按销量`score`排序）、学生成绩榜（按分数`score`排序）；
2. **范围统计**：如统计某 APP “积分在 100-500 之间的用户数”（`ZCOUNT`）、筛选 “考试分数≥90 的优秀学生”（`ZRANGEBYSCORE`）；
3. **带权重的队列**：如任务优先级队列，按任务优先级（`score`）排序，优先执行`score`高的任务。



### 第三章 redis的Java客户端

![image-20251018135321354](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018135321354.png)

##### 二、三大主流 Java 客户端对比

##### 1. Jedis（Java Redis 的缩写）

- **核心特点**：方法名与 Redis 命令完全一致（如`set()`对应`SET`命令、`get()`对应`GET`命令、`mset()`对应`MSET`命令），学习成本极低，上手快。
- **使用现状**：早期最广泛使用的客户端，至今仍有大量企业沿用。
- **关键局限**：Jedis 实例**线程不安全**，多线程环境下需为每个线程创建独立连接，必须通过**连接池**管理连接以避免性能损耗。

##### 2. Lettuce

- 核心特点

  ：

  - 底层基于**Netty 高性能网络框架**实现，支持同步、异步连接及**响应式编程**（符合当前主流编程模式）。
  - 实例**线程安全**，无需额外处理多线程并发问题。
  - 对 Redis 高级特性（哨兵模式、集群模式）支持完善。

- **官方适配**：Spring 官方默认兼容的 Redis 客户端，与 Spring 生态（如 Spring Boot、Spring Cloud）整合性极强。

- **优势场景**：高吞吐、异步响应式业务，或基于 Spring 技术栈的项目。

##### 3. Redisson

- **核心特点**：不聚焦 Redis 基础操作，而是基于 Redis 实现**分布式环境下的 Java 工具类**，解决单机工具类（如`HashMap`、`Queue`、`Lock`）在分布式场景下失效的问题。
- **核心能力**：提供分布式 Map、分布式队列、分布式锁、分布式信号量、分布式原子整形等组件，开箱即用，无需手动实现分布式逻辑。
- **优势场景**：有明确分布式工具需求的场景（如分布式锁、分布式计数器），可直接复用组件，避免 “重复造轮子”。

##### 三、客户端选择与后续学习规划

##### 1. 基础业务选择建议

- 普通 Redis 业务（如数据缓存、简单键值操作）：优先选择**Jedis 或 Lettuce**，二者均能满足基础需求，具体取决于项目技术栈（非 Spring 栈可选 Jedis，Spring 栈优先 Lettuce）。

##### 2. 后续学习重点

- **Spring Data Redis**：Spring 提供的 Redis 整合框架，定义统一 API，底层可切换 Jedis 或 Lettuce 实现，学习一次即可掌握两种客户端的使用，提升效率。
- **Jedis 原生使用**：考虑到部分企业仍依赖 Jedis，需补充其原生用法（含连接池配置）。
- **Redisson 专项学习**：结合 “分布式锁” 场景讲解，聚焦其分布式工具类的实际应用，而非基础操作。



#### 第一节 jedis客户端

#### 第二节lettuce客户端

#### 第三节 springDataRedis

1. SpringDataRedis 的定位
   - 属于 **Spring Data** 模块，该模块整合了对关系型数据库、NoSQL 等多种数据存储的操作方案。
   - 是 Spring 对 Redis 操作的封装方案，底层整合了 **Jedis** 和 **Lettuce** 两种 Redis Java 客户端。
2. 核心特性
   - 提供统一操作 API：核心类为 `RedisTemplate`，类比 `JdbcTemplate` 对数据库的封装逻辑。
   - 丰富的功能支持：支持发布订阅、哨兵模式、集群模式，还能基于 Lettuce 实现响应式编程。
   - 内置序列化机制：支持 JDK、JSON、字符串等多种数据的序列化与反序列化，解决了 Java 对象直接存入 Redis 的问题，无需手动转换字节或字符串。
   - 支持 Redis 分布式集合：基于 Redis 重新实现了队列、链表等集合类型，具备跨系统的分布式特性。
3. RedisTemplate 的设计思想
   - 按 Redis 数据类型分组封装 API，避免方法臃肿：
     - `opsForValue()`：操作字符串（String）类型数据
     - `opsForHash()`：操作哈希（Hash）类型数据
     - `opsForList()`：操作列表（List）类型数据
     - `opsForSet()`：操作集合（Set）类型数据
     - `opsForZSet()`：操作有序集合（SortedSet）类型数据
   - `RedisTemplate` 类本身封装的是通用命令或特殊命令。