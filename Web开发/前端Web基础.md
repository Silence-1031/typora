# Web前端基础

- Web 前端开发**核心目标**：开发前端网页程序，将后端传递的数据以 “美观、易用的样式” 呈现给用户（即 “数据可视化 + 交互体验”）。

- 网页组成元素：所有网页的基础内容均包含 4 类核心元素，是前端开发的 “内容载体”：
  1. 文本（大段文字、标题、段落等）；
  2. 媒体（图片、视频、音频）；
  3. 超链接（跳转至其他页面 / 位置的交互入口）；
  4. 交互组件（按钮、表单、菜单等）。

- Web 标准核心：Web 标准明确网页由 “结构、表现、行为” 三部分组成，由W3C负责制定。分别对应 3 种核心技术，三者协同实现完整网页功能

|       技术       | 负责模块 |                           核心作用                           |
| :--------------: | :------: | :----------------------------------------------------------: |
|       HTML       |   结构   | 定义网页的 “内容骨架”，包括文本、图片、超链接等元素的排列与存在（无样式） |
|       CSS        |   表现   | 控制网页的 “视觉样式”，包括字体（大小 / 颜色 / 类型）、布局（位置 / 间距）、背景等 |
| JavaScript（JS） |   行为   | 实现网页的 “动态交互”，包括鼠标悬停效果、轮播图自动播放、菜单展开 / 收起等 |

除了 “HTML/CSS/JS” 三大基础技术，还有企业级开发中常用的进阶技术，构成完整技术栈：

- **JS 框架**：基于 JS 封装的高效开发工具，如 Vue 3（当前主流框架，视频课程重点）；
- **UI 组件库**：基于框架的现成视觉组件集合，如 Element Plus（用于快速搭建桌面端页面）；
- **前后端交互技术**：实现前端与后端的数据通信，如 AJAX（异步请求数据，无需刷新页面）、XSource；
- **工程化工具**：Vue 脚手架（快速构建 Vue 项目结构，规范开发流程）。

## 第一章 HTML-CSS

### 第一节 入门程序

一、HTML 核心概念

1. HTML（Hyper Text Markup Language，超文本标记语言）是构建网页结构的核心技术

- 超文本（Hyper Text）：突破普通文本（如记事本仅能记录文字）的限制，可集成图片、音频、视频、超链接等多媒体资源。

  示例：浏览器中打开的新闻页面，包含加粗标题、可跳转的超链接（如点击 “新华社” 跳转新页面）、可播放的视频、图文内容等，均属于超文本范畴。

- 标记语言（Markup Language）：由 “标签” 构成的语言，标签是 HTML 的基本单位，语法为`<标签名>`（开始标签）和`</标签名>`（结束标签），中间包裹内容。

  示例：

  - 双标签：`<h1>标题内容</h1>`（`<h1>` 为开始标签，`</h1>` 为结束标签，控制内容为一级标题样式）；
  - 单标签：`<img src="图片路径">`（无结束标签，用于引入图片，`src` 是标签的 “属性”，指定图片来源）。

2. HTML 的两大关键特点

- **标签预先定义，不可自定义**：HTML 的标签功能是固定的，浏览器仅识别预设标签（如 `<h1>` 定义标题、`<img>` 定义图片、`<video>` 定义视频），自定义标签（如 `<it黑马>`）会被浏览器忽略。
- **依赖浏览器运行**：HTML 标签需经浏览器解析后，才能渲染为可视化的网页效果（如浏览器识别 `<h1>` 后，自动将内容加粗放大显示）。

二、CSS 核心概念

1. CSS（Cascading Style Sheets，层叠样式表）是控制网页 “样式” 的技术，与 HTML 分工明确：HTML 负责 “结构”，CSS 负责 “外观”。

2. 核心作用：美化 HTML 结构：当 HTML 搭建好网页骨架后，CSS 可修改元素的样式（如颜色、字体、大小、位置等）。

- 示例：若需将 `<h1>HTML入门程序</h1>` 中的文字改为红色，可通过 HTML 标签的 `style` 属性引入 CSS 样式：

```html
<h1 style="color: red;">HTML入门程序</h1>
```

（`style` 是 HTML 标签的属性，`color: red` 是 CSS 样式规则，控制文字颜色为红色）。

三、HTML 入门程序开发

通过制作一个简单 HTML 页面，掌握 HTML 的基本结构、开发流程及语法特点

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251102135720358.png" alt="image-20251102135720358" style="zoom: 67%;" />

| 步骤 |      操作内容      |                           细节说明                           |
| :--: | :----------------: | :----------------------------------------------------------: |
|  1   |   创建 HTML 文件   | 在文件夹中新建文本文件，将后缀名改为 `.html`（如 `01-HTML快速入门.html`），文件会被浏览器识别为网页文件。 |
|  2   | 编写 HTML 基本骨架 | 所有 HTML 页面的基础结构由 3 个核心标签构成，是网页的 “骨架” |
|  3   |  编写页面主体内容  | 在 `<body>` 标签中添加需求内容：1. 一级标题：`<h1>Hello HTML</h1>`；2. 图片：先将图片（如 `1.png`）放入文件夹，再用 `<img>` 标签引入：`<img src="1.png">`（`src` 属性指定图片路径）。 |

```html
<html> <!-- 根标签，包裹所有HTML内容 -->
    <head> <!-- 头部标签，存放浏览器用的信息（如网页标题） -->
        <title>HTML快速入门</title> <!-- 定义网页标题，显示在浏览器顶部 -->
    </head>
    <body> <!-- 主体标签，存放用户可见的内容（如文字、图片） -->
   		<!-- 后续添加用户可见内容 -->
    </body>
</html>
```

四、HTML 语法特点

HTML 语法结构较松散，容错性强，但开发中建议遵循规范以保证可读性：

1. **标签不区分大小写**：`<HTML>`、`<html>`、`<Html>` 效果一致，但推荐使用小写（如 `<html>`）；
2. **属性值引号可灵活选择**：标签属性的值（如 `<img src="1.png">` 中的 `1.png`）可用双引号或单引号包裹，推荐使用双引号；
3. **语法松散（不严谨）**：即使遗漏结束标签（如只写 `<html>` 不写 `</html>`），浏览器仍可能正常渲染，但建议完整编写开始 / 结束标签（单标签除外），避免后续问题。





### 第二节 常用标签和样式

一、浏览器解析渲染机制

- **解析顺序**：浏览器对 HTML 页面采用**从上到下逐行解析**的方式，因此开发时需遵循 “从上到下” 的代码编写逻辑（如先写标题部分，再写正文部分），确保页面渲染效果与代码逻辑一致。

二、HTML 核心标签（标题与超链接）

1. 标题标签（`<h1> `~ `<h6>`）

- **功能**：定义网页中的标题文本，用于区分内容层级，提升页面语义化（便于搜索引擎抓取、屏幕阅读器识别）。
- 特性
  - 共 6 级标签，从`<h1>`到`<h6>`，**级别越高，字体默认大小越大**（`<h1>`最大，`<h6>`最小），无`<h7>`及以上标签（HTML 标签为预定义，不可自定义）。
  - 实战应用：央视新闻网页的主标题使用`<h1>`标签，例：`<h1>新思想引领新征程</h1>`，默认呈现 “加大加粗” 效果。

2. 超链接标签（`<a>`）

- **功能**：定义可点击的链接，实现页面跳转。

- 核心属性

  |  属性名  |          作用           |                    常见取值                    |                             说明                             |
  | :------: | :---------------------: | :--------------------------------------------: | :----------------------------------------------------------: |
  |  `href`  | 指定链接目标地址（URL） | 绝对 URL（如`https://www.cctv.com`）、相对 URL |                 决定点击链接后 “跳转到哪里”                  |
  | `target` |    指定链接打开方式     |           `_self`（默认）、`_blank`            | `_self`：在当前浏览器窗口打开链接，会覆盖原页面<br>`_blank`：在新浏览器窗口打开链接，保留原页面 |

3. 文本内容处理

- 纯文本（如新闻发布时间 “2024 年 5 月”）可直接在 HTML 中编写，无需包裹标签，编辑器中的换行不会影响页面显示效果（页面中仍为连续文本）。

三、HTML 页面基本结构

- 核心骨架通过 VS Code 输入`!`（英文感叹号）并回车，自动生成 HTML5 基本结构，关键部分如下：

  ```html
  <!DOCTYPE html> <!-- 声明文档类型为HTML5 -->
  <html lang="zh-CN"> <!-- 根标签，指定页面语言为中文 -->
  <head>
    <meta charset="UTF-8"> <!-- 字符编码，确保中文正常显示 -->
    <title>新思想引领新征程</title> <!-- 网页标题（浏览器标签栏显示），需与新闻主标题一致 -->
  </head>
  <body>
    <h1>新思想引领新征程</h1>
    <a href="https://www.cctv.com" target="_blank">央视网</a> 2024年5月
  </body>
  </html>
  ```

- **`<title>`标签作用**：定义浏览器标签栏显示的文本，需与网页核心内容匹配（如央视新闻的主标题），提升用户识别度。

- **预览与调试**：通过 “Open with Live Server” 启动服务，实时预览页面，验证标题、链接、时间的显示与跳转效果。



### 第三节 CSS样式

 一、HTML 引入 CSS 的三种方式

1. 行内样式（Inline Style）

- **定义**：在 HTML 标签内通过 `style` 属性直接编写 CSS 样式，仅作用于当前标签。

- 语法

  ```html
  <标签名 style="CSS属性: 值; CSS属性: 值;">内容</标签名>
  ```

  示例：

  ```html
  <span style="color: gray;">2024-10-24</span>
  <!-- span没有具体含义，仅表示用一个标签包裹起来 -->
  ```

- 特点

  - 优先级最高（仅低于 `!important`），直接覆盖其他样式。
  - 复用性最差，仅对单个标签生效，不适用于批量样式控制。
  - 常用于 JavaScript 动态修改样式的场景。

2. 内部样式（Internal Style）

- **定义**：在 HTML 文档的 `<head>` 标签内通过 `<style>` 标签**包裹 CSS 代码**，作用于当前整个 HTML 页面。

  ```html
  <head>
    <style>
      选择器 {
        CSS属性: 值;
        CSS属性: 值;
      }
    </style></head>
  ```

  ```html
  <head>
    <style>
      span { color: gray; } /* 页面中所有 span 标签内容均为灰色 */
    </style>
  </head>
  ```

- 特点

  - 复用性中等，仅对当前页面生效，无需额外引入文件。
  - 代码集中在 HTML 内，适合小型页面或单页面样式管理。

3. 外部样式（External Style）

- **定义**：将 CSS 代码单独编写在 `.css` 文件中，通过 `<link>` 标签在 HTML 中引入，可跨多个页面复用。

- 步骤

  1. 创建独立 CSS 文件（如 `news.css`），编写样式：`span { color: gray; }`。

  2. 在 HTML 的`<head>`中引入文件：`<link rel="stylesheet" href="CSS/news.css">`

     （`href`为 CSS 文件路径）。

- 特点

  - 复用性最强，一个 CSS 文件可被多个 HTML 页面引用，便于项目统一样式管理。
  - 代码分离，HTML 专注结构，CSS 专注样式，符合前端工程化规范。

- **样式优先级**：行内样式 > 内部样式 = 外部样式（若选择器权重相同，后定义的样式覆盖先定义的）；`!important` 可强制提升样式优先级（如 `color: red !important;`）



二、CSS 颜色的四种表示形式

1. 关键字表示法（英文单词）

- **定义**：使用预定义的英文单词描述颜色，如 `red`（红色）、`green`（绿色）、`gray`（灰色）。
- 语法：`color: 颜色关键字;`
- 优缺点
  - 优点：语法简单，易理解。
  - 缺点：颜色种类有限（仅支持约 140 种标准色），无法精确匹配自定义颜色（如淡灰色、深灰色难以区分）。

2. RGB 表示法（三原色混合）

- **定义**：通过红（Red）、绿（Green）、蓝（Blue）三原色的数值混合表示颜色，每种颜色取值范围为 `0-255`（0 表示无该颜色，255 表示该颜色最饱和）。

- 语法：`color: rgb(红, 绿, 蓝);`

  示例：

  - `rgb(255, 0, 0)`：红色（仅红色饱和）。
  - `rgb(178, 178, 178)`：灰色（三原色数值相等，混合为中性色）。

- **特点**：可表示 `256×256×256 = 16777216` 种颜色，覆盖绝大多数日常需求。

3. RGBA 表示法（带透明度的 RGB）

- **定义**：在 RGB 基础上增加 Alpha（透明度）通道，取值范围为 `0-1`（0 完全透明，1 完全不透明，0.5 半透明）。

- 语法:`color: rgba(红, 绿, 蓝, 透明度);`

  示例：`rgba(178, 178, 178, 0.7)`

- **应用场景**：需要实现半透明效果时使用（如 hover 时的文字淡入、叠加层文字等）。

4. 十六进制表示法（Hexadecimal）

- **定义**：将 RGB 中每种颜色的 `0-255` 数值转换为两位十六进制数（00-FF），以 `#` 开头表示。
- 语法
  - 完整形式：`color: #RRGGBB;`（RR 对应红色，GG 对应绿色，BB 对应蓝色）。
  - 简化形式：若 RR、GG、BB 每组两位数值相同，可缩写为一位，如 `#0000FF` 可缩写为 `#00F`（蓝色）。
- 示例
  - `#888888` 或 `#888`：中灰色（对应 RGB (136, 136, 136)）。
  - `#B2B2B2`：淡灰色（对应 RGB (178, 178, 178)，常用于新闻发布时间等次要信息）。
- **特点**：前端开发中最常用的颜色表示法，简洁且易通过工具（如拾色器）拾取。



三、css选择器

1. CSS 三大基础选择器

| 选择器类型 |    语法格式    |             作用范围              |                           示例代码                           |
| :--------: | :------------: | :-------------------------------: | :----------------------------------------------------------: |
| 元素选择器 |  直接写标签名  |      页面中**所有同名标签**       |  `span { color: gray; }`（设置所有`<span>`标签文字为灰色）   |
|  类选择器  | `.class属性值` | 页面中**所有 class 值匹配的标签** | 1. HTML：`<span class="time">发布时间</span>`<br>2. CSS：`.time { color: red; }` |
| ID 选择器  |  `#id属性值`   |  页面中**唯一 id 值匹配的标签**   | 1. HTML：`<span id="news-time">发布时间</span>`<br>2. CSS：`#news-time { color: blue; }` |

2. 选择器优先级：**ID 选择器 > 类选择器 > 元素选择器**

- 示例场景：若一个`<span>`标签同时满足 “元素选择器（span）”“类选择器（.time）”“ID 选择器（#news-time）”，且三者都设置了`color`属性，则最终生效的是 ID 选择器的样式（如蓝色），其次是类选择器（如红色），最后是元素选择器（如灰色）。

3. 去除超链接默认下划线

- 问题：超链接（`<a>`标签）默认显示文本下划线

- 解决方案：

  - 核心 CSS 属性：`text-decoration`（控制文本装饰线，`none`表示去除装饰线）。

  - 代码实现（元素选择器，适合页面只有一个超链接的场景）：

    ```
    a { text-decoration: none; }
    ```

  - 拓展：若需精准定位某个超链接，可结合类选择器 / ID 选择器（如`.news-link { text-decoration: none; }`）。

4. 补充：其他常用选择器（了解）

| 选择器类型 | 语法格式                 | 作用说明                                       | 示例                                                         |
| ---------- | ------------------------ | ---------------------------------------------- | ------------------------------------------------------------ |
| 分组选择器 | 选择器 1, 选择器 2, ...  | 同时给多个选择器设置相同样式，简化代码         | `h1, h2, .title { font-weight: bold; }`（h1、h2、class 为 title 的元素均加粗） |
| 属性选择器 | 标签名 [属性名 = 属性值] | 根据标签的属性及属性值定位元素，适合表单等场景 | `input[type="text"] { border: 1px solid #ccc; }`（定位 type 为 text 的输入框） |
| 后代选择器 | 父元素 子元素            | 定位 “父元素内部的所有子元素”，适合嵌套结构    | `div span { color: #666; }`（定位`<div>`内部所有`<span>`标签） |



### 第四节 正文样式

一、核心标签及属性

1. 视频标签 `<video>`：用于在网页中嵌入视频文件，是正文排版的核心多媒体标签之一。

|       属性       |                     作用说明                      |                         关键注意事项                         |
| :--------------: | :-----------------------------------------------: | :----------------------------------------------------------: |
|      `src`       |  指定视频文件的访问路径（支持绝对路径/相对路径）  | 路径规则与图片标签 `<img>` 一致，优先使用相对路径（避免磁盘路径，兼容性差） |
|    `controls`    | 显示视频播放控件（如播放/暂停、进度条、音量调节） |  **必须添加**，否则视频无法交互（仅显示静态画面，无法播放）  |
|    `autoplay`    |            页面加载完成后自动播放视频             | 部分浏览器（如 Chrome）需配合 `muted`（静音）属性才生效，实际开发按需使用 |
| `width`/`height` |                 设置视频宽度/高度                 | 仅需设置一个属性（如 `width="800px"` 或 `width="80%"`），另一个会等比例缩放 |

**示例代码**：

```html
<video src="video/news.mp4" controls width="80%"></video>
<!--px:像素，%：百分比-->
```



2. 音频标签 `<audio>`:用于嵌入音频文件，属性逻辑与 `<video>` 相似。

|    属性    |                  作用说明                   |
| :--------: | :-----------------------------------------: |
|   `src`    |   指定音频文件路径（如 `audio/news.mp3`）   |
| `controls` | 显示音频播放控件（播放/暂停、进度条、音量） |

**示例代码**：

```html
<audio src="audio/news.mp3" controls></audio>
```



3. 图片标签 `<img>`：用于嵌入图片（正文排版中与文字相间排列），是多媒体内容的核心载体。

|       属性       |                   作用说明                   |                           关键细节                           |
| :--------------: | :------------------------------------------: | :----------------------------------------------------------: |
|      `src`       | 指定图片文件的访问路径（核心属性，不可缺失） |                  支持 GIF、PNG、JPG 等格式                   |
| `width`/`height` |              设置图片宽度/高度               | 同视频标签逻辑，仅设一个属性即可实现等比例缩放（如 `width="80%"`） |

**示例代码**：

```html
<img src="image/1.gif" width="80%">
```



4. 段落标签 `<p>` 与换行标签 `<br>`：用于正文文字排版，实现文字分段和换行，保证页面可读性。

|  标签  |                  作用说明                  |                        区别与使用场景                        |
| :----: | :----------------------------------------: | :----------------------------------------------------------: |
| `<p>`  | 定义一个完整段落，段落间会自动添加垂直间距 |  用于大段文字的“分段”（如新闻正文的不同段落），结构更语义化  |
| `<br>` |           强制换行（无垂直间距）           | 用于段落内部的“换行”（如一句话内的换行），不推荐用于段落间分隔 |

**示例代码**：

```html
<!-- 段落分隔（有间距） -->
<p>央视网消息：行走在长江沿线，我们本意是...</p>
<p>接下来，正文内容继续展开...</p>

<!-- 段落内换行（无间距） -->
<p>第一行文字<br>第二行文字（与上一行紧连）</p>
```



二、路径规则

`src` 属性（视频/音频/图片）的路径分为 **绝对路径** 和 **相对路径**，实际开发中优先使用相对路径（兼容性强、移植性好）。

1. 绝对路径

- **绝对磁盘路径**：从磁盘根目录开始的路径（如 `C:\课程素材\央视新闻\video\news.mp4`）
  ❌ 强烈不推荐：仅本地生效，网页部署到服务器后会失效，且跨设备无法访问。
- **绝对网络路径**：从网络域名开始的完整路径（如 `https://xxx.com/image/1.gif`）
  ✅ 适用场景：引用网络上的公共资源（如第三方图片、视频），需确保资源链接长期有效。

2. 相对路径

以当前 HTML 文件所在目录为基准，定位目标文件的路径，是开发中最常用的方式。

| 符号  |             含义             |                           示例场景                           |
| :---: | :--------------------------: | :----------------------------------------------------------: |
| `./`  | 表示“当前目录”（可省略不写） | 若 HTML 文件与 `image` 文件夹同级，引用图片：`./image/1.gif` 或 `image/1.gif` |
| `../` |       表示“上一级目录”       | 若 HTML 文件在 `html` 文件夹内，`image` 在 `html` 上级目录：`../image/1.gif` |

**场景示例**：
假设文件结构如下：

```
项目文件夹/
├─ html/
│  └─ index.html （当前编辑的HTML文件）
├─ video/
│  └─ news.mp4
└─ image/
   └─ 1.gif
```

- 引用视频：`../video/news.mp4`（从 `html` 文件夹向上一级，找到 `video` 文件夹）
- 引用图片：`../image/1.gif`（同上逻辑）



三、文本加粗：语义化标签与非语义化标签

| 标签       | 功能     | 推荐场景                            |
| ---------- | -------- | ----------------------------------- |
| `<b>`      | 文本加粗 | 仅需视觉加粗，无语义需求            |
| `<strong>` | 文本加粗 | 需强调文本重要性（如 “央视网消息”） |

**实操要点**：开发中优先使用 `<strong>`，符合 HTML 语义化原则，便于搜索引擎识别和无障碍访问。



四、行高控制：CSS `line-height` 属性

用于调整段落文本的行间距，提升可读性：

1. **属性作用**：定义文本行与行之间的垂直距离，影响段落整体美观度。

2. 常用取值方式

   - **倍数取值**（推荐）：如 `line-height: 2`，表示行高为当前字体大小的 2 倍（无需加单位），适配不同字体大小，兼容性好。
   - **像素取值**：如 `line-height: 30px`，固定行高，适合固定字体大小的场景（灵活性较低）。

3. 应用场景：通过元素选择器为所有段落设置，示例代码：

   ```css
   /* 为所有<p>标签设置2倍行高 */
   p {
     line-height: 2; 
   }
   ```

   

五、首行缩进：CSS `text-indent` 属性

用于实现段落首行缩进（如中文新闻正文首行缩进 2 个字符），替代繁琐的空格实体：

1. **属性作用**：指定文本块首行的缩进量，仅对块级元素（如 `<p>`）生效。

2. **关键取值**：`text-indent: 2em`，其中 `em` 是相对单位（1em = 当前字体大小），`2em` 恰好对应 “2 个字符宽度”，适配不同字体大小。

3. **优势**：一次设置可作用于所有目标段落，避免手动添加多个空格实体，代码更简洁易维护。

4. 示例代码

   ```css
   /* 为所有<p>标签设置首行缩进2个字符 */
   p {
     text-indent: 2em; 
   }
   ```

   

六、HTML 字符实体：解决特殊符号显示问题

HTML 中部分符号（如空格、`<`、`>`）会被解析为语法，需用 “字符实体” 表示才能正常显示：

| 需求            | 字符实体 | 说明                                      |
| --------------- | -------- | ----------------------------------------- |
| 显示单个空格    | `&nbsp`  | 替代键盘输入的空格（HTML 会忽略连续空格） |
| 显示小于号（<） | `&lt`    | 避免被解析为标签开始符号                  |
| 显示大于号（>） | `&gt`    | 避免被解析为标签结束符号                  |



七、其他文本样式标签

| 样式需求 | 非语义化标签 | 语义化标签（推荐） | 说明                              |
| -------- | ------------ | ------------------ | --------------------------------- |
| 下划线   | `<u>`        | `<ins>`            | `<ins>` 表示 “插入的文本”，含语义 |
| 倾斜     | `<i>`        | `<em>`             | `<em>` 表示 “强调文本”，含语义    |
| 删除线   | `<s>`        | `<del>`            | `<del>` 表示 “删除的文本”，含语义 |

**核心原则**：视觉样式与语义结合，优先使用带语义的标签（如 `<em>`、`<ins>`），提升页面可访问性和 SEO 效果。



### 第五节 网页布局

一、网页整体居中布局实现

1. 使网页内容（如央视新闻标题、正文、图片等）水平居中，左右留白均等，且内容宽度占页面总宽度的 70%。

2. 实现步骤

   - **创建容器标签**：用 `<div>` 标签包裹页面所有内容，并为其设置唯一 ID（如 `id="content-container"`），作为**布局控制的统一容器**。

   - 编写 CSS 样式：通过 CSS 控制容器的宽度和居中效果，核心代码如下：

   ```css
   #content-container {
     width: 70%; /* 内容宽度占页面总宽度的70% */
     margin-left: auto; /* 左侧外边距自动 */
     margin-right: auto; /* 右侧外边距自动 */
     /* 简化写法：margin: 0 auto; （上下外边距0，左右自动） */
   }
   ```

   - **适配内部元素**：若容器内元素（如图片、视频）宽度与容器不一致，需将其宽度设为 `width: 100%;`，确保与**容器宽度**同步。

 二、CSS 盒子模型（核心布局模型）

1. 盒子模型的 4 个组成部分

- 盒子：页面中所有的元素（标签），都可以看做是一个盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局

| 组成部分   | 英文    | 作用                                                 | 对应属性                                                     |
| ---------- | ------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 内容展示区 | Content | 显示标签核心内容（如文字、图片）                     | `width`（宽度）、`height`（高度）                            |
| 内边距     | Padding | 内容区与边框之间的空白区域，用于调整内容与边框的距离 | `padding`（复合属性）、`padding-top`/`padding-left`等（单方向属性） |
| 边框       | Border  | 包裹内边距和内容区的线条，用于视觉分隔               | `border`（复合属性，需指定宽度、样式、颜色，如 `border: 20px solid pink;`） |
| 外边距     | Margin  | 盒子与其他盒子之间的空白区域，用于控制盒子的位置     | `margin`（复合属性）、`margin-top`/`margin-left`等（单方向属性） |

![image-20251107130928877](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107130928877.png)

2. 盒子模型关键属性详解

 （1）`box-sizing`：控制盒子宽高的计算方式

- **默认值（`content-box`）**：`width`/`height` **仅计算「内容区（Content）」的宽高**，内边距（Padding）和边框（Border）会额外增加盒子总尺寸（可能导致盒子 “变大”）。

- 推荐值（`border-box`）

  计算「内容区 + 内边距 + 边框」的总宽高，内边距和边框不会改变盒子总尺寸，布局更可控，代码示例：
  
  ```css
  #content-container {
    box-sizing: border-box; /* 宽高包含内边距和边框 */
    width: 400px;
    height: 300px;
    padding: 30px;
    border: 20px solid pink;
  }
  ```

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107132309839.png" alt="image-20251107132309839" style="zoom:80%;" />

（2）`padding`/`margin` 复合属性的取值规则

```css
div{
	width: 200px;
	height: 100px;
	background-color: #05a5d2;
	padding: 20px 20px 20px 20px;
	border: 20px solid #6bd5d7;
	margin: 30px 30px 30px 30px;
}
```

- **1 个值**：上下左右边距均为该值（如 `padding: 20px;` → 四方向内边距 20px）。
- **2 个值**：第一个值控制「上下」，第二个值控制「左右」（如 `margin: 30px auto;` → 上下外边距 30px，左右自动居中）。
- **4 个值**：按「上→右→下→左」顺时针顺序赋值（如 `padding: 10px 20px 30px 40px;` → 上 10px、右 20px、下 30px、左 40px）。

3. 常用布局标签（DIV 与 SPAN）

| 标签     | 显示模式                 | 宽度 / 高度特性                                              | 适用场景                                 |
| -------- | ------------------------ | ------------------------------------------------------------ | ---------------------------------------- |
| `<div>`  | 块级元素（独占一行）     | 宽度默认等于父元素宽度，高度默认由内容撑开，可手动设置 `width`/`height` | 大区域布局（如页面容器、导航栏、正文区） |
| `<span>` | 行内元素（一行可放多个） | 宽度 / 高度均**由内容撑开**，**无法手动设置**                | 行内内容修饰（如高亮文字、小图标）       |



第五节 Tlias案例

 一、页面原型相关概念

1. **定义**：产品经理制作的早期项目模型，是前端、后端、UI 设计师的核心参考依据。
2. 核心作用
   - 呈现页面**基本布局**（如顶部导航栏、搜索区、数据表格、底部版权区）；
   - 明确页面**功能模块**（如搜索、退出登录、数据展示）；
   - 标注页面**交互设计**（如按钮点击效果、表单提交逻辑）。

二、顶部导航栏开发（HTML+CSS）

1. 需实现的关键效果：

- **内容**：显示标题（“Telius 智能学习辅助系统”）+ 退出登录超链接；
- **布局**：标题居左、超链接居右，二者在同一行；
- **样式**：导航栏灰色背景、标题白色字体（凯体）、超链接无默认下划线。

2. HTML 结构设计，通过嵌套标签实现内容组织，核心标签选择：

- 外层用 `<div class="navbar">` 包裹整个导航栏（便于统一控制背景、布局）；
- 标题用 `<h1>` ；
- 退出登录用 `<a href="#">退出登录</a>` 超链接标签。

示例结构：

```html
<div class="navbar">
  <h1>Telius 智能学习辅助系统</h1>
  <a href="#">退出登录</a>
</div>
```

3. CSS 样式控制

（1）基础样式：背景与字体

- 导航栏背景：给 `.navbar` 类设置 `background-color: #f0f0f0;`（浅灰色，可按需调整）；
- 标题样式：通过**后代选择器**（`.navbar h1`）控制标题，设置 `color: white;`（白色）、`font-family: "楷体";`（凯体字体）；
- 超链接样式：去除默认下划线，设置 `text-decoration: none;`，同时调整字体颜色为白色（`color: white;`）。

（2）布局关键：Flex 弹性布局

通过 Flex 解决 “标题居左、超链接居右” 的核心布局需求，是本次开发的重点。

 

三、Flex 弹性布局

![image-20251107133656766](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107133656766.png)

1. 基本概念

- **定位**：CSS 中的一维布局模型（仅沿 “横向” 或 “纵向” 一个方向排列元素）；
- **作用**：控制容器内**子元素**的**空间分布**（如元素间距）和**对齐方式**（如居左、居右、居中）；
- **使用前提**：给**父容器**（如导航栏的外层 `<div>`）设置 `display: flex;`，开启 Flex 布局。

2. 三大核心属性

| 属性名            | 作用                            | 常见取值及效果                                               |
| ----------------- | ------------------------------- | ------------------------------------------------------------ |
| `display`         | 开启 Flex 布局                  | `flex`：父容器启用 Flex 布局（子元素默认横向排列）；`block`/`inline`：关闭 Flex 布局 |
| `flex-direction`  | 设置 “主轴方向”（元素排列方向） | `row`（默认）：主轴为水平方向（子元素横向排列）；<br>`column`：主轴为垂直方向（子元素纵向排列） |
| `justify-content` | 控制子元素在 “主轴上的对齐方式” | `flex-start`：从头排列（默认，子元素贴左 / 上）；<br>`flex-end`：从尾排列（子元素贴右 / 下）；<br>`center`：居中排列；<br>`space-around`：子元素平分剩余空间（元素两侧间距相等）<br> `space-between`：两侧元素贴边，中间元素平分剩余空间（顶部导航栏用此值实现 “居左 + 居右”） |

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107140656585.png" alt="image-20251107140656585" style="zoom:50%;" />

3. 实践应用（顶部导航栏）：

```css
.navbar {
  display: flex; /* 开启 Flex 布局 */
  justify-content: space-between; /* 两侧元素贴边，中间平分空间 */
  background-color: #f0f0f0; /* 灰色背景 */
  padding: 10px 20px; /* 内边距，避免内容贴边 */
}
```



### 第六节 表单

一、表单的核心作用

表单是 HTML 中负责**数据采集与提交**的核心组件，主要用于收集用户输入的信息（如账号、密码、搜索条件等），并将信息传递到服务器端进行处理（如登录验证、数据查询、信息保存）。

**典型应用场景**：注册 / 登录页面、搜索框、数据录入表单（如员工信息添加）。

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107141014543.png" alt="image-20251107141014543" style="zoom:50%;" />

二、核心标签：`<form>`

`<form>` 是定义表单的 “容器标签”，所有表单项（输入框、按钮等）必须嵌套在 `<form>` 内部才能生效。其核心属性决定了数据提交的目标和方式。

1. `<form>` 的两个核心属性

| 属性名   | 作用                                           | 关键说明                                                     |
| -------- | ---------------------------------------------- | ------------------------------------------------------------ |
| `action` | 指定表单数据的**提交地址**（服务器端接口 URL） | 例如 `action="/save"` 表示数据提交到服务器的 `/save` 路径；若未指定，默认提交到当前页面 URL |
| `method` | 指定表单数据的**提交方式**                     | 仅支持两种核心方式：`get`（默认）和 `post`，二者差异极大     |

2. 表单项的 “必选配置”：`name` 属性

​	所有表单项（如输入框、单选框等）要想正常提交数据，**必须设置 `name` 属性**，其作用是：

- 作为数据的 “标识键”，服务器端通过 `name` 识别对应的数据（如 `name="username"` 对应用户名数据）；
- 若未设置 `name`，表单项的数据会被忽略，无法提交到服务器。

**示例**：

```html
<!-- 正确：设置 name 属性，数据可提交 -->
<input type="text" name="username" placeholder="姓名">
<!-- 错误：无 name 属性，数据无法提交 -->
<input type="text" placeholder="姓名">
```

三、常见表单项标签

HTML 中用于采集用户数据的表单项标签主要有 **input**、**select**、**textarea** 三种，其中 `input` 标签通过 `type` 属性灵活实现多种输入形式，是最常用的表单项标签。

1. input 标签：通过 type 属性实现多形态输入

`input` 标签是表单项的核心，通过修改 `type` 属性值，可实现文本输入、密码隐藏、单选 / 多选等多种功能，常见 `type` 取值及说明如下表：

![image-20251107142357527](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107142357527.png)

2. select 标签：下拉列表选择

用于提供**固定选项的下拉列表**，适用于选项较多且需节省页面空间的场景（如学历、地区选择）。

- 结构组成

  - 外层 `select` 标签：定义下拉列表整体，通过 `name` 属性指定表单项名称（用于提交数据标识）；
  - 内层 `option` 标签：定义下拉列表中的单个选项，每个 `option` 需设置 `value` 属性（提交到服务器的值），标签内文本为页面显示的选项名称。

- 示例

  ```html
  <select name="education">
    <option value="1">大专</option>
    <option value="2">本科</option>
    <option value="3">硕士</option>
  </select>
  ```

- **关键注意点**：选择某选项后，提交的是 `option` 的 `value` 值，而非页面显示的文本（如选择 “本科”，提交值为 “2”）。



3. textarea 标签：多行文本域

用于输入大量文本（如备注、描述、留言），区别于 `input type="text"` 的 “单行限制”，支持多行输入且可调整大小。

- 核心属性

  - `name`：表单项名称（提交数据标识）；
  - `cols`：文本域的默认宽度（按字符数计算）；
  - `rows`：文本域的默认高度（按行数计算）；

- 示例

  ```html
  <textarea name="description" cols="30" rows="10"></textarea>
  ```

- **关键注意点**：页面中可手动拖动文本域的右下角，调整输入区域大小（如需固定大小，可通过 CSS 限制）。



四、Label 标签：关联表单项与文本，优化交互

- **功能**：将表单项（如单选按钮、复选框）与对应的文本描述 “绑定”，点击文本即可选中表单项，无需精准点击按钮，提升用户体验。

- 使用方式

  1. 直接用`label`标签包裹表单项和文本（推荐）；

     ```html
     <label><input type="radio" name="gender" value="1"> 男</label>
     <label><input type="radio" name="gender" value="2"> 女</label>
     ```

  2. 通过`label`的`for`属性与表单项的`id`关联（适用于文本与表单项分离的场景）

    ```html
     <input type="checkbox" id="hobby1" name="hobby" value="1">
     <label for="hobby1"> 运动</label>
    ```
  
- **关键注意点**：`for` 属性值必须与表单项的 `id` 完全一致，才能实现绑定。



五、表单提交与数据传递

1. 表单项的核心属性：确保数据正确传递

- `name`：表单项的 “标识名”，服务器通过该名称识别对应数据（如 `name="username"` 对应用户名数据）；
- `value`：表单项的 “实际提交值”，服务器最终接收的是该值（而非页面显示的文本，如单选按钮 “男” 的 `value="1"`）。



六、两种数据提交方式：`get` vs `post`

`method` 属性的 `get` 和 `post` 是表单提交的核心方式，二者在数据传输位置、安全性、数据量限制上差异显著，需根据场景选择：

| 对比维度     | `get` 方式                                                  | `post` 方式                                                  |
| ------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
| 数据传输位置 | 数据拼接在 **URL 末尾**（可见），格式：`URL?name=值&age=值` | 数据放在 **请求体（消息体）** 中（不可见，需通过浏览器开发者工具查看） |
| 安全性       | 低（数据暴露在 URL 中，易被截取，不适合隐私数据）           | 高（数据隐藏在请求体，适合密码、银行卡号等隐私数据）         |
| 数据量限制   | 有限制（URL 长度通常不超过 2KB，不同浏览器略有差异）        | 无限制（可提交大文件、大量文本等）                           |
| 适用场景     | 数据查询、搜索（如员工信息搜索，无隐私数据）                | 数据提交、保存（如注册、登录、文件上传）                     |

**实操验证**：

- `get` 提交：打开浏览器后，提交表单可直接在地址栏看到数据（如 `http://xxx/save?name=Tom&age=18`）；
- `post` 提交：需按 F12 打开 “开发者工具”→ 切换到 “网络” 面板 → 提交表单后查看请求的 “载荷（Payload）”，才能看到提交的数据。



第七节 CSS样式

- 布局控制
  - 使用 `display` 属性：如 `display: flex` 实现搜索框与按钮的水平排列，通过 `justify-content`（水平对齐）、`align-items`（垂直对齐）调整元素间距。
  - 宽度与边距：给表单容器设置固定宽度（如 `width: 600px`）或百分比宽度，通过 `margin: 0 auto` 实现表单区域水平居中，`padding` 控制表单内部元素与边框的间距。
- 视觉美化
  - 输入框样式：`border: 1px solid #ddd`（浅灰色边框）、`border-radius: 4px`（圆角）、`outline: none`（取消聚焦时的默认边框），聚焦时通过 `:focus` 伪类修改边框颜色（如 `border-color: #1E9FFF`）。
  - 按钮样式：`background-color: #1E9FFF`（主题色背景）、`color: #fff`（白色文字）、`border: none`（取消默认边框）、`border-radius: 4px`， hover 时通过 `:hover` 伪类调整背景色（如 `background-color: #0C86E5`），提升交互感。
- **响应式适配（可选延伸）**：通过 `@media` 媒体查询，在小屏幕设备（如手机）上调整表单宽度为 `100%`，避免横向滚动。



第八节 表格

一、HTML 表格标签

表格是前端展示结构化数据的核心组件

| 标签      | 作用与语义                             | 关键特性                                                     |
| --------- | -------------------------------------- | ------------------------------------------------------------ |
| `<table>` | 定义整个表格的容器，包裹所有表格内容   | 表格的顶层标签，所有行、单元格需嵌套在其内部                 |
| `<thead>` | 定义表格**表头区域**（列名行）         | 语义化标签，用于区分表头与数据主体，可省略（但推荐保留）     |
| `<tbody>` | 定义表格**数据主体区域**（实际数据行） | 语义化标签，包裹所有数据行，可省略（浏览器会默认生成）       |
| `<tr>`    | 定义表格的**一行**（表头行 / 数据行）  | 一个`<tr>`对应表格的一行，内部需嵌套`<th>`或`<td>`           |
| `<th>`    | 定义**表头单元格**（列名）             | 自带 “字体加粗 + 居中” 样式，明确列的语义（如 “姓名”“职位”） |
| `<td>`    | 定义**普通数据单元格**（实际数据）     | 无默认样式，需通过 CSS 控制对齐方式、内边距等                |
| `<img>`   | 表格中嵌入图片（如员工头像）           | 需通过`src`属性指定图片路径（本地路径 / 在线 URL），可配合 CSS 调整尺寸 |

1. **新增数据行**：如需增加表格数据，直接复制一份`<tbody>`内的`<tr>`，修改`<td>`中的内容即可（一个`<tr>`对应一行数据）。
2. **图片路径替换**：AI 生成的默认图片路径可能无效，需替换为真实路径（如课程资料中的在线图片 URL），确保图片正常显示。
3. **表头与数据区分**：表头用`<th>`（语义化 + 默认样式），数据用`<td>`（纯数据展示），避免混用导致语义混乱。

 二、CSS 样式调整（表格 + 按钮 + 对齐）

视频中通过 “AI 生成基础样式→手动优化” 的流程，重点讲解如何根据需求调整样式，核心调整场景及方法如下：

1. 表格内容对齐（高频需求）

- **默认问题**：AI 生成的表格可能默认 “左对齐”，不符合视觉统一需求。

- 解决方案：通过 CSS 选择器统一控制`<th>`和`<td>`的对齐方式：

  ```css
  th, td {
    text-align: center; /* 居中对齐（可选left/right） */
    padding: 8px 12px;  /* 单元格内边距，避免内容拥挤 */
  }
  ```

2. 操作按钮样式优化

- **默认问题**：AI 生成的按钮可能带多余边框或间距，影响美观。

- 解决方案

  1. 删除 AI 生成的冗余样式（如`.action-buttons`中不必要的边框、定位）；

  2. 如需自定义按钮样式，可新增 CSS（如背景色、圆角、内边距），示例：

     ```css
     .operate-btn {
       background-color: #409eff;
       color: white;
       border: none;
       padding: 4px 8px;
       border-radius: 4px;
       cursor: pointer;
     }
     ```

3. 底部版权区样式：通过`<footer>`标签实现，核心样式需求及 CSS 对应属性：

|   样式需求   |                      CSS 属性与值                      |                     作用                      |
| :----------: | :----------------------------------------------------: | :-------------------------------------------: |
|  灰色背景色  | `background-color: #f5f5f5;`（或与顶部导航栏配色统一） |        区分版权区与表格区域，视觉分层         |
|   文字居中   |                 `text-align: center;`                  |      版权文字水平居中，符合用户阅读习惯       |
|   文字颜色   |    `color: white;`（或深色，根据背景色调整对比度）     |  确保文字清晰可见（如灰色背景配深灰色文字）   |
|   上下间距   |                   `padding: 10px 0;`                   | 版权区上下留白，避免与表格 “紧贴”，提升美观度 |
| 与表格的间距 |                  `margin-top: 30px;`                   | 给`<footer>`添加顶部外边距，分隔表格与版权区  |

三、页面整体布局（居中与容器控制）

为让页面更专业（避免内容撑满浏览器宽度），视频最后讲解了**页面整体居中布局**，核心思路是 “用容器包裹所有内容 + 控制容器宽度 + 自动居中”：

**实现步骤**

1. **创建外层容器**：用`<div>`标签包裹页面所有内容（顶部导航栏、搜索区、表格、版权区），并给**容器设置唯一 ID（如`id="container"`）**，用于 CSS 定位。

   ```html
   <div id="container">
     <!-- 所有页面内容：导航栏、搜索区、表格、版权区 -->
   </div>
   ```

2. **CSS 控制容器布局**：通过以下属性实现 “固定宽度 + 水平居中”：

   ```css
   #container {
     width: 80%; /* 容器宽度占浏览器宽度的80%（可根据需求调整） */
     margin: 0 auto; /* 上下外边距0，左右自动（实现水平居中） */
   }
   ```

3. **适配调整**：若容器内元素（如搜索框、下拉框）因宽度过大变形，需单独调整元素宽度（如将搜索框宽度从`300px`改为`260px`），确保整体视觉协调。



## **第二章 Javascript**核心语法

### 第一节 引入方式

一、JS 引入的两种核心方式

HTML 中加载 JS 代码的方式分为内部脚本和外部脚本，二者在实现形式、使用场景上存在明确差异，具体如下：

1. 内部脚本

- **定义**：无需额外文件，直接在 HTML 页面内通过`<script>`标签包裹 JS 代码。

- 实操：在 HTML 的`<body>`底部添加`<script>`标签，内部编写 JS 逻辑

  ```html
  <body>
    <!-- 其他HTML内容 -->
    <script>
      // 内部脚本示例：弹出"hellogs"提示框
      alert("hellogs");
    </script>
  </body>
  ```

- **特点**：代码与当前 HTML 页面强关联，无需处理文件路径；但代码无法在多个页面复用，且会增加 HTML 文件体积。

- **适用场景**：页面所需 JS 逻辑简单（仅几行代码），且无需在其他页面复用（如单一页面的简单交互）。

2. 外部脚本

- **定义**：将 JS 代码单独编写在`.js`后缀的外部文件中，再通过 HTML 的`<script>`标签的`src`属性引入该文件。

- 实操步骤

  1. 创建外部 JS 文件（如视频中的`demon.js`），写入 JS 代码：

     ```js
     // demon.js中的外部脚本示例
     alert("Hello JavaScript");
     ```

  2. 在 HTML 中通过`src`指定文件路径引入，示例：

     ```html
     <body>
       <!-- 其他HTML内容 -->
       <!-- 通过src属性引入外部JS文件，路径为"gs/demon.js"（根据实际文件夹结构调整） -->
       <script src="gs/demon.js"></script>
     </body>
     ```

     

- **特点**：JS 代码与 HTML 分离，可在多个 HTML 页面中复用，且便于维护和修改（修改 JS 只需更新外部文件）。

- **适用场景**：JS 逻辑复杂（代码量较大），或需要在多个 HTML 页面中重复使用（如网站公共导航的交互逻辑）。

二、`<script>`标签的位置规范

​	**建议将所有`<script>`标签放在`<body>`元素的底部**，而非`<head>`或 HTML 中间位置，背后有两大关键原因：

1. 避免阻塞 HTML 解析，提升页面加载速度,HTML 解析遵循 “从上到下” 的顺序：

- 若`<script>`放在`<head>`或页面中间，浏览器会优先解析并执行 JS 代码（JS 执行需耗时）；
- 此时下方未解析的 HTML 标签会暂停渲染，导致页面出现 “白屏”，影响用户体验；

2. 避免 JS 操作未渲染的 HTML 元素，导致报错,JS 常需操作 HTML 中的标签（如获取按钮、修改文本内容）：

- 若`<script>`位置靠前，JS 执行时，下方的 HTML 标签尚未被解析渲染，此时操作标签会因 “元素不存在” 而报错；



三、JS 代码书写基础规范

- **行尾分号规则**：JS 引擎会自动通过换行符等识别语句结束，因此行尾分号 “可有可无”；
- **统一原则**：在同一项目中，需保持分号使用的一致性 —— 要么所有语句都添加行尾分号，要么所有语句都不添加，避免混合使用导致逻辑混乱或潜在 bug。



### 第二节 基础语法

#### 2.1 变量和常量

 一、变量声明

JavaScript 作为**弱类型语言**，声明变量时无需指定数据类型，变量可后续存储不同类型的值（如先存数字、再存字符串），核心通过 `let` 关键字声明。

1. 声明语法

```javascript
// 格式：let 变量名 = 初始值（初始值可选，不赋值时默认undefined）
let A = 20; // 声明变量A，初始值为数字20
let B; // 声明变量B，未赋值，默认值为undefined
```

2. 变量名命名规则

与 Java 命名规则一致，需严格遵循：

- 允许使用：字母、数字、下划线（`_`）、美元符号（`$`）
- 禁止规则：数字不能开头；**严格区分大小写**（如 `a` 和 `A` 是两个不同变量）
- 特殊限制：不能使用 JavaScript 关键字（如 `let`、`if`、`for`、`const` 等）



二、常量声明

常量用于存储**不可修改的值**（如圆周率 π），通过 `const` 关键字声明，声明后必须赋值，且后续无法重新赋值（否则报错）。

1. 声明语法

```javascript
// 格式：const 常量名 = 固定值（必须赋值，不能只声明不赋值）
const π = 3.14; // 声明常量π，值为3.14
```

2. 核心特性

- 不可修改：一旦赋值，后续无法通过 “常量名 = 新值” 修改，否则浏览器控制台会报错（如 `π = 5.0` 会触发错误）
- 必须初始化：声明时必须赋值，不能像 `let` 那样 “先声明、后赋值”（如 `const C;` 会直接报错）

三、JavaScript 输出方式

其中前两种为开发中常用方式，用于调试或展示数据：

|   输出方式   |         语法示例          |                 功能说明                 |         使用场景         |
| :----------: | :-----------------------: | :--------------------------------------: | :----------------------: |
|  弹出警告框  |     `alert(变量/值)`      |      弹出浏览器默认提示框，展示内容      |  简单数据展示、快速调试  |
|  控制台输出  |  `console.log(变量/值)`   | 输出内容到浏览器 “控制台”（按 F12 打开） |    开发调试（最常用）    |
| 页面内容写入 | `document.write(变量/值)` |     直接将内容写入浏览器页面主体区域     | 极少使用（影响页面结构） |

```javascript
let name = "Tom";
const age = 18;

alert(name); // 弹出框显示"Tom"
console.log(age); // 控制台输出18
document.write(`姓名：${name}，年龄：${age}`); // 页面显示“姓名：Tom，年龄：18”
```

 四、数据类型

JavaScript 数据类型分为 “基本数据类型” 和 “引用数据类型”（课程暂聚焦基本数据类型），共 5 类，可通过 `typeof` 运算符判断变量 / 值的类型（语法：`typeof 变量/值`）。

1. 五 种基本数据类型

|    类型    |   关键字    |                           取值示例                           | `typeof` 结果 |
| :--------: | :---------: | :----------------------------------------------------------: | :-----------: |
|  数字类型  |  `number`   | 整数（10）、小数（1.5）、负数（-5）、特殊值 `NaN`（Not a Number） |  `"number"`   |
|  布尔类型  |  `boolean`  |            仅两个值：`true`（真）、`false`（假）             |  `"boolean"`  |
| 字符串类型 |  `string`   |            文本内容，用单引号、双引号或反引号包裹            |  `"string"`   |
|   空对象   |   `null`    |               仅一个值：`null`（表示对象为空）               |  `"object"`   |
|   未定义   | `undefined` |           仅一个值：`undefined`（变量声明未赋值）            | `"undefined"` |

2. 关键注意点

- **`NaN` 的特殊性**：`NaN` 属于 `number` 类型，表示 “非数字”，但 `typeof NaN` 结果为 `"number"`（如 `typeof (10 / "abc")` 会返回 `"number"`，因计算结果为 `NaN`）。

- `null` 与 `undefined` 的区别

  - `null`：主动赋值，表示 “对象为空”（如 `let obj = null;`）；
  - `undefined`：**默认值**，表示 “变量声明后未赋值”（如 `let x;`，`x` 的值为 `undefined`）。

- 字符串的**反引号用法**：反引号包裹的字符串称为“模板字符串”，可通过`${变量名}`直接嵌入变量，简化字符串拼接（无需频繁使用`+` 连接），示例：

  ```javascript
  let name = "Tom";
  let age = 18;
  // 模板字符串拼接（推荐）
  let info = `我是${name}，今年${age}岁`; 
  // 等价于传统拼接："我是" + name + "，今年" + age + "岁"
  console.log(info); // 输出“我是Tom，今年18岁”
  ```



#### 2.2 函数

一、函数的本质与作用

- **本质**：函数`function`是封装 “特定任务代码块” 的容器，属于 JS 中的核心语法结构。
- 核心作用
  1. **提高代码复用性**：将重复执行的逻辑封装为函数，避免重复编写代码；
  2. **简化程序结构**：通过函数调用替代复杂代码块，让程序逻辑更清晰；
  3. **类比关联**：与 Java 中的 “方法” 功能类似，但语法更灵活（因 JS 是弱类型语言）。

 二、函数的三种定义方式

JS 中函数定义分为 “具名函数” 和 “匿名函数” 两大类，共三种具体形式，核心区别在于是否有显式函数名、是否需要变量承载。

1. 具名函数（有名称的函数）

- 语法结构：通过`function`关键字声明，显式指定函数名，直接独立定义（无需变量承载）。

  ```javascript
  // 语法：function 函数名(形参列表) { 函数体逻辑; [return 返回值;] }
  
  function add(a, b) { //形参（无需指定类型）
    return a + b; // 返回值（无需指定类型）
  }
  ```

- 特点

  - 函数名是标识符，可直接通过函数名调用；
  - 定义后即可调用，无需额外赋值步骤；
  - 适合定义全局通用、需多次调用的逻辑（如工具函数）。

2. 匿名函数（无名称的函数）

匿名函数无显式函数名，必须通过 “变量承载” 才能调用，分为 “函数表达式” 和 “箭头函数” 两种形式。

![image-20251107212200588](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107212200588.png)

（1）函数表达式

- 语法结构:`function`关键字后不写函数名，将匿名函数整体赋值给变量。

  ```javascript
  // 语法：let 变量名 = function(形参列表) { 函数体逻辑; [return 返回值;] }
  let add = function(a, b) { // 匿名函数赋值给变量 add
    return a + b;
  };
  ```

- 特点：

  - 函数本身无名称，调用时需通过承载它的变量名（如`add(10,20)`）；
  - 可作为 “值” 传递（如作为其他函数的参数）；
  - 变量声明与函数定义绑定，需先定义再调用（否则会因变量提升导致`undefined`）。

（2）箭头函数（ES6 新增，函数表达式的简化版）

- 语法结构：省略`function`关键字，在形参列表后加`=>`（箭头）连接函数体，是匿名函数的 “简写形式”。

  ```javascript
  // 语法：let 变量名 = (形参列表) => { 函数体逻辑; [return 返回值;] }
  let add = (a, b) => { // 省略 function，用 => 连接形参和函数体
    return a + b;
  };
  
  // 简化场景：若函数体只有一句 return，可省略 {} 和 return
  let add = (a, b) => a + b; // 等价于上述完整写法
  ```

- 特点

  - 语法更简洁，是前端开发中最常用的匿名函数形式（如回调函数、Vue/React 组件逻辑）；
  - 无自己的`this`（继承外层作用域的`this`，与普通函数不同）；
  - 调用方式与函数表达式一致（通过变量名调用）。



 三、关键注意事项（因 JS 弱类型导致的灵活性）

- **无需指定类型**：定义函数时，**形参无需声明类型**（如`a`无需写`number a`），**返回值也无需声明类型**（弱类型语言特性）；
- 实参 / 形参数量可不一致
  - 实参多于形参：多余实参被忽略（如`add(10,20,50)`，`50`不生效，结果仍为`30`）；
  - 实参少于形参：未匹配的形参值为`undefined`（如`add(10)`，`b`为`undefined`，结果为`NaN`）；
  - **建议**：开发中尽量保证 “实参数量 = 形参数量”，避免逻辑异常。

#### 2.3 自定义对象

一、JavaScript 自定义对象

JavaScript 自定义对象是对变量、数据类型、函数等基础语法的综合应用，用于封装相关的**属性（数据）** 和**方法（行为）** ，是 JS 中组织数据和逻辑的重要方式。

1. 定义语法

（1）标准方式（完整写法）

通过 `let` 声明对象变量，用**大括号 `{}`** 包裹属性和方法，语法结构如下：

```javascript
let 对象名 = {
  // 属性：属性名: 属性值（多个属性用逗号分隔）
  属性名1: 属性值1,
  属性名2: 属性值2,
  // 方法：方法名: function() { 方法体 }
  方法名1: function() {
    // 方法体（可通过 this 访问当前对象的属性）
    console.log(this.属性名1); // this 代表“当前对象”，类似 Java 中的 this
  },
  方法名2: function() {
    // 方法体逻辑
  }
};
```

（2）简化方式（省略 `:` 和 `function`）

对象方法的声明可省略 `:` 和 `function` 关键字，直接写方法名和括号，语法更简洁：

```javascript
let 对象名 = {
  属性名1: 属性值1,
  属性名2: 属性值2,
  // 简化后的方法写法
  方法名1() {
    console.log(this.属性名1); // 效果与标准方式一致
  },
  方法名2() {
    // 方法体逻辑
  }
};
```

示例：定义 “用户对象”

```javascript
let user = {
  name: "汤姆",  // 字符串属性
  age: 18,      // 数字属性
  gender: "男", // 字符串属性
  // 方法（简化写法）
  sing() {
    alert(this.name + "悠悠的唱着最炫的民族风"); // this.name 访问当前对象的 name 属性
  }
};
```

2. 对象的使用（访问属性 + 调用方法）

通过 **“对象名.属性名”** 访问属性，通过 **“对象名.方法名 ()”** 调用方法：

```javascript
// 1. 访问属性：对象名.属性名
alert(user.name); // 弹出“汤姆”（访问 name 属性）
alert(user.age);  // 弹出 18（访问 age 属性）

// 2. 调用方法：对象名.方法名()
user.sing(); // 弹出“汤姆悠悠的唱着最炫的民族风”（调用 sing 方法）
```

3. 关键注意事项

（1）严禁在对象方法中使用 “箭头函数”：箭头函数中的 `this` **不指向当前对象**，而是指向当前对象的 “上级对象”（如全局对象 `window`），会导致无法正确访问对象属性，示例如下：

```javascript
let user = {
  name: "汤姆",
  // 错误写法：箭头函数导致 this 指向异常
  sing: () => {
    alert(this.name + "唱歌"); // 弹出“undefined唱歌”（this 不指向 user）
  }
};
user.sing(); // 结果错误
```

**结论**：定义对象方法时，必须用 “标准写法” 或 “简化写法”，不能用箭头函数。

（2）属性间的逗号分隔

多个属性 / 方法之间必须用 **逗号 `,`** 分隔；若为最后一个属性 / 方法，逗号可省略（建议保留，便于后续添加新内容）。

二、JSON 格式（JavaScript Object Notation）

![image-20251107213455667](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107213455667.png)

​	JSON 是基于 JS 对象标记法的**文本格式**，本质是 “字符串”，主要用于**前后端数据传输**（如前端向服务器发送请求、服务器向前端返回数据），因语法简单、层次清晰，成为开发中最常用的数据载体。

1. JSON 与 JS 对象 “形似但本质不同”，语法有严格要求

![image-20251107213403641](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107213403641.png)

| 规则                                      | 说明                                                    | 示例                                             |
| ----------------------------------------- | ------------------------------------------------------- | ------------------------------------------------ |
| 1. 关键字（key）必须用**双引号**包裹      | 不可用单引号，不可省略引号                              | `"name": "汤姆"`（正确）；`name: "汤姆"`（错误） |
| 2. 字符串类型的属性值必须用**双引号**包裹 | 数字、布尔值（`true`/`false`）无需加引号                | `"age": 18`（正确）；`"gender": "男"`（正确）    |
| 3. 整体用**大括号 `{}`** 包裹             | 结构与 JS 对象一致，体现 “键值对” 形式                  | `{"name": "汤姆", "age": 18, "gender": "男"}`    |
| 4. 禁止包含方法                           | JSON 仅用于存储数据，不支持方法（与 JS 对象的核心区别） | 不可写 `"sing": function() {}`（错误）           |

2. JSON 与 JS 对象的核心区别

| 对比维度 | JSON                   | JavaScript 对象               |
| -------- | ---------------------- | ----------------------------- |
| 本质     | 文本字符串（数据载体） | 代码中的对象（可操作的实体）  |
| key 要求 | 必须用双引号包裹       | 可加双引号、单引号，也可省略  |
| 支持内容 | 仅支持属性（数据）     | 支持属性和方法（数据 + 行为） |
| 用途     | 前后端数据传输         | 代码内部组织数据和逻辑        |

3. JS 中 JSON 与对象的转换（核心方法）

JS 提供 `JSON` 全局对象，包含两个关键方法，实现 “对象” 与 “JSON 字符串” 的相互转换，满足数据传输需求：

（1）JS 对象 → JSON 字符串：`JSON.stringify(对象)`

将 JS 对象转为 JSON 格式的字符串，用于 “前端向服务器发送数据”（服务器仅接收文本格式）：

```javascript
// 定义 JS 对象
let person = {
  name: "ATCast",
  age: 18,
  gender: "男"
};

// 转换为 JSON 字符串
let personJson = JSON.stringify(person);
alert(personJson); 
// 弹出结果：{"name":"ATCast","age":18,"gender":"男"}（JSON 格式字符串）
```

（2）JSON 字符串 → JS 对象：`JSON.parse(JSON字符串)`

将服务器返回的 JSON 字符串转为 JS 对象，用于 “前端解析服务器数据”（解析后才能访问属性）：

```javascript
// 定义 JSON 格式字符串（key 必须用双引号）
let personJson = '{"name": "黑码", "age": 18}';

// 转换为 JS 对象
let personObj = JSON.parse(personJson);
alert(personObj.name); 
// 弹出“黑码”（解析后可通过“对象.属性名”访问数据）
```





### 第三节 DOM

一、DOM 基础概念

1. **DOM 定义**：DOM（Document Object Model，**文档对象模型**）是 JavaScript 操作网页内容的核心机制，它将 HTML 文档中所有元素（标签、属性、文本、注释等）封装为 JavaScript 对象，通过面向对象的方式对页面元素进行操作。
2. DOM 对象分类：HTML 文档中不同内容对应不同 DOM 对象类型，具体如下：
   - **Document 对象**：封装整个 HTML 文档，是操作 DOM 的入口。
   - **Element 对象**：封装 HTML 标签（如`<html>`、`<body>`、`<h1>`、`<a>`等），每个标签对应一个 Element 对象。
   - **Attribute 对象**：封装 HTML 标签的属性（如`<a>`标签的`href`属性）。
   - **Text 对象**：封装标签中的文本内容（如`<h1>`标签内的文字）。
   - **Comment 对象**：封装 HTML 文档中的注释内容。

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251107214104723.png" alt="image-20251107214104723" style="zoom: 67%;" />

3. **DOM 树结构**：所有 DOM 对象按 HTML 文档的层级关系形成树形结构（即 “DOM 树”），文档（Document）为根节点，根节点下包含`<html>`元素节点，`<html>`下又包含`<head>`和`<body>`子节点，子节点下再嵌套其他元素、文本等节点，类似 “树干 - 树枝 - 树叶” 的层级关系。

二、DOM 的核心作用

通过 DOM 操作，可实现对 HTML 页面的动态控制，核心能力包括：

1. **修改元素内容**：如修改`<h1>`标签的文本、`<p>`标签的段落内容。
2. **修改元素样式**：如调整元素的颜色、字体大小、隐藏 / 显示元素等。
3. **响应元素事件**：如为按钮绑定 “点击” 事件、为输入框绑定 “输入” 事件。
4. **增删页面元素**：如动态添加一个`<div>`标签、删除页面中的`<a>`标签。

三、DOM 操作的核心步骤

- DOM操作核心思想：将网页中所有的元素当做**对象**来处理。（标签的所有属性在该对象上都可以找到）

步骤 1：获取（定位）DOM 元素

通过`Document`对象提供的方法定位需要操作的 DOM 元素，核心方法有两种（现代前端开发主流方式）：

| 语法                                | 功能说明                                                     | 返回结果                                                     |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `document.querySelector(选择器)`    | 根据 CSS 选择器（如 ID 选择器、类选择器、元素选择器）匹配元素，**只返回第一个匹配的元素** | 单个 DOM 元素对象（如 Element 对象）                         |
| `document.querySelectorAll(选择器)` | 根据 CSS 选择器匹配元素，**返回所有匹配的元素**              | NodeList 集合（类数组结构，有长度和索引，无数组自带方法，需通过索引访问单个元素） |

- 选择器规则：与 CSS 选择器一致，如 ID 选择器`#title1`、类选择器`.box`、元素选择器`h1`、后代选择器`body .content`等。
- 示例：
  - 通过 ID 选择器获取元素：`const h1 = document.querySelector('#title1')`（匹配 ID 为`title1`的第一个元素）。
  - 通过元素选择器获取所有元素：`const allH1 = document.querySelectorAll('h1')`（匹配所有`<h1>`标签，返回 NodeList 集合，通过`allH1[0]`访问第一个`<h1>`）。

> 补充：早期 DOM 获取方法（如`getElementById()`、`getElementsByTagName()`）已较少使用，因`querySelector()`/`querySelectorAll()`支持所有 CSS 选择器，灵活性更高，可替代早期方法。

步骤 2：操作 DOM 元素（属性 / 方法）

1. 修改元素内容：通过`innerHTML`属性（设置或获取元素内容，支持 HTML 标签）。
   - 示例：`const h1 = document.querySelector('h1'); h1.innerHTML = '修改后的标题'`（将第一个`<h1>`的文本改为 “修改后的标题”）。
2. **查询元素内容**：直接读取`innerHTML`属性，如`console.log(h1.innerHTML)`（打印`<h1>`标签内的内容）。

> 说明：DOM 元素的属性 / 方法需参考官方文档（如 W3C School、MDN），不同元素（如`<h1>`、`<input>`、`<img>`）有各自特有的属性，也有通用属性（如`innerHTML`、`style`）。



## 第三章 JS事件监听

### 第一节 语法和基本事件

 一、事件与事件监听的基础概念

1. 事件的定义

- 前端中的**事件**：指在 HTML 元素上发生的用户操作或浏览器行为，例如 “点击按钮”“鼠标移入元素”“键盘按键按下” 等。

2. 事件监听的定义

- **事件监听（又称事件绑定、注册事件）**：指 JavaScript 可以 “监听” 某个事件是否触发，一旦触发则立即执行预设的函数（响应逻辑）。
- 核心作用：实现页面交互（如点击按钮弹出提示、鼠标移入改变样式等）。

二、事件监听的三要素

实现事件监听必须明确三个核心要素，缺一不可：

|     要素名称     |                      定义                      |                       如何获取 / 指定                        |
| :--------------: | :--------------------------------------------: | :----------------------------------------------------------: |
|    **事件源**    |        触发事件的 HTML 元素（DOM 对象）        | 通过 `document.querySelector()`（获取单个元素）、`document.querySelectorAll()`（获取多个元素）等 DOM 选择器获取 |
|   **事件类型**   |   触发事件的具体方式（如 “点击”“鼠标移入”）    | 传入特定的事件类型字符串（如 `click` 代表单击、`mouseenter` 代表鼠标移入） |
| **事件处理函数** | 事件触发后要执行的逻辑（如输出日志、修改样式） |      定义匿名函数或命名函数，作为事件监听的 “响应动作”       |

 三、事件监听的语法

（1）语法结构

```javascript
// 1. 获取事件源（DOM 对象）
const btn = document.querySelector('#btn'); 
// 2. 绑定事件监听
btn.addEventListener('事件类型', 事件处理函数);
```

（2）关键特性

- 支持多次绑定同一事件：对同一元素的同一事件（如`click`）绑定多个处理函数，触发时会依次执行，不会覆盖。

  ```javascript
  // 为同一个按钮绑定两个 click 事件
  btn.addEventListener('click', () => console.log('点击响应1'));
  btn.addEventListener('click', () => console.log('点击响应2'));
  // 点击按钮后，控制台会依次输出：点击响应1、点击响应2
  ```
  
- 语法更规范：符合 W3C 标准，兼容性好（支持所有现代浏览器）。



四、实战案例：员工列表鼠标移入 / 移出效果

视频通过 “员工管理列表” 案例，演示事件监听的实际应用，需求如下：

- 鼠标**移入**数据行（`tr` 元素）：背景色变为淡粉色（`#F21212`）。
- 鼠标**移出**数据行：背景色恢复为白色（`#FFF`）。

核心实现步骤

1. **获取事件源**：通过 `document.querySelectorAll('tr')` 获取所有数据行 DOM 元素。
2. **遍历绑定事件**：循环为每个 `tr` 元素绑定 `mouseenter`（鼠标移入）和 `mouseleave`（鼠标移出）事件。
3. **编写处理函数**：在函数中通过 `this.style.backgroundColor` 修改元素样式（`this` 指向当前触发事件的 DOM 元素）。

```javascript
// 1. 获取所有数据行（tr 元素）
const rows = document.querySelectorAll('tr');
// 2. 遍历绑定事件
rows.forEach(row => {
  // 鼠标移入事件
  row.addEventListener('mouseenter', function() {
    this.style.backgroundColor = '#F21212'; // 淡粉色
  });
  // 鼠标移出事件
  row.addEventListener('mouseleave', function() {
    this.style.backgroundColor = '#FFF'; // 白色
  });
});
```

五、JavaScript 常见事件类型（四类核心事件）

|   事件类别   |   常见事件   |               触发时机               |                  应用场景                  |
| :----------: | :----------: | :----------------------------------: | :----------------------------------------: |
| **鼠标事件** |   `click`    |             鼠标单击元素             |             按钮点击、卡片选择             |
|              | `mouseenter` |        鼠标移入元素（不冒泡）        |        元素 hover 提示、背景色变化         |
|              | `mouseleave` |        鼠标移出元素（不冒泡）        |              恢复元素默认样式              |
| **键盘事件** |  `keydown`   |          键盘按键**按下**时          |        快捷键触发（如 Ctrl+S 保存）        |
|              |   `keyup`    |          键盘按键**抬起**时          |     输入内容实时校验（如密码强度检测）     |
| **焦点事件** |   `focus`    | 元素**获得焦点**时（如输入框被点击） |          输入框聚焦时显示提示文字          |
|              |    `blur`    | 元素**失去焦点**时（如点击输入框外） | 输入框失焦时校验内容格式（如手机号合法性） |
| **表单事件** |   `input`    |  表单元素（如输入框）内容**变化时**  |         实时搜索联想、输入字数统计         |
|              |   `submit`   |        表单点击 “提交按钮” 时        |  表单提交前的数据校验（如阻止空表单提交）  |



### 第二节 JS优化

 一、问题背景将 JS 代码直接写在 HTML 文件的`<script>`标签内（即 “内部 JS”），存在两大核心问题：

1. **复用性差**：代码与 HTML 强耦合，无法在其他页面或文件中重复使用；
2. **维护性低**：HTML（页面结构）与 JS（交互逻辑）混在一起，后期修改需在同一文件中查找，效率低。

二、核心优化步骤：JS 代码拆分与模块化

步骤 1：将 HTML 中的 JS 抽取到独立.js 文件

步骤 2：抽取重复逻辑到 “工具类模块”

若独立 JS 文件中存在重复代码（如视频中多次使用的`console.log`日志输出），需进一步拆分到 “工具模块”，提升复用性：

1. 创建工具类文件

   - 在`JS`目录下新建工具文件`utils.js`（命名体现 “工具” 职责）；

   - 定义复用函数（如日志输出），并通过`export`关键字暴露函数（让其他模块可引入）：

     ```javascript
     // utils.js：工具类模块，封装重复逻辑
     export function printLog(message) { 
       console.log(message); // 复用的日志输出逻辑
     }
     ```

2. 在业务模块中引入工具函数

   - 在`eventdemo.js`（业务模块）顶部，通过`import`关键字导入工具函数

     ```javascript
     // eventdemo.js：业务模块，引入工具函数
     import { printLog } from './utils.js'; // 从utils.js导入printLog函数
     ```

   - 替换重复代码：将原`console.log('xxx')`全部改为`printLog('xxx')`，复用工具函数逻辑。

三、关键语法：JS 模块化的 “导入 / 导出” 核心

模块化依赖`import`（导入）和`export`（导出）关键字，二者需配合使用，且有严格规则：

| 关键字   | 作用                                       | 语法示例                               | 注意事项                                                     |
| -------- | ------------------------------------------ | -------------------------------------- | ------------------------------------------------------------ |
| `export` | 暴露模块内的函数、变量等，允许其他模块引入 | `export function 函数名(参数) { ... }` | 必须暴露后，其他模块才能导入；可同时暴露多个（用逗号分隔），如`export { fn1, fn2 }` |
| `import` | 从其他模块导入暴露的内容                   | `import { 函数名 } from '模块路径'`    | 路径需准确（相对路径用`./`/`../`，绝对路径需完整 URL）；导入的名称必须与暴露的名称完全一致 |

四、关键配置

若 JS 文件中使用了`import`/`export`（模块化语法），必须在 HTML 的`<script>`标签中添加`type="module"`属性，否则浏览器会报错：

```html
<!-- 正确写法：添加type="module"，声明模块化JS -->
<script type="module" src="./JS/eventdemo.js"></script>
```

- **原理**：浏览器默认将`<script>`视为 “普通 JS”，`type="module"`会触发浏览器的 “模块化解析逻辑”，支持`import`/`export`语法。

 五、模块化优化的核心价值

1. **职责分离**：HTML（结构）、业务 JS（交互逻辑）、工具 JS（重复逻辑）各司其职，代码结构清晰；
2. **高复用性**：工具模块（如`utils.js`）可在多个业务模块（如`eventdemo1.js`、`eventdemo2.js`）中复用，减少重复代码；
3. **易维护性**：修改逻辑时，只需针对性修改对应模块（如改日志格式仅需改`utils.js`，改事件逻辑仅需改`eventdemo.js`），降低维护成本。



## 第四章 Vue

### 第一节 概念

 一、Vue 基础概念

Vue 定义为 **用于构建用户界面**的**渐进式** JavaScript **框架**

1. 构建用户界面

- **核心逻辑**：将服务器返回的 “原始数据”（如 JSON 格式的`{ "真带": 1, "Job": 2 }`），通过 Vue 渲染为 “用户可看懂的网页”。

![image-20251108122926429](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108122926429.png)

- **本质**：基于数据驱动视图（页面），无需手动操作 DOM（文档对象模型），解决原生 JS 中 “获取 DOM→操作 DOM” 的繁琐流程。

2. 渐进式

- **核心含义**：“循序渐进” 使用 Vue 功能，可根据项目需求灵活选择所需模块，无需一次性引入所有功能，对开发者友好。

- Vue 生态核心组成

  ![image-20251108123404033](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108123404033.png)

  | 功能模块       | 作用                         | Vue 2 / Vue 3 差异                |
  | -------------- | ---------------------------- | --------------------------------- |
  | 核心包         | 声明式渲染（核心）+ 组件系统 | 无差异，均为 Vue 基础功能         |
  | 路由插件       | 实现页面跳转（客户端路由）   | Vue 2 用`VueRouter`               |
  | 状态管理工具   | 管理全局数据                 | Vue 2 用`VueX`，Vue 3 推荐`Pinia` |
  | 工程化构建工具 | 搭建完整 Vue 项目            | Vue 2 用`Webpack`，Vue 3 用`Vite` |

- 全栈开发：结合路由、状态管理、构建工具，开发完整项目。

3. 框架

- **定义**：一套完整的项目解决方案，封装了固定的开发规则和流程，目的是 “提高开发效率”。
- **优势**：简化原生 JS 的 DOM 操作，减少重复代码（如无需手动获取 DOM 元素）。



二、Vue 快速入门：核心开发流程

第一步：Vue 环境准备（3 个子步骤）

1. 引入 Vue 模块（ES 模块化方式）

- 核心代码：通过`<script type="module">`标签引入 Vue 官方 CDN，导入`createApp`函数（用于创建 Vue 实例）。

  ```html
  <!-- 注意：type="module"是ES模块化标识，必须添加 -->
  <script type="module">
    // 从Vue官方CDN引入createApp函数
    import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
  </script>
  ```

2. 创建 Vue 应用实例

- 核心代码：调用`createApp`函数，传入一个配置对象（后续用于定义数据、方法等）。

  ```javascript
  // app即为Vue应用实例
  const app = createApp({
  
  })
  ```

  

3. 指定 Vue 接管的 DOM 区域

- 步骤 1：在 HTML 中定义一个容器（通常用`<div>`），并设置唯一 ID（如`app`）。

  ```html
  <!-- Vue仅能控制此div内部的内容 -->
  <div id="app"></div>
  ```

- 步骤 2：通过`mount`方法绑定容器，让 Vue 接管该区域。

  ```javascript
  // 传入CSS选择器（#app对应id="app"的div）
  app.mount('#app')
  ```

- **关键规则**：Vue 仅能渲染 “接管区域内” 的内容，若将 Vue 语法（如插值表达式）写在`div#app`外，会被当作纯文本显示（无渲染效果）。

第二步：数据驱动视图（2 个子步骤）

1. 定义数据（在 Vue 实例中）

- **核心要求**：数据必须定义在`createApp`配置对象的`data()`方法中，且`data()`需返回一个 “数据对象”。

  ```javascript
  const app = createApp({
    // data是固定方法名，用于定义组件内部数据
    data() {
      // 返回数据对象，key为数据名，value为数据值
      return {
        message: "HelloVue", // 需渲染的数据
        count: 100 // 可新增多个数据
      }
    }
  })
  app.mount('#app')
  ```

2. 渲染数据（使用插值表达式）

- **插值表达式语法**：`{{ 数据名 }}`，用于将 Vue 中定义的数据 “嵌入” HTML 标签中。

- 代码示例：在 Vue 接管的`div#app`内，用`<h1>`标签加粗展示`message

  ```html
  <div id="app">
    <!-- 插值表达式渲染message，h1标签实现加粗效果 -->
    <h1>{{ message }}</h1>
    <!-- 可同时渲染多个数据 -->
    <h1>{{ count }}</h1>
  </div>
  ```

  ![image-20251108130404354](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108130404354.png)

- **效果**：页面最终显示 “加粗的 HelloVue” 和 “100”，数据修改时页面会自动更新（响应式特性）。 三、关键注意点

1. **ES 模块化标识不可漏**：`<script>`标签必须添加`type="module"`，否则无法导入`createApp`函数。
2. **数据定义规则**：数据必须放在`data()`方法的返回值中，直接在配置对象中定义（如`{ message: "HelloVue" }`）无效。
3. **Vue 接管范围**：所有需要 Vue 渲染的内容（如插值表达式、指令），必须放在`mount`绑定的容器（如`div#app`）内部。



### 第二节 常用指令

一、Vue 指令基础概念

1. **定义**：Vue 中的指令是**作用在 HTML 标签上**、带有 `v-` 前缀的特殊属性，用于增强页面渲染功能，实现动态数据展示、条件控制、事件绑定等效果。

2. 常用指令概览

   |            指令             |                           核心作用                           |
   | :-------------------------: | :----------------------------------------------------------: |
   |           `v-for`           |          列表渲染，遍历数组或对象，动态生成重复标签          |
   |          `v-bind`           |      动态绑定 HTML 标签属性（如 `src`、`href`、样式等）      |
   | `v-if`/`v-else-if`/`v-else` |       条件渲染，根据条件决定标签是否**渲染到 DOM 中**        |
   |          `v-show`           | 条件展示，根据条件通过 `display` CSS 属性控制标签是否**显示（DOM 已存在）** |
   |          `v-model`          | 双向数据绑定，仅用于表单元素（如输入框、下拉框），同步数据与视图 |
   |           `v-on`            |      事件绑定，为标签绑定点击、输入等事件（简写为 `@`）      |

二、v-for

1. 作用：实现**列表渲染**，**遍历数组（或对象）**中的元素，动态生成对应数量的 HTML 标签（如表格行、列表项等），避免手动编写重复代码。

2. 基本语法

（1）遍历数组

```html
<!-- 完整语法：获取“元素”和“索引” -->
<标签 v-for="(item, index) in 数组名" :key="唯一标识">
  <!-- 可通过 {{ item.属性名 }} 使用遍历的元素 -->
</标签>

<!-- 简化语法：仅获取“元素”（索引可选） -->
<标签 v-for="item in 数组名" :key="唯一标识">
</标签>
```

- 参数说明
  - `item`：遍历出的 “当前元素”（变量名可自定义，如 `emp`、`user`）；
  - `index`：遍历的 “索引 / 下标”（从 0 开始，可选，需时再写）；
  - `数组名`：Vue 实例中 `data` 里定义的数组（如 `empList`）；
  - `:key`：为每个遍历生成的标签添加**唯一标识**。

 （2）遍历对象（扩展）

```html
<!-- 遍历对象的“值、键、索引” -->
<标签 v-for="(value, key, index) in 对象名" :key="key">
  {{ index }} - {{ key }}: {{ value }}
</标签>
```

3. 关键属性：:key 的作用与规范

（1）核心作用：给遍历生成的每个标签分配唯一标识，帮助 Vue 识别标签的 “身份”；

（2）推荐用 “数据的唯一 ID” 作为 key**（如后端返回的 `id`，如 `item.id`）；

4. 注意事项

- 指令挂载位置：想让哪个标签 “重复生成”，就把 v-for 加在哪个标签上
  - 例：渲染表格行（`<tr>`）时，v-for 加在 `<tr>` 上，而非 `<tbody>` 或 `<td>`；

- 遍历的数组 / 对象必须在 Vue 实例的`data`中定义（确保 Vue 能监听数据变化，实现响应式）；

  ```javascript
  new Vue({
    el: "#app",
    data: {
      // 需遍历的数组（定义在 data 中）
      empList: [
        { id: 1, name: "张三", job: "班主任" },
        { id: 2, name: "李四", job: "讲师" }
      ]
    }
  });
  ```

- 插值表达式支持简单逻辑：如三元运算符（`{{ emp.gender === 1 ? '男' : '女' }}`）、算术运算（`{{ index + 1 }}` 将索引从 1 开始显示）。



三、v-bind 指令：动态绑定标签属性

1. 作用：解决 “标签属性无法直接使用插值表达式赋值” 的问题，**动态为 HTML 标签的属性绑定值**（如`src`、`href`、`style`、`alt`等）。

2. 语法规则

|          写法示例          |                            说明                             |
| :------------------------: | :---------------------------------------------------------: |
| `v-bind:属性名="绑定的值"` |              标准写法，明确指定 “v-bind” 指令               |
|    `:属性名="绑定的值"`    | Vue 支持的简写形式，省略 “v-bind”，仅保留冒号，开发中更常用 |

```html
<!-- 错误：插值表达式不能用于标签属性 -->
<img src="{{ emp.imgUrl }}" alt="{{ emp.name }}"> 

<!-- 正确：使用v-bind简化语法 -->
<img :src="emp.imgUrl" :alt="emp.name"> 
```

3. 关键注意事项

- **绑定值的来源**：绑定的值必须是 Vue 实例`data`中定义的数据，或基于`data`数据演变的结果（如遍历`v-for`得到的当前元素`emp`）。
- **与插值表达式的区别**：插值表达式（`{{ }}`）仅用于标签**内容区域**（如`<div>{{ name }}</div>`），不能用于标签**属性**；属性动态赋值必须用`v-bind`。



四、v-if 与 v-show 指令：条件控制元素显示 / 隐藏

1. 共同作用

两者均用于**根据条件判断元素是否显示**，条件为`true`时元素显示，条件为`false`时元素隐藏，语法均为 “指令名 ="条件表达式"”。

```html
<!-- v-if：条件成立则渲染元素 -->
<div v-if="isShow"> 我通过v-if控制显示 </div>

<!-- v-show：条件成立则显示元素 -->
<div v-show="isShow"> 我通过v-show控制显示 </div>
```

2. 区别

`v-if`和`v-show`的核心差异在于**元素是否被渲染到 DOM**，直接决定了适用场景

|   对比   |                             v-if                             |                            v-show                            |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   原理   | 条件控制 “元素是否渲染”：<br>`true`：创建元素并插入 DOM<br>`false`：不渲染元素（DOM 中无此元素） | 条件控制 “元素样式”：<br>无论条件真假，元素都会渲染到 DOM<br>`true`：元素样式`display: block`（显示）<br>`false`：元素样式`display: none`（隐藏） |
|   性能   |          切换时涉及 “DOM 创建 / 删除”，性能消耗较高          |             切换时仅修改 CSS 样式，性能消耗较低              |
| 适用场景 | 元素**不频繁切换**显示 / 隐藏的场景（如页面初始化时的条件渲染、用户角色权限控制的模块显示） | 元素**频繁切换**显示 / 隐藏的场景（如鼠标 hover 显示的下拉菜单、tab 页切换的内容区） |

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108140022659.png" alt="image-20251108140022659"  />

- v-show不论是否展示都要全部渲染，只是display值为none



五、v-model 指令：表单双向数据绑定

1. 核心作用：实现**表单元素与数据模型的双向绑定**，即：

- 数据模型变化 → 视图（页面表单）自动更新

- 视图（表单输入）变化 → 数据模型自动同步

  无需手动操作 DOM，即可便捷采集 / 设置表单数据（如输入框、下拉框、复选框等）。

  ![image-20251108141423155](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108141423155.png)

2. 关键语法

（1）定义数据模型

在 Vue 实例的 `data` 中声明用于绑定表单的变量（需预先定义，否则报错），推荐用对象封装多表单项数据（如查询条件）：

```javascript
new Vue({
  el: '#app',
  data() {
    return {
      // 封装用户输入的查询条件（姓名、性别、职位）
      searchForm: {
        name: '',    // 姓名（初始值为空串）
        gender: '',  // 性别（初始值为空串）
        job: ''      // 职位（初始值为空串）
      }
    }
  }
})
```

（2）绑定表单元素

在 HTML 表单标签上通过 `v-model="数据模型"` 关联，不同表单类型用法一致：

|   表单元素类型   |                           示例代码                           |                            说明                            |
| :--------------: | :----------------------------------------------------------: | :--------------------------------------------------------: |
| 输入框（input）  |       `<input type="text" v-model="searchForm.name">`        |  绑定 “姓名” 输入框，输入内容实时同步到 `searchForm.name`  |
| 下拉框（select） | `<select v-model="searchForm.gender"><option value="1">男</option><option value="2">女</option></select>` | 选择 “性别” 后，`searchForm.gender` 自动同步选中的 `value` |
| 单选框（radio）  | `<input type="radio" name="gender" value="1" v-model="searchForm.gender">` |               选中后同步 `value` 到数据模型                |



六、v-on 指令：事件绑定

1. 作用：为 HTML 元素绑定事件（如点击、输入、鼠标事件等），实现 “用户操作 → 执行函数” 的交互逻辑（如查询按钮点击、清空按钮点击）。

![image-20251108143519975](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108143519975.png)

2. 关键语法

（1）基础语法与简写

| 格式                   | 说明                                                       | 示例（绑定 “点击事件”）                     |
| ---------------------- | ---------------------------------------------------------- | ------------------------------------------- |
| `v-on:事件名="函数名"` | 显式声明 `v-on`，事件名如 `click`（点击）、`input`（输入） | `<button v-on:click="search">查询</button>` |
| `@事件名="函数名"`     | 用 `@` 代替 `v-on:`，更简洁（推荐日常使用）                | `<button @click="clear">清空</button>`      |

（2）定义事件处理函数

在 Vue 实例的 `methods` 中声明事件对应的函数，函数内通过 `this` 访问 `data` 中的数据模型：

```javascript
new Vue({
  el: '#app',
  data() { /* 数据模型省略 */ },
  methods: { //与data数据模型省略
    // 1. 点击“查询”：输出查询条件到控制台
    search() {
      console.log('用户查询条件：', this.searchForm); // this 指向当前 Vue 实例，访问 searchForm
    },
    // 2. 点击“清空”：重置表单数据（利用双向绑定，数据清空后页面自动同步）
    clear() {
      this.searchForm = {
        name: '',
        gender: '',
        job: ''
      };
    }
  }
})
```

3. 常见使用场景

- **按钮点击**：如查询、清空、提交等（案例核心场景）；
- **表单事件**：如 `@input`（实时监听输入）、`@submit`（表单提交，需阻止默认行为时用 `@submit.prevent`）；
- **键盘事件**：如 `@keyup.enter`（按回车键触发），适合 “输入后按回车查询” 的场景。





## 第五章 Ajax

### 第一节 概念

 一、AJAX 基础概念

1. **定义**：AJAX 是 **Asynchronous JavaScript and XML** 的缩写，中文译为 “异步 JavaScript 和 XML”。

   - **XML（Extensible Markup Language，可扩展标记语言）**，是一种用于存储复杂数据结构的数据格式，本质是 “由标签构成的标记语言”（与 HTML 同属标记语言范畴）。

2. **核心作用**

   - **数据交换**：前端可通过 AJAX 向服务器发起请求，获取服务器响应的数据（解决 “页面数据写死” 问题，对应项目开发中 “动态获取服务器数据” 的需求）。
   - **异步交互**：在**不重新加载整个页面**的前提下，与服务器进行数据交换并更新页面部分内容（区别于 “同步交互” 的 “页面整体刷新 + 等待服务器响应” 模式）。

   ![image-20251108144344585](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108144344585.png)

3. **异步 vs 同步交互对比**

   | 对比维度   | 同步交互                           | 异步交互（AJAX）                       |
   | ---------- | ---------------------------------- | -------------------------------------- |
   | 页面刷新   | 整个页面重新加载                   | 仅更新页面部分内容，无整体刷新         |
   | 客户端状态 | 等待服务器响应期间，客户端无法操作 | 发起请求后可继续执行其他操作，无需等待 |
   | 典型场景   | 传统表单提交、浏览器地址栏直接访问 | 百度搜索联想、注册账号实时查重         |

二、AJAX 实现工具：Axios

- 作用：对原生 AJAX 进行封装，解决原生 AJAX 的 “浏览器兼容性差、代码繁琐” 问题，简化 AJAX 请求编写。

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```



三、Axios 发起 AJAX 请求的两种方式

方式 1：基础配置式（完整参数对象）

- 语法结构：通过 `axios()` 函数传入配置对象，指定请求方式、URL、参数等。

- 核心配置项：

  |  配置项  |                  作用说明                   |                 示例                 |
  | :------: | :-----------------------------------------: | :----------------------------------: |
  | `method` | 指定请求方式（大小写均可，如 `get`/`post`） |           `method: 'GET'`            |
  |  `url`   |         服务器接口地址（请求路径）          | `url: 'https://xxx.com/api/getData'` |
  | `params` |     GET 请求的参数（自动拼接在 URL 后）     |  `params: { id: 1, name: 'test' }`   |
  |  `data`  |     POST 请求的参数（放在请求体中传递）     |    `data: { username: 'admin' }`     |

  ![image-20251108144814540](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108144814540.png)

- 回调机制：

  - `then()`：请求成功后的回调函数，参数 `result` 为服务器响应结果（`result.data` 才是实际响应数据，需注意层级）。
  - `catch()`：请求失败后的回调函数（如网络错误、接口不存在）。

- 代码示例：

  ```javascript
  // 发起 GET 请求
  axios({
    url: 'https://mock.apfox.cn/ml/3083103-0-defaults/list',
    method: 'GET',
    params: { id: 1 } // GET 参数
  }).then(result => {
    console.log('成功响应数据：', result.data); // 取实际数据需加 .data
  }).catch(error => {
    console.log('请求失败：', error);
  });
  
  // 发起 POST 请求
  axios({
      url:'https://mock.api.fox.cn/m1/3083103-0-defaults/update',
    method: 'POST',
    data: { username: 'admin' } // POST 参数（即请求体的数据）
  }).then(result => {
    console.log('成功响应数据：', result.data);
  }).catch(error => {
    console.log('请求失败：', error);
  });
  ```

- **响应数据层级**：Axios 响应结果 `result` 包含请求状态、响应头、数据等信息，**实际业务数据需通过 `result.data` 获取**

方式 2：请求方式别名

- 语法结构：Axios 为每种请求方式提供 “别名方法”，直接调用 `axios.请求方式()`，简化代码。

- 核心别名方法：

  - `axios.get(url, [config])`：发起 GET 请求，参数可直接拼接在 URL 后，或通过 `config.params` 指定。
  - `axios.post(url, [data], [config])`：发起 POST 请求，`data` 为请求体参数，`config` 为可选配置。

  ![image-20251108151059284](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251108151059284.png)

  

### **第二节 案例**

## 一、核心需求与接口基础

### 1. 需求背景

- 初始员工列表数据为页面“写死”的静态数据，需改造为：**点击“查询”按钮时，根据用户输入的3个查询条件（姓名`name`、性别`gender`、职位`job`），动态请求服务器数据并渲染到页面**。
- 清空查询条件后，需自动重新查询全量数据，提升用户体验。

### 2. 接口信息

- 提供的员工列表查询URL：视频中通过课程资料给出（实际开发中需从后端文档获取）。

- 请求方式：`GET`（通过URL拼接查询参数）。

- 支持的查询参数：

  |  参数名  |                    说明                    |                 示例                  |
  | :------: | :----------------------------------------: | :-----------------------------------: |
  |  `name`  |                姓名模糊查询                | `name=一笑`（查询姓名含“一笑”的员工） |
  | `gender` |      性别筛选（1=男，2=女，空=全选）       |      `gender=1`（查询男性员工）       |
  |  `job`   | 职位筛选（3=学工主管，其他值对应不同职位） |        `job=3`（查询学工主管）        |

- 响应数据格式：JSON结构，包含状态码

  ```
  code
  ```

  （1=成功）、提示信息

  ```
  message
  ```

  、核心数据

  ```
  data
  ```

  （员工列表数组），示例：

  ```json
  {
    "code": 1,
    "message": "success",
    "data": [{"id": 1, "name": "谢逊", "gender": 1, "job": "班主任"}, ...]
  }
  ```

  

## 二、Ajax异步请求实现（基于Axios）

视频中使用**Axios库**发起Ajax请求（需先在HTML中通过`<script>`标签引入Axios文件），核心实现步骤如下：

### 1. 基础请求逻辑（回调函数方式）

- 绑定“查询”按钮的点击事件到

  ```
  search()
  ```

  方法，在方法中完成3件事：

  1. **获取查询条件**：通过Vue的`v-model`将表单输入绑定到`searchForm`对象（如`this.searchForm.name`）；

  2. 拼接请求URL

     ：使用模板字符串（反引号

     ```
     `
     ```

     ）拼接基础URL与查询参数，示例：

     ```javascript
     const url = `员工列表接口URL?name=${this.searchForm.name}&gender=${this.searchForm.gender}&job=${this.searchForm.job}`;
     ```

     

  3. 发起Axios请求

     ：调用

     ```
     axios.get()
     ```

     ，通过成功回调处理响应数据，将

     ```
     result.data
     ```

     （接口返回的员工列表）赋值给Vue实例的

     ```
     empList
     ```

     （页面通过

     ```
     v-for
     ```

     循环

     ```
     empList
     ```

     渲染表格）：

     ```javascript
     search() {
       const url = `接口URL?name=${this.searchForm.name}&gender=${this.searchForm.gender}&job=${this.searchForm.job}`;
       axios.get(url)
         .then(result => {
           // 成功回调：将服务器返回的员工数据赋值给empList，页面自动渲染
           this.empList = result.data.data; 
         })
         .catch(error => {
           // 失败回调（可选）：处理请求错误，如弹窗提示
           console.error("请求失败", error);
         });
     }
     ```

     

### 2. 清空功能优化

- 清空方法

  ```
  clear()
  ```

  中，除了重置

  ```
  searchForm
  ```

  对象的属性值（如

  ```
  this.searchForm.name = ""
  ```

  ），还需

  主动调用`search()`方法

  ，实现“清空后自动查全量数据”：

  ```javascript
  clear() {
    this.searchForm = { name: "", gender: "", job: "" }; // 重置表单
    this.search(); // 调用查询方法，加载全量数据
  }
  ```

  

## 三、异步请求优化：async/await语法

### 1. 问题背景

传统`then/catch`回调方式在复杂逻辑中易出现“回调嵌套”，导致代码可读性差、维护成本高。`async/await`是ES6+提供的**异步语法糖**，可将“异步请求”转化为“同步代码风格”。

### 2. 核心用法

- **`async`关键字**：修饰函数（如`search()`方法），声明该函数为异步函数，函数返回值自动包装为Promise对象。

- **`await`关键字**：只能在`async`函数内部使用，用于“等待”Promise对象完成（即等待Ajax请求响应），避免回调嵌套。

- 优化后的

  ```
  search()
  ```

  方法：

  ```javascript
  // 1. 用async修饰方法，声明为异步函数
  async search() {
    const url = `接口URL?name=${this.searchForm.name}&gender=${this.searchForm.gender}&job=${this.searchForm.job}`;
    // 2. 用await等待Axios请求完成，直接获取响应结果
    const result = await axios.get(url);
    // 3. 响应后直接处理数据，代码自上而下执行，无回调嵌套
    this.empList = result.data.data;
  }
  ```

### 3. 关键注意点

- `await`必须配合`async`使用，单独使用会报错；

- 若需处理请求失败，可搭配

  ```
  try/catch
  ```

  捕获异常（视频中虽未提及，但实际开发必备）：

  ```javascript
  async search() {
    try {
      const url = `接口URL?参数`;
      const result = await axios.get(url);
      this.empList = result.data.data;
    } catch (error) {
      alert("查询失败，请重试！");
      console.error(error);
    }
  }
  ```

  

## 四、Vue生命周期：mounted钩子的应用

### 1. 问题背景

页面初始加载时，`empList`为空，需用户手动点击“查询”才加载数据，体验不佳。需实现**页面加载完成后自动发起请求，加载全量员工数据**。

### 2. Vue生命周期核心概念

- 生命周期：Vue实例从“创建”到“销毁”的全过程，每个阶段会触发对应的“钩子方法”（无需手动调用，Vue自动执行）。
- 核心钩子方法：`mounted`（视频重点）——**Vue实例创建完成且挂载到DOM后触发**（即页面加载完毕），适合在此发起初始化数据请求。

### 3. 实现页面初始化加载数据

- 在Vue实例中，与`data` `method`平级声明`mounted`钩子，内部调用`search()`方法：

  ```javascript
  new Vue({
    el: "#app",
    data: {
      empList: [], // 员工列表数据
      searchForm: { name: "", gender: "", job: "" } // 查询条件
    },
    methods: {
      async search() { /* ... */ },
      clear() { /* ... */ }
    },
    // mounted钩子：页面加载完毕后自动执行
    mounted() {
      this.search(); // 调用查询方法，初始化加载全量数据
    }
  });
  ```

- 效果：页面刷新后，无需点击“查询”，自动请求服务器并展示全量员工数据。

## 五、核心总结

1. **动态数据交互流程**：表单输入→绑定查询条件→Axios发起GET请求→处理响应数据→渲染页面；
2. **异步优化关键**：`async/await`替代`then/catch`，提升代码可读性；
3. **Vue生命周期应用**：`mounted`钩子用于页面初始化数据加载，是前端开发高频用法；
4. **用户体验细节**：清空条件后自动重新查询，减少用户操作步骤。



## 第六章 tomcat

一、Web 服务器核心作用

1. **协议封装**：Web 服务器是封装 HTTP 协议操作的软件程序，开发者无需直接编写 HTTP 协议相关代码，降低 Web 应用开发难度，提升开发效率。
2. **应用部署与访问**：在服务器安装 Web 服务器后，可将开发好的 Web 应用部署其中，启动服务器后，通过浏览器即可访问部署的应用；若知晓服务器 IP 地址，其他设备也能远程访问该应用。

二、主流 Web 服务器对比

| 服务器名称 | 特点                                                      | 适用场景                                   |
| ---------- | --------------------------------------------------------- | ------------------------------------------ |
| Tomcat     | 开源免费、轻量级，仅支持 Servlet、JSP 等少量 Java EE 规范 | 中小型 Java Web 项目、企业级开发主流选择   |
| WebLogic   | 重量级，支持全部 Java EE 规范，商用收费                   | 大型企业级复杂应用（如金融、电信核心系统） |
| WebSphere  | 重量级，支持全部 Java EE 规范，商用收费                   | 大型企业级复杂应用，与 IBM 生态兼容性强    |

三、Tomcat 部署 Web 应用演示

1. **部署步骤**：将 Web 应用文件夹（如`demo`）复制到 Tomcat 安装目录下的`webapps`文件夹中。
2. 访问配置
   - Tomcat 默认端口为 8080，本地访问基础路径为`localhost:8080`（访问 Tomcat 首页）。
   - 访问部署的应用需追加应用名和资源路径，例如访问`demo`应用下的`index.html`，完整路径为`localhost:8080/demo/index.html`。

四、Tomcat 核心目录结构

| 目录名称  |     核心功能     |                         关键作用场景                         |
| :-------: | :--------------: | :----------------------------------------------------------: |
|   `bin`   |  存放可执行文件  | 启动（`startup.bat`）、停止（`shutdown.bat`）Tomcat 的脚本文件在此目录 |
|  `conf`   |   存放配置文件   | 核心配置文件（如端口配置 `server.xml`、日志编码 `logging.properties`）在此目录 |
|   `lib`   | 存放依赖 Jar 包  | Tomcat 基于 Java 开发，运行所需的 Java 类库（Jar 包）集中在此 |
|  `logs`   |   存放日志文件   | Tomcat 启动、运行、报错等日志（如控制台输出日志）均保存在此，便于问题排查 |
|  `temp`   |   存放临时文件   |      Tomcat 运行过程中生成的临时缓存文件，无需手动操作       |
| `webapps` | 应用程序发布目录 | 开发好的 Web 应用（如 Demo 项目）需放在此目录，才能通过 Tomcat 访问 |
|  `work`   | Tomcat 工作目录  |  用于存放 Tomcat 对 JSP 等文件的编译结果，属于内部工作目录   |



## 第七章 请求响应

### 第一节 概述

一、前置知识回顾

1. **Spring Boot Web 入门基础**
   - 入门程序中，启动类启动内嵌 Tomcat 服务器后，浏览器通过 URL 访问部署的应用，Controller 接收请求、处理后返回响应结果。
   - 浏览器与服务器的数据传输基于**HTTP 协议**（规定数据传输规则），Web 服务器（如 Tomcat）负责解析 HTTP 协议。
2. **Tomcat 的核心能力**
   - Tomcat 是 “Servlet 容器”，仅能识别实现了**Servlet 规范（Servlet 接口）** 的 Java 程序，无法直接识别开发者自定义的 Controller 类。

二、核心组件：DispatcherServlet（前端控制器）

![image-20251116143942625](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251116143942625.png)

1. 作用与定位

- Spring Boot 底层提供的核心 Servlet 程序，是连接浏览器请求与 Controller 的 “中间桥梁”，也称为**前端控制器 / 核心控制器**。
- 关键特性：实现了 Servlet 接口，可被 Tomcat 直接识别并运行。

2. 请求处理流程（核心流程）

1. 浏览器发起 HTTP 请求，首先进入**DispatcherServlet**；
2. DispatcherServlet 将请求 “分发” 给对应的 Controller 类；
3. Controller 处理请求逻辑；
4. Controller 将处理结果返回给 DispatcherServlet；
5. DispatcherServlet 将结果封装为 HTTP 响应，返回给浏览器。

三、请求与响应的核心对象

Tomcat 解析 HTTP 协议后，通过两个核心对象封装请求 / 响应数据，供开发者使用：

| 对象名称              | 作用                                             | 核心操作                                      |
| --------------------- | ------------------------------------------------ | --------------------------------------------- |
| `HttpServletRequest`  | 封装**所有请求数据**（浏览器发送给服务器的数据） | 从对象中获取请求参数（如表单数据、URL 参数）  |
| `HttpServletResponse` | 封装**所有响应数据**（服务器发送给浏览器的数据） | 向对象中设置响应内容（如 JSON、页面跳转指令） |

四、Web 架构模式：BS 架构与 CS 架构

1. BS 架构（Browser/Server，浏览器 - 服务器架构）

- **定义**：客户端仅需浏览器，所有业务逻辑、数据均存储在服务器端。
- **典型案例**：京东、淘宝、12306、政府官网等（浏览器可直接访问）。
- 优缺点
  - 优点：无需安装客户端，维护成本低（仅需维护服务器）；
  - 缺点：依赖网络带宽与服务器性能，加载速度受外界影响。
- **JavaWeb 定位**：后续开发的 Web 应用均基于 BS 架构。

2. CS 架构（Client/Server，客户端 - 服务器架构）

- **定义**：需在客户端安装独立软件（如 PC 端 QQ、微信、百度网盘），客户端与服务器交互。
- **典型案例**：QQ、微信、Pliers（视频工具）、本地游戏客户端。
- 优缺点
  - 优点：客户端可缓存数据，体验流畅（如本地缓存视频）；
  - 缺点：需开发多端客户端（Windows/Mac/iOS 等），开发与维护成本高。



### 第二节 请求

#### 2.1 Postman

一、工具引入背景：为什么需要 Postman？

源于**前后端分离开发模式**的特性：

- 开发分工：前端开发前端工程，后端开发后端接口，双方仅通过 “接口文档” 协作，无实时联调的前端页面。
- 浏览器局限性：浏览器地址栏仅能发起`GET`请求，无法直接测试`POST`、`PUT`等其他请求方式，若手动编写前端代码测试则流程繁琐。
- Postman 的价值：解决上述痛点，可模拟浏览器发起**任意类型的 HTTP 请求**，且能灵活携带参数、请求头，是后端工程师接口测试的首选工具。

二、Postman 工具核心介绍

1. 工具定位:原本是 Chrome 浏览器插件，现发展为独立应用，功能是 “网页调试与 HTTP 请求发送”，核心用途是接口测试

2. 核心能力

   - 支持所有 HTTP 请求方法（GET、POST、PUT、DELETE 等）；
   - 可便捷配置请求参数、请求头、请求体等信息；
   - 自动展示响应结果（如字符串、JSON、HTML 等）；
   - 支持请求数据的保存与云端同步。

3. 同类衍生工具

   如 ApiPost、ApiFox 等，使用逻辑与 Postman 基本一致，可按需选择。



#### 2.2 简单参数

简单参数指请求中传递的普通数据（如姓名、年龄、ID 等），支持 GET/POST 两种请求方式，核心是 “参数名匹配” 与 “类型自动转换”。

1. 原始 Web 开发方式:基于`HttpServletRequest`对象手动获取参数，需手动处理**参数提取**和**类型转换**，步骤繁琐，仅作原理了解。

- **核心 API**：`request.getParameter("参数名")`，返回值为`String`类型（需手动转 int/long 等）。

  ```java
  @RequestMapping("/simpleParam")
  public String simpleParam(HttpServletRequest request) {
      // 1. 手动获取参数（String类型）
      String name = request.getParameter("name");
      String ageStr = request.getParameter("age");
      // 2. 手动类型转换（String → int）
      int age = Integer.parseInt(ageStr);
      // 3. 业务处理
      System.out.println("name: " + name + ", age: " + age);
      return "ok";
  }
  ```

- **缺点**：参数多时代码冗余，且需处理类型转换异常（如非数字字符串转 int）。

2. Spring Boot 简化方式:Spring Boot 自动完成 “参数匹配” 和 “类型转换”，无需手动操作，仅需满足 **“请求参数名 = Controller 方法形参名”**。

- 核心规则

  - GET 请求：参数拼接在 URL 后（如`http://localhost:8080/simpleParam?name=Tom&age=10`），Spring Boot 自动解析 URL 参数。
  - POST 请求：参数放在请求体（Form 表单格式），Spring Boot 自动读取请求体参数。

  ```java
  @RequestMapping("/simpleParam")
  public String simpleParam(String name, int age) { 
      // 无需手动获取/转换：形参名与请求参数名一致（name/age），Spring Boot自动处理
      System.out.println("name: " + name + ", age: " + age);
      return "ok";
  }
  ```

- **优势**：代码简洁，支持自动类型转换（如 String→int、String→long 等）。

3. 参数名不匹配：@RequestParam 注解（重点）

当 “请求参数名” 与 “Controller 形参名” 不一致时，使用`@RequestParam`注解手动建立映射关系。

- 核心属性

  |    属性名    |                      作用                       | 默认值 |
  | :----------: | :---------------------------------------------: | :----: |
  | `name/value` |        指定请求参数名（必填，建立映射）         |   -    |
  |  `required`  | 该参数是否必须传递（true = 必须，false = 可选） | `true` |

  ```java
  // 请求参数名是"username"，形参名是"name"，用@RequestParam映射
  @RequestMapping("/simpleParam")
  public String simpleParam(
          @RequestParam(name = "username") String name,  // 强制映射
          @RequestParam(required = false) Integer age) { // age可选（不传递则为null）
      System.out.println("name: " + name + ", age: " + age);
      return "ok";
  }
  ```

- 注意事项

  - 若`required=true`（默认）但未传递参数，会返回 400 错误（客户端参数错误）。
  - 可选参数（`required=false`）的形参类型需用**包装类**（如 Integer，避免 null 赋值给基本类型 int 报错）。

#### 2.3 实体参数

当请求参数较多（如用户信息：姓名、年龄、手机号、地址等）时，将参数封装到**实体类对象**中，简化代码并便于维护，核心是 “属性名匹配”。

1. 简单实体参数（单层级实体）：实体类的**属性名**与**请求参数名**完全一致，Spring Boot 自动将参数封装到实体对象中。

- 步骤 1：定义实体类（需生成`getter/setter`方法)

  ```java
  public class User {
      private String name; // 与请求参数名"name"一致
      private Integer age; // 与请求参数名"age"一致
      
      // 生成getter/setter
      public String getName() { return name; }
      public void setName(String name) { this.name = name; }
      public Integer getAge() { return age; }
      public void setAge(Integer age) { this.age = age; }
  }
  ```

- 步骤 2：Controller 方法接收实体对象

  ```java
  @RequestMapping("/simplePojo")
  public String simplePojo(User user) { 
      // Spring Boot自动将请求参数封装到User对象（调用setter方法赋值）
      System.out.println("user: " + user.getName() + ", " + user.getAge());
      return "ok";
  }
  ```

- 请求示例

  - GET：`http://localhost:8080/simplePojo?name=Tom&age=16`
  - POST：Form 表单传递`name=Tom`和`age=16`

2. 复杂实体参数（多层级实体）

实体类中包含**另一个实体类属性**（如 User 包含 Address 属性，Address 有 province、city 属性），需按 “层级结构” 传递参数。

- 步骤 1：定义多层级实体类

  ```java
  // 地址实体（子实体）
  public class Address {
      private String province; // 省份
      private String city;     // 城市
      // getter/setter
  }
  
  // 用户实体（父实体，包含Address属性）
  public class User {
      private String name;
      private Integer age;
      private Address address; // 多层级属性
      // getter/setter
  }
  ```

- 步骤 2：按层级传递请求参数,参数名格式为`“父实体属性名.子实体属性名”`，如`address.province`  `address.city`

  - GET 请求：`http://localhost:8080/complexPojo?name=Tom&age=16&address.province=北京&address.city=北京`
  - POST 请求：Form 表单传递上述参数。

- 步骤 3：Controller 接收复杂实体

  ```java
  @RequestMapping("/complexPojo")
  public String complexPojo(User user) {
      // 自动封装多层级参数：user.getAddress().getProvince()
      System.out.println("name: " + user.getName() + 
                         ", province: " + user.getAddress().getProvince());
      return "ok";
  }
  ```



#### 2.4 数组集合参数

一、前置基础：使用场景与前端参数传递规则

1. 使用场景

当前端需要传递**多个同名称的参数**时（最典型场景：HTML 表单中的`checkbox`复选框，如 “爱好选择”“活动性质多选”），需通过特定格式将多值提交到后端，后端再通过数组 / 集合接收。

2. 前端参数传递格式

无论是 GET 还是 POST 请求，多值参数需以 **“同名参数重复传递”** 的形式提交，格式如下：

- 示例：传递 “爱好（hobby）” 的 3 个值（game、java、sing）
  - GET 请求 URL：`http://localhost:8080/xxx?hobby=game&hobby=java&hobby=sing`
  - POST 请求表单 / Body：参数名均为`hobby`，值分别为`game`、`java`、`sing`

二、后端接收方式一：使用数组接收

1. 核心规则

- 后端方法的**数组形参名称**，必须与前端传递的**参数名完全一致**（如前端传`hobby`，数组名也需为`hobby`）。
- 无需额外注解，SpringBoot 会自动将同名的多个参数值封装到数组中。

2. 代码示例

```java
// 1. 请求路径：与前端请求路径匹配（示例为/arrayParam）
// 2. 数组形参：String[] hobby（名称与前端参数名一致）
@RequestMapping("/arrayParam")
public String arrayParam(String[] hobby) {
    // 输出数组内容（需导入java.util.Arrays）
    System.out.println("爱好列表：" + Arrays.toString(hobby)); 
    return "success";
}
```

3. 测试结果

若前端传递`hobby=game&hobby=java&hobby=sing`，控制台输出：

```
爱好列表：[game, java, sing]
```

三、后端接收方式二：使用集合接收

1. 核心规则（与数组的关键区别）

- 集合形参名称需与前端参数名一致；
- **必须添加`@RequestParam`注解**：SpringBoot 默认会将多值参数封装到数组，若需封装到`List`集合，需通过该注解 “绑定参数关系”，明确告知框架 “此集合用于接收多值参数”。

2. 代码示例

```java
// 1. 导入List包：import java.util.List;
// 2. 集合形参：@RequestParam List<String> hobby（注解不可省略）
@RequestMapping("/listParam")
public String listParam(@RequestParam List<String> hobby) {
    // 直接输出集合（List重写了toString()，无需额外处理）
    System.out.println("爱好列表：" + hobby); 
    return "success";
}
```

3. 测试结果

与数组接收逻辑一致，前端传递相同参数时，控制台输出：

```
爱好列表：[game, java, sing]
```

四、关键对比与注意事项

| 接收方式 | 核心要求            | 是否需 @RequestParam | 适用场景                                                     |
| -------- | ------------------- | -------------------- | ------------------------------------------------------------ |
| 数组     | 形参名 = 前端参数名 | 否                   | 简单多值接收，无需后续集合操作（如遍历、筛选）               |
| 集合     | 形参名 = 前端参数名 | 是                   | 需对多值进行复杂操作（如添加、删除、排序，依赖 List 的 API） |



#### 2.5 日期参数

在前端表单（如生日、入职时间、操作时间）传递日期参数时，因前端格式不统一（横杠 / 斜杠分隔、年月日 / 年月日时分秒等），后端需明确格式并指定接收规则。

1. 核心技术点

- **参数类型**：推荐使用 JDK 1.8 + 提供的`LocalDateTime`（线程安全，比传统`Date`类更优）。
- **关键注解**：`@DateTimeFormat`—— 用于指定前端传递的日期参数格式，核心属性`pattern`定义格式规则。
- 格式规则：常用格式示例（需与前端严格一致）：
  - 年月日：`yyyy-MM-dd`（如`2024-05-20`）
  - 年月日时分秒：`yyyy-MM-dd HH:mm:ss`（如`2024-05-20 14:30:00`）

2. 代码实现步骤

1. **定义 Controller 方法**：指定请求路径（如`/dateParam`），请求方式推荐`GET`（日期参数多为查询场景）。
2. **声明日期参数**：方法形参使用`LocalDateTime`，参数名需与前端请求参数名一致（如前端传`updateTime`，形参名也为`updateTime`）。
3. **添加格式注解**：在形参前加`@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")`，明确接收格式。

```java
// 示例代码
@RestController
public class ParamController {
    // 接收日期参数：前端传递 updateTime=2024-05-20 14:30:00
    @RequestMapping("/dateParam")
    public String dateParam(
            @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") 
            LocalDateTime updateTime) {
        System.out.println("接收的日期参数：" + updateTime);
        return "OK";
    }
}
```



#### 2.6 json格式参数

JSON 是前后端异步交互的主流数据格式（如表单提交、复杂对象传递），后端需将 JSON 数据自动封装到实体类中。

1. 核心技术点

- **请求方式**：必须使用`POST`——JSON 数据需放在**请求体（Request Body）** 中，而非 URL 参数。
- **关键注解**：`@RequestBody`—— 用于将请求体中的 JSON 数据自动映射到后端实体类对象。
- **映射规则**：JSON 的`key`必须与实体类的**属性名完全一致**（支持嵌套对象，如 JSON 中嵌套`address`对象，实体类也需有`Address`类型属性）。

2. 前提准备：定义实体类

需根据 JSON 结构创建对应实体类（含嵌套对象），确保属性名与 JSON 的`key`匹配。

```java
// 1. 嵌套对象：Address（对应JSON中的address属性）
public class Address {
    private String province; // 对应JSON的 "province"
    private String city;     // 对应JSON的 "city"
    //  getter/setter、toString() 省略
}

// 2. 主实体类：User（对应整个JSON）
public class User {
    private String name;    // 对应JSON的 "name"
    private Integer age;    // 对应JSON的 "age"
    private Address address;// 对应JSON的 "address"（嵌套对象）
    //  getter/setter、toString() 省略
}
```

3. 代码实现步骤

1. **定义 Controller 方法**：指定请求路径（如`/jsonParam`），请求方式为`POST`。
2. **声明实体类参数**：方法形参为目标实体类（如`User`）。
3. **添加注解**：在形参前加`@RequestBody`，开启 JSON 到实体类的自动映射。

```java
// 示例代码
@RestController
public class ParamController {
    // 接收JSON参数：请求体为 {"name":"张三","age":20,"address":{"province":"北京","city":"北京"}}
    @RequestMapping("/jsonParam")
    public String jsonParam(@RequestBody User user) {
        System.out.println("接收的JSON参数：" + user);
        return "OK";
    }
}
```



#### 2.7 路径参数

1. 定义与特点

- **概念**：路径参数是成为 URL 一部分的请求参数，例如请求路径`/pass/1`中，`1`既是 URL 路径的组成部分，也是传递给服务端的参数。
- **灵活性**：参数值可动态变化（如`1`可替换为`2`、`100`等），无需写死在请求路径中。

2. 服务端接收方式（SpringBoot 环境）

（1）路径配置

在`@RequestMapping`注解的路径中，用`{参数名}`标记动态参数部分，示例：

```java
// 路径中的{id}表示动态路径参数，参数名为id
@RequestMapping("/pass/{id}")
```

（2）参数绑定

- 需在方法形参前添加`@PathVariable`注解，实现路径参数与形参的绑定。
- **关键规则**：路径中定义的参数名（如`{id}`）需与方法形参名称（如`id`）保持一致，否则无法自动绑定。
- 单参数接收示例：

```java
@RequestMapping("/pass/{id}")
public String passParam(@PathVariable Integer id) {
    System.out.println("接收的路径参数id：" + id);
    return "OK";
}
```

（3）多路径参数接收

- 多参数用`/`分隔，在路径中依次定义`{参数名1}/{参数名2}`，方法形参前分别添加`@PathVariable`。
- 多参数接收示例：

```java
// 路径中定义id和name两个动态参数
@RequestMapping("/pass/{id}/{name}")
public String passParam2(@PathVariable Integer id, @PathVariable String name) {
    System.out.println("接收的路径参数id：" + id + "，name：" + name);
    return "OK";
}
```

- 对应请求 URL 示例：`/pass/10/Tcast`（此时`id=10`，`name=Tcast`）。

3. 测试工具与验证

- 使用 Postman 发起 GET 请求，输入动态路径（如`/pass/1`或`/pass/10/Tcast`），发送后可在服务端控制台查看参数是否成功接收。



#### 第三节 响应

一、@ResponseBody 注解：响应数据的 “转换器”

1. 核心作用

- 将 Controller 方法的**返回值直接作为响应体**，传递给客户端（而非跳转页面）。
- 自动格式转换：若返回值是**对象 / 集合**，会自动转为`JSON格式`后响应；若为`String`，则直接以字符串形式响应。

2. 作用范围

- **方法级**：单独加在某个 Controller 方法上，仅该方法的返回值会被处理。
- **类级**：加在 Controller 类上，该类下所有方法的返回值都会被统一处理。

3. 与 @RestController 的关系

`@RestController`是**组合注解**，等价于`@Controller + @ResponseBody`，是开发中最常用的注解（无需单独加`@ResponseBody`）。

4. 实际效果

| 方法返回值类型           | 处理逻辑       | 响应结果示例                                       |
| ------------------------ | -------------- | -------------------------------------------------- |
| String                   | 直接返回字符串 | `"hello world"`                                    |
| 自定义对象（如 Address） | 转为 JSON 对象 | `{"province":"Beijing","city":"Haidian"}`          |
| 集合（如 List<Address>） | 转为 JSON 数组 | `[{"province":"Beijing"},{"province":"Shanghai"}]` |

二、统一响应结果：解决前后端交互 “格式混乱” 问题

1. 为什么需要统一响应结果？

- 未统一时：不同接口返回值类型混乱（String / 对象 / 集合），前端需反复适配解析逻辑，开发成本高、维护难。
- 统一后：所有接口返回**相同格式的 JSON 数据**，前端只需一套解析规则，降低沟通成本，提升项目规范性。

2. 统一响应结果的核心结构（Result 类）

通过自定义`Result`实体类，封装所有响应的共性信息，核心包含 3 个属性：

| 属性名  | 类型    | 含义说明                                                     |
| ------- | ------- | ------------------------------------------------------------ |
| code    | Integer | 响应状态码（与前端约定）：如`1`代表 “成功”，`0`代表 “失败”，可扩展更多状态（如 404、500） |
| message | String  | 提示信息：如 “操作成功”“参数错误”，用于前端展示或调试        |
| data    | Object  | 响应数据体：存储实际业务数据（如查询结果、新增后的对象），无数据时可返回`null` |

3. Result 类的优化设计（静态工具方法）

为简化代码，在`Result`类中提供**静态方法**，快速构建响应对象，避免重复`new Result()`的操作：

```java
public class Result {
    private Integer code;
    private String message;
    private Object data;

    // 1. 成功（无数据返回）：如新增/删除操作
    public static Result success() {
        return new Result(1, "操作成功", null);
    }

    // 2. 成功（有数据返回）：如查询操作
    public static Result success(Object data) {
        return new Result(1, "操作成功", data);
    }

    // 3. 失败（返回错误提示）：如参数校验失败、业务异常
    public static Result error(String message) {
        return new Result(0, message, null);
    }

    // 构造器、getter/setter省略
}
```

4. 实际应用：改造 Controller 接口

将所有 Controller 方法的返回值从 “原始类型” 改为`Result`，示例如下：

改造前（混乱格式）

```java
@RestController
public class ResponseController {
    // 返回String
    @GetMapping("/hello")
    public String hello() {
        return "hello world";
    }

    // 返回对象
    @GetMapping("/addr")
    public Address getAddr() {
        Address addr = new Address("Beijing", "Haidian");
        return addr;
    }
}
```

改造后（统一格式）

```java
@RestController
public class ResponseController {
    // 统一返回Result
    @GetMapping("/hello")
    public Result hello() {
        return Result.success("hello world"); // 有数据返回
    }

    @GetMapping("/addr")
    public Result getAddr() {
        Address addr = new Address("Beijing", "Haidian");
        return Result.success(addr); // 有数据返回
    }

    @PostMapping("/user")
    public Result addUser() {
        // 新增逻辑...
        return Result.success(); // 无数据返回（仅提示成功）
    }

    @GetMapping("/error")
    public Result testError() {
        return Result.error("参数格式错误"); // 失败场景
    }
}
```

5. 统一响应后的效果（JSON 格式）

所有接口响应格式一致，前端可按`code`判断状态，按`data`获取业务数据：

```json
// 1. 成功（有数据）
{
  "code": 1,
  "message": "操作成功",
  "data": "hello world"
}

// 2. 成功（无数据）
{
  "code": 1,
  "message": "操作成功",
  "data": null
}

// 3. 失败
{
  "code": 0,
  "message": "参数格式错误",
  "data": null
}
```



![image-20251116163128284](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251116163128284.png)