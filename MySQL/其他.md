三大范式（Normalization Forms）是数据库设计中**规范化理论**的核心，目的是**减少数据冗余、避免插入 / 更新 / 删除异常**，让数据库结构更清晰、维护更高效。其本质是通过对数据表的属性（列）进行合理拆分，明确属性间的依赖关系，最终形成结构严谨的关系模型。

### 核心前提：理解 “函数依赖”

范式的定义基于「函数依赖」（Functional Dependency，FD）：

若数据表中，通过属性集 `X` 能唯一确定属性集 `Y`（即同一 `X` 对应唯一 `Y`），则称 **Y 函数依赖于 X**（记为 `X → Y`）。

例：学生表中，`学号 → 姓名`（一个学号唯一对应一个姓名），但 `姓名 → 学号` 不成立（可能重名）。

### 第一范式（1NF：First Normal Form）—— 原子性

#### 定义：

数据表中的**每一列（属性）必须是不可再分的原子值**，且列名唯一、列的顺序无关、行的顺序无关、行不重复。

#### 核心要求：

- 列不可拆分（无 “复合列”“多值列”）；
- 行无重复（通常用主键保证）。

#### 反例（不满足 1NF）：

| 学号 | 姓名 | 联系方式（复合列）           |
| ---- | ---- | ---------------------------- |
| 001  | 张三 | 电话：123 邮箱：zhangsan@xxx |
| 002  | 李四 | 电话：456 邮箱：lisi@xxx     |

#### 正例（满足 1NF）：

| 学号（主键） | 姓名 | 电话 | 邮箱         |
| ------------ | ---- | ---- | ------------ |
| 001          | 张三 | 123  | zhangsan@xxx |
| 002          | 李四 | 456  | lisi@xxx     |

#### 说明：

1NF 是最基础的范式，所有关系型数据库（MySQL、Oracle 等）默认满足 1NF（列无法存储拆分后的数据），但设计时需主动避免 “隐性复合列”（如用逗号分隔的多值数据）。

### 第二范式（2NF：Second Normal Form）—— 完全依赖

#### 定义：

在满足 1NF 的基础上，**所有非主键列必须完全函数依赖于主键**（而非依赖主键的一部分，即 “部分依赖”）。

#### 核心要求：

- 消除 “部分依赖”；
- 若主键是 “复合主键”（多列组合），非主键列不能只依赖其中一列。

#### 反例（不满足 2NF）：

假设用「课程号 + 学生号」作为复合主键的 “选课表”：

| 课程号（主键 1） | 学生号（主键 2） | 课程名称 | 学生姓名 | 成绩 |
| ---------------- | ---------------- | -------- | -------- | ---- |
| C01              | S01              | 数学     | 张三     | 90   |
| C01              | S02              | 数学     | 李四     | 85   |
| C02              | S01              | 英语     | 张三     | 88   |

问题：

- `课程名称` 只依赖 `课程号`（部分依赖复合主键）；
- `学生姓名` 只依赖 `学生号`（部分依赖复合主键）；
- 冗余严重（同一课程名称、学生姓名重复存储）；
- 更新异常（修改课程名称需改所有该课程的记录）。

#### 正例（满足 2NF）：

拆分为 3 张表，消除部分依赖：

1. 学生表（主键：学生号）：

   | 学生号 | 学生姓名 |
   |--------|----------|
   | S01 | 张三 |
   | S02 | 李四 |

2. 课程表（主键：课程号）：

   | 课程号 | 课程名称 |
   |--------|----------|
   | C01 | 数学 |
   | C02 | 英语 |

3. 选课表（主键：课程号 + 学生号）：

   | 课程号 | 学生号 | 成绩 |
   |--------|--------|------|
   | C01 | S01 | 90 |
   | C01 | S02 | 85 |
   | C02 | S01 | 88 |

#### 说明：

- 若主键是 “单一列”（如学生表的学号），则天然满足 2NF（无 “部分依赖” 的可能）；
- 2NF 的核心是 “拆分表，让非主键列只依赖完整主键”。

### 第三范式（3NF：Third Normal Form）—— 传递依赖

#### 定义：

在满足 2NF 的基础上，**所有非主键列必须直接函数依赖于主键，不能存在传递依赖**（即非主键列 A 依赖非主键列 B，B 依赖主键，导致 A 传递依赖主键）。

#### 核心要求：

- 消除 “传递依赖”；
- 非主键列之间不能有函数依赖关系。

#### 反例（不满足 3NF）：

学生表（主键：学号）：

| 学号 | 姓名 | 班级编号 | 班级名称    |
| ---- | ---- | -------- | ----------- |
| S01  | 张三 | C101     | 一年级 1 班 |
| S02  | 李四 | C102     | 一年级 2 班 |
| S03  | 王五 | C101     | 一年级 1 班 |

问题：

- `班级名称` 依赖 `班级编号`（非主键列之间的依赖），而 `班级编号` 依赖 `学号`，因此 `班级名称` 传递依赖于主键 `学号`；
- 冗余严重（同一班级名称重复存储）；
- 更新异常（修改班级名称需改所有该班级学生的记录）。

#### 正例（满足 3NF）：

拆分为 2 张表，消除传递依赖：

1. 学生表（主键：学号）：

   | 学号 | 姓名 | 班级编号 |
   |------|------|----------|
   | S01 | 张三 | C101 |
   | S02 | 李四 | C102 |
   | S03 | 王五 | C101 |

2. 班级表（主键：班级编号）：

   | 班级编号 | 班级名称 |
   |----------|----------|
   | C101 | 一年级 1 班 |
   | C102 | 一年级 2 班 |

#### 说明：

3NF 的核心是 “非主键列只回答‘与主键直接相关的问题’”，避免 “间接关联” 导致的冗余和异常。

### 三大范式的核心目标与总结

| 范式 | 核心要求             | 解决的问题                | 通俗理解                            |
| ---- | -------------------- | ------------------------- | ----------------------------------- |
| 1NF  | 列不可拆分（原子性） | 数据格式不规范            | 一列只存一个 “最小单位” 的数据      |
| 2NF  | 非主键列完全依赖主键 | 部分依赖导致的冗余 / 异常 | 非主键列必须 “绑定完整主键”         |
| 3NF  | 非主键列无传递依赖   | 传递依赖导致的冗余 / 异常 | 非主键列之间 “互不依赖”，只依赖主键 |

#### 关键补充：

1. 范式是 “设计指南”，而非 “强制标准”：实际设计中可能为了查询效率（减少表连接），适当保留少量冗余（反规范化），需在 “规范化” 和 “性能” 之间权衡；
2. 更高范式：除三大范式外，还有 BCNF（Boyce-Codd Normal Form）、4NF、5NF 等，但实际开发中**满足 3NF 已能解决绝大多数问题**，更高范式可能导致表过多、查询复杂。

通过三大范式设计的数据库，结构清晰、冗余少、维护成本低，是关系型数据库设计的基础原则。