# C++高级课程

### 一、对象的应用优化，右值引用的优化

#### 1.为什么要关注对象使用过程中背后调用的函数？

- **代码效率优化**：C++ 与 C 同属**本地编译型语言**，效率差异并非源于语言本身，而是开发者未减少 “编译器隐式添加的函数调用”。优化对象的核心思路是：**减少不必要的构造、拷贝构造、析构调用**，直接提升面向对象代码效率。

#### 2.类的四大核心函数及基础调用场景

|   函数类型   |                 功能描述                  |                         典型调用场景                         |                      关键特征                      |
| :----------: | :---------------------------------------: | :----------------------------------------------------------: | :------------------------------------------------: |
| 普通构造函数 | 初始化新对象（分配资源、初始化成员变量）  | 1. 直接定义对象：`Test t1(10);`<br/> 2. new 创建对象：`Test* p = new Test(20);` |             新对象生成，无同类对象参与             |
|   析构函数   |    释放对象资源（如堆内存、文件句柄）     | 1. 局部对象出作用域 <br/>2. delete 对象 / 对象数组 <br/>3. 临时对象生命周期结束 |     与构造函数调用顺序**相反**（栈：先进后出）     |
| 拷贝构造函数 | 用已有对象初始化新对象（同类对象 “复制”） | 1. 定义对象时直接赋值：`Test t2 = t1;` <br/>2. 函数参数按值传递 <br/>3. 函数返回值为对象（未优化时） | 参数必须是 “同类对象的 const 引用”（避免递归调用） |
| 赋值重载函数 |   给已存在的对象赋值（同类对象 “更新”）   | 1. 对象定义后赋值：`Test t3; t3 = t1;`<br/>2. 临时对象给已有对象赋值：`t3 =Test(30);` |      左操作数是 “已初始化的对象”，返回`*this`      |

#### 3. 编译器核心优化：临时对象 “消除”

当**临时对象仅用于构造新对象**时，编译器会直接优化为 “新对象的普通构造”，跳过 “临时对象构造→拷贝构造→临时对象析构” 三步，仅保留一次普通构造调用：

- 优化后逻辑（实际执行）：直接等同于`Test t5(70);` → 仅 1 次普通构造调用（无临时对象）

**注意**：该优化是 C++ 标准规定的 “允许优化”，所有主流编译器（VS、GCC、Clang）均支持，与平台无关。

#### 4. 临时对象无法优化的场景

当临时对象用于 “赋值” 而非 “构造新对象” 时，**必须生成临时对象**，无法优化，调用逻辑为：

- 语法示例：`Test t6; t6 = Test(80);`（t6 已存在，是赋值操作）
- 调用顺序：构造临时对象（`Test(80)`）→ 调用赋值重载（给 t6 赋值）→ 析构临时对象（3 次调用，无优化）

```c++
class Test{
public:
    Test(int a=10):ma(a){cout<<"Test(int)"<<endl;}
    //带默认参数的构造函数，使用初始化列表将参数 a 赋值给成员变量 ma
    ~Test() {cout<<"~Test"<<endl;}
    //析构函数
    Test(const Test &t):ma(t.ma) {cout<<"Test(const Test&)"<<endl;}
    //拷贝构造函数，通过已存在的对象创建新对象
    Test& operator = (const Test &t)
    {
        cout<<"operator"<<endl;
        ma=t.ma;
        return *this;
    }
    //赋值运算符重载，使得对象间可以进行赋值操作
    //将参数对象的 ma 值赋给当前对象的 ma，然后返回当前对象的引用
private:
    int ma;
};

int main()
{
    Test t1;
    Test t2(t1);
    Test t3=t1;
    Test t4=Test(20);//与Test t4(20); 是没有区别的
    //Test(20) 生成临时对象，生存周期：所在的语句
    //C++编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了
    //即临时对象就被优化掉了
    cout<<"---------"<<endl;
    t4=t2;//调用拷贝构造函数

    t4=Test(30);//这里的Test(30)是必须要生成的，需要给t4重新赋值
    t4=(Test)30;//int->Test 强行转为Test类型
    //要看Test类型里是否有int类型的构造函数，有的话可以直接转换，没有会报错

    t4=30;//隐式转换
    cout<<"---------"<<endl;
    return 0;
}


//析构与创建的顺序是相反的
```

![](C:\Users\Silence\OneDrive\Pictures\Screenshots\屏幕截图 2025-10-08 131552.png)

#### 5.指针 / 引用与临时对象的安全问题

- 在使用指针或引用绑定临时对象时，存在**生命周期不匹配**的风险，需严格区分安全场景：

| 绑定方式         | 语法示例                       | 安全性           | 原因分析                                                     |
| ---------------- | ------------------------------ | ---------------- | ------------------------------------------------------------ |
| 指针绑定临时对象 | `Test* p = &Test(90);`         | 不安全（野指针） | 临时对象在语句结束后立即析构，指针指向 “已释放的内存”，后续访问会触发未定义行为 |
| 引用绑定临时对象 | `const Test& ref = Test(100);` | 安全             | C++ 标准规定：**const 引用会延长临时对象的生命周期**，使其与引用变量生命周期一致（非 const 引用在高版本 VS 中直接报错，禁止绑定临时对象） |

```c++
int main()
{
    cout<<"---------"<<endl;
    Test *p=&Test(40);
    //在 C++ 中，Test(40) 是一个临时对象（右值），不能直接取地址赋给指针
    //尝试获取临时对象的地址并赋给指针是不允许的，这会导致指针指向已销毁的对象，形成野指针。

    const Test &ref=Test(50);//用引用变量指向临时对象是可行的，语句结束后临时对象不析构
    cout<<"---------"<<endl;
    return 0;
}
```

#### 6.特殊对象的调用逻辑

1. **全局对象**：
   - 构造时机：`main`函数执行前（数据段初始化）
   - 析构时机：`main`函数执行结束后（程序退出前）
   - 特点：构造顺序与定义顺序一致，析构顺序相反。
2. **静态局部对象（`static Test t;`）**：
   - 构造时机：**第一次执行到定义语句时**（仅一次，数据段内存提前分配，但初始化延迟）
   - 析构时机：程序退出前（晚于普通局部对象）
   - 特点：生命周期贯穿整个程序，避免 “局部对象频繁构造 / 析构”。
3. **对象数组**：
   - 构造时机：`new Test[3];` → 调用 3 次默认构造（无参数或参数全有默认值）
   - 析构时机：`delete[] p;` → 调用 3 次析构（必须用`delete[]`，否则仅析构第一个对象，内存泄漏）
   - 注意：若类无默认构造，无法直接定义对象数组（需手动指定每个元素的构造参数）。
4. 需明确区分 “初始化” 和 “赋值”—— 初始化是对象**首次创建时**的操作（调用构造 / 拷贝构造），赋值是对象**已存在后**的内容更新（调用赋值重载），二者在汇编指令和内存行为上完全不同。

```c++

class Test
{
public:
    Test(int a =5, int b =5):ma(a), mb(b)
    {
        cout << "Test(int, int)" << endl;
    }	
    //带默认参数的构造函数
    //可以构造Test(),Test(10),Test(10,10)

    ~Test() {cout << "~Test()" << endl;}

    Test(const Test &src):ma(src.ma), mb(src.mb)
    {
    cout << "Test(const Test&)" << endl;
    }

    void operator=(const Test &src)
    {
        ma = src.ma;
        mb = src.mb;
    cout << "operator=" << endl;
    }
private:
    int ma;
    int mb;
};

Test t1(10, 10);//先进行全局函数的构造 1.Test(int, int)

int main()
{
    Test t2(20, 20);//3.Test(int,int)
    Test t3 = t2;//4.Test(const Tset&) 拷贝构造函数
    static Test t4 = Test(30, 30);
    //静态局部变量在第一次运行到它时进行初始化
    //临时对象被优化，直接对t4进行构造，等同于static Test t4(30,30);
    //5.Test(int,int)

    t2 = Test(40, 40);
    //6.显式生成临时对象Test(int,int),再调用赋值函数operator=，最后析构~Test()
    t2 = (Test)(50, 50);
    //逗号表达式，相当于t2=(Test)50;
    //直接调用构造函数实现强制转换
    //7.Test(int,int) operator= ~Test()
    t2 = 60;//8.隐式生成临时对象 Test(int,int) operator= ~Test()
    Test *p1 = new Test(70, 70);
    //9.new在堆上新建一个对象，只有在delete时会删除对象，释放空间 Test(int,int)
    Test *p2 = new Test[2];
    //10.new一个对象数组，每一个对象都会调用默认构造
    //Test(int,int) Test(int,int)

    //Test *p3 = &Test(80, 80);会产生野指针

    const Test &p4 = Test(90, 90);
    //11.p4出作用域时，临时对象才析构
    delete p1;//12.~Test()
    delete[]p2;//13.~Test() ~Test()

    //p4析构，t3,t2
    //t4在数据段上的程序结束才析构
    //t5,t1
}

Test t5(100, 100);//2.Test(int, int)
```

![](C:\Users\Silence\OneDrive\Pictures\Screenshots\屏幕截图 2025-10-08 135910.png)

#### 7. 核心风险提示

- **函数不能返回局部对象（如`tmp`）或临时对象的指针 / 引用**，原因是：

  - 局部对象存储在函数的 “栈内存” 中，函数执行结束后，栈内存会被系统回收，对象随之销毁；

  - 若返回其指针 / 引用，调用方拿到的是 “悬空指针 / 引用”，后续访问会触发内存越界（未定义行为）。


- 例外情况：若对象存储在 “数据段”（如全局对象、`static`局部对象），其生命周期与程序一致，可返回指针 / 引用。

```c++
class Test{
public:
    Test(int data=10) :ma(data)
    {
        cout<<"Test(int)"<<endl;
    }

    ~Test() {cout<<"~Test()"<<endl;}

    Test(const Test &t):ma(t.ma)
    {
        cout<<"Test(const Test&)"<<endl;
    }
    void operator=(const Test &t)
    {
        cout<<"operator="<<endl;
        ma=t.ma;
    }

    int getData() const {return ma;}

private:
    int ma;
};


//这里不能返回一个指针或引用，一定要保证指针和引用在返回时仍然存在
//即不能返回局部或临时对象的引用或指针
Test GetObject(Test t)//3.Test(const Test&)拷贝构造函数，由t1来拷贝构造形参t
{
    int val =t.getData();
    static Test tmp(val);//4.Test(int)
    return tmp;
}
//5.Test(const Test&) 调用拷贝构造函数在main栈帧上构造一个临时对象将tmp带出
//6.tmp ~Test()
//7.形参t ~Test()


int main()
{
    Test t1;//1.Test(int,int)
    Test t2;//2.Test(int,int)
    t2=GetObject(t1);//8.operator
    //函数调用，实参到形参时一个初始化而不是赋值的过程
    return 0;
}

//9.临时对象 ~Test()
//10.t2,t1 ~Test()

```

![](C:\Users\Silence\OneDrive\Pictures\Screenshots\屏幕截图 2025-10-08 141948.png)

#### 8.三大对象优化规则

- [ ] **规则 1:函数参数传递对象时，优先按 “引用传递”，而非 “值传递”**

##### 	1.1未优化的问题（值传递)

- 当函数参数以 “值传递” 接收对象时，编译器会：

1. 用实参对象**拷贝构造一个新的形参对象**（产生 1 次拷贝构造调用）；

2. 函数执行结束后，形参对象出作用域，触发**析构调用**（产生 1 次析构调用）；

##### 1.2 优化方案（引用传递）

- 将参数改为 “引用类型”（底层本质是安全的指针，必须初始化），此时：

1. 不产生新的形参对象（直接复用实参的内存地址）；

2. 减少 “拷贝构造 + 析构”2 次函数调用；



- [ ] **规则 2：函数返回对象时，优先返回 “临时对象”，而非 “已定义的局部对象”**

##### 2.1 未优化的问题（返回已定义局部对象）

- 若函数先定义局部对象，再返回该对象，编译器会：

1. 构造局部对象（1 次构造调用）；
2. 返回时，用局部对象**拷贝构造一个 “临时对象”**（带返回值出函数，1 次拷贝构造）；
3. 局部对象出作用域，触发析构（1 次析构）；

##### 2.2 优化方案（返回临时对象）

- 直接返回 “临时对象”（不提前定义局部对象），利用**编译器的 “返回值优化（RVO）”**：

- 临时对象无需先构造再拷贝：编译器会直接在 “调用者的栈帧” 中构造临时对象，跳过 “局部对象的构造 + 拷贝构造 + 析构”；

##### 2.3 关键原理：编译器的 RVO 优化

- 当满足 “用临时对象拷贝构造同类型新对象” 时，C++ 编译器会自动触发**返回值优化（Return Value Optimization）**

- 不实际产生临时对象，直接在 “最终需要的内存位置”（如调用者的栈帧）构造对象，彻底消除临时对象的拷贝 / 析构开销。



- [ ] **规则 3：接收函数返回的对象时，优先用 “初始化方式”，而非 “先定义再赋值”**

#####3.1 未优化的问题（先定义再赋值）

- 若先定义对象，再用函数返回值给对象 “赋值”，编译器会：

1. 函数返回临时对象（已通过规则 2 优化，但仍需构造临时对象）；
2. 用临时对象给已定义的对象 “赋值”（产生 1 次赋值运算符调用）；
3. 赋值结束后，临时对象析构（产生 1 次析构调用）；

##### 3.2 优化方案（初始化方式接收）

- 在定义对象时，直接用函数返回值 “初始化” 对象，利用**编译器的 “拷贝省略（Copy Elision）” 优化**：

- 不产生临时对象：编译器直接将 “函数返回的对象” 构造在 “t2 的内存地址” 上，跳过 “临时对象的构造 + 赋值 + 析构”；

##### 3.3 关键原理：编译器的拷贝省略

- 当满足 “用函数返回的临时对象初始化同类型新对象” 时，编译器触发**拷贝省略**：

- 直接在 “接收对象的内存位置” 构造返回对象，彻底消除临时对象的开销（即使禁用 RVO，C++17 后该优化为强制行为）。



```C++
/*
1.函数参数传递过程中，对象优先按引用传递，不用按值传递
    形参t的拷贝构造，形参t的析构
2.函数返回对象时，应该优先返回一个临时对象，而不是返回一个定义过的对象
3.接收返回值是对象的函数调用时，优先按初始化的方式接收，不要以赋值的方式接收
*/

Test GetObject(Test &t)
{
    int val = t. data();
    /*Test tmp(val);
    return tmp; */
    //返回临时对象
    return Test(val);//用临时对象拷贝构造一个新对象，这里会优化
    //直接在main上构造临时对象
}

int main()
{
    Test t1;
    Test t2= GetObject(t1);//用临时对象拷贝构造新对象，同样会优化
    //t2= GetObject(t1);
    return 0;
}

```

<img src="C:\Users\Silence\OneDrive\Pictures\Screenshots\屏幕截图 2025-10-08 143953.png"  />





#### 9.三大规则的底层支撑

1. **返回值优化（RVO）**：针对 “函数返回临时对象”，直接在调用者栈帧构造对象，跳过拷贝；
2. **拷贝省略（Copy Elision）**：针对 “用临时对象初始化新对象”，省略临时对象的拷贝 / 析构，直接构造目标对象；

- 注意：这两个优化不是 “可选”，C++17 后已成为编译器强制行为，无需手动开启。





### 二、智能指针

##### 1. 裸指针的定义与问题

- **定义**：直接通过`new`分配堆内存、需手动通过`delete`释放的指针（如`int* p = new int(10);`），称为 “裸指针”（视频中 “罗指针” 为口误）。

- 核心痛点

  - **内存泄漏**：堆内存需用户手动释放（C++ 用`delete`、C 用`free`），若忘记释放、代码逻辑跳转（如`return`提前退出）或抛出异常，会导致内存无法回收，造成泄漏。
  - **资源管理不可靠**：程序运行中异常、逻辑分支变化可能导致 “释放代码写了但未执行”，无法保证资源可靠回收。

##### 2.**智能指针的核心目标**

- 通过封装裸指针，利用 C++ 对象的 “出作用域自动析构” 特性，实现**资源自动释放**—— 无论程序正常执行、提前返回还是抛出异常，都能确保堆内存被回收，解决裸指针的管理问题。

#### 3.智能指针的底层原理与简易实现

- **核心设计思路**：智能指针本质是 “封装裸指针的类模板”，利用**栈上对象的自动析构特性**（栈对象出作用域时，编译器会自动调用其析构函数），在析构函数中完成裸指针的`delete`操作。

- 简易智能指针实现步骤（类模板）

```cpp
template <typename T>
class CSmartPtr {
private:
    T* m_ptr; // 封装的裸指针，存储堆内存地址
public:
    // 1. 构造函数：初始化裸指针（接收new分配的堆内存地址）
    CSmartPtr(T* ptr = nullptr) : m_ptr(ptr) {}
    
    // 2. 析构函数：自动释放资源（核心！）
    ~CSmartPtr() {
        if (m_ptr != nullptr) {
            delete m_ptr; // 出作用域时自动调用，释放堆内存
            m_ptr = nullptr;
        }
    }
    
    // 3. 重载运算符：模拟裸指针的使用方式
    // （1）重载*：支持解引用（如*ptr = 20;）
    T& operator*() { return *m_ptr; }
    // （2）重载->：支持访问对象成员（如ptr->func();）
    T* operator->() { return m_ptr; }
};
```

- 关键细节说明

  - **运算符重载的必要性**：若不重载`*`和`->`，智能指针无法像裸指针一样操作（如无法解引用赋值、无法访问对象方法），重载后才能 “表现得和裸指针一致”。

  - **返回值类型**：`operator*`返回`T&`（引用），而非`T`（值）—— 若返回值，修改时会操作 “值的拷贝”，无法真正修改堆内存中的数据；返回引用才能直接操作原内存。

  - **智能指针的存储位置**：严禁将智能指针本身分配在堆上（如`CSmartPtr<int>* p = new CSmartPtr<int>(new int(10));`）—— 堆上的智能指针对象仍需手动`delete`，会回到裸指针的问题，失去 “自动释放” 的意义，智能指针必须定义在栈上。

























## 三、绑定器和函数对象，lambda表达式

## 四、C++11，多线程应用实践

## 五、设计模式

## 六、面向对象编程实践