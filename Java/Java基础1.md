# Java基础

## 第一章 概述

### 第一节 简介

一、历史

- Java是美国的sun公司(Stanford University Network)在1995年推出的一门**计算机高级编程语言**。sun公司于2009年被Oracle(甲骨文)公司收购。
- 普遍认同Java的联合创始人之一：**詹姆斯·高斯林(James Gosling)**为Java之父。

二、Java为什么会被企业广泛采用

- Java是世界上最流行的编程语言之一，在国内是使用最为广泛的编程语言。
- Java的开发社区完善，功能丰富。
- Java具有很好的可移植，安全可靠、性能较好。

- 主要做企业服务器开发

三，Java的三大技术平台

- Java SE(Java Standard Edition)标准版：Java技术的核心和基础
- Java EE(Java Enterprise Edition)企业版：企业级应用开发的一套解决方案
- Java ME(Java Micro Edition)小型版：针对移动设备应用的解决方案

四、开发第一个Java入门程序

- Java的产品叫JDK (Java Development Kit: Java开发者工具包)，必须安装JDK才能使用Java。



### 第二节 入门

一、JDK

1.**JDK（Java Development Kit，Java 开发工具包）** 是 Oracle（或 OpenJDK 社区）提供的**Java 开发核心套件**，是程序员开发、编译、调试 Java 程序的 “必备工具集”。

本质上，JDK 是 Java 开发的 “基础环境”，包含了开发 Java 程序所需的所有工具、资源和运行支持，**没有 JDK 就无法编写、编译 Java 代码**（仅装 JRE 只能运行已编译好的 Java 程序，无法开发）。

2、JDK 的核心组成

- JVM (Java Virtual Machine): Java虚拟机，真正运行Java程序的地方。

- 核心类库：Java自己写好的程序，给程序员自己的程序调用的。
- JRE (Java runtime Environment): Java的运行环境。
- JDK (Java Development Kit): Java开发工具包(包括上面所有)。

3. JDK 与 JRE、JVM 的关系

很多初学者会混淆三者，用 “包含关系” 可清晰理解：`JDK ⊃ JRE ⊃ JVM`

- **JVM**：最核心的 “跨平台引擎”，仅负责执行字节码，无法单独运行（需依赖 JRE 的类库）；
- **JRE**：仅包含 “JVM + 核心类库”，只能运行已编译好的 Java 程序（如双击.jar 文件），**不能开发**（无 javac 等编译工具）；
- **JDK**：包含 “JRE + 开发工具集”，是开发的 “完整版套件”

二、javac

​	**javac** 是 Java Compiler（Java 编译器）的缩写，是 JDK（Java Development Kit，Java 开发工具包）中自带的核心命令行工具之一，主要作用是将人类可读的 **Java 源代码文件（.java 文件）** 编译成 Java 虚拟机（JVM）可执行的 **字节码文件（.class 文件）**。

​	说明：我们写好的Java程序都是高级语言，计算机底层是硬件不能识别这些语言，必须先通过javac编译工具进行翻译，然后再通过java执行工具执行才可以驱动机器干活。

2. javac 与 JDK、JVM 的关系

| 组件  |               核心作用                |                与 javac 的关联                |
| :---: | :-----------------------------------: | :-------------------------------------------: |
|  JDK  | Java 开发工具包（含开发所需所有工具） |  javac 是 JDK 的 `bin` 目录下的核心工具之一   |
| javac |              Java 编译器              | 将 .java 编译为 .class，是 “开发→运行” 的桥梁 |
|  JVM  |              Java 虚拟机              |      解释执行 .class 字节码，实现跨平台       |

简单来说：**JDK 包含 javac，javac 编译出的 .class 文件由 JVM 运行**。

2.配置环境变量
    安装IDK后，需要配置环境变量。主要是设置JAVA_HOME和将JDK的bin目录添加到系统的PATH中。这样你就可以在**任何位置**运行Java命令了。

三、环境变量

- **Path 环境变量**是操作系统（如 Windows、macOS、Linux）中一个**核心的系统级配置项**，可用于配置程序的所在路径，以方便在命令行窗口的任意目录下直接通过命令启动该程序。其核心作用是 **“告诉系统去哪里找可执行程序”**

 1、Path 环境变量的核心定义

​	Path（全大写，部分系统小写为`path`，功能一致）是操作系统维护的 “路径列表”，当你在**命令行窗口（如 Windows 的 CMD、PowerShell，macOS 的终端）** 输入一个命令时，系统会按以下规则查找对应的可执行程序（如`.exe`、`.bat`文件）：

1. 先在**当前命令行所在的目录**中查找；
2. 如果当前目录找不到，就会依次遍历`Path`环境变量中配置的所有路径，逐个目录查找；
3. 找到对应程序则直接运行，所有路径都找不到则提示 “命令不是内部或外部命令，也不是可运行的程序”。

2. Path 的配置本质： “**简化命令执行流程**”：

- 对于用户：无需记住程序的完整安装路径，也无需手动切换到程序目录，输入命令就能运行；
- 对于开发者：编写脚本、运行工具（如 Java、Python、Node.js 等开发工具）时，无需硬编码程序路径，保证脚本在不同电脑上的兼容性。

3. 建议为JDK再配置JAVA_HOME环境变量：

- JAVA_HOME:是用于告诉操作系统JDK安装在了哪个位置（将来其他技术要通过这个环境变量找JDK）：`Path%JAVA HOME%\bin`

四、Java的跨平台特性

![image-20251018143224480](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018143224480.png)

​	Java 的 “跨平台” 特性（即 “一次编写，到处运行”，Write Once, Run Anywhere）是其核心优势之一，其实现原理并非直接让 Java 代码与操作系统交互，而是通过**中间层（JVM）** 实现 “平台隔离”，本质是 “Java 代码不直接依赖操作系统，而是依赖统一的 JVM 标准”。

 1.核心支撑：JVM（Java 虚拟机）是跨平台的 “桥梁”

​	Java 跨平台的核心是 **JVM（Java Virtual Machine，Java 虚拟机）**，它是一个 “虚拟的计算机”—— 对 Java 程序而言，JVM 提供了统一的运行环境；对操作系统而言，JVM 是一个普通的可执行程序（如 Windows 上的`jvm.dll`、Linux 上的`libjvm.so`）。

​	关键逻辑：**不同操作系统安装对应的 JVM 版本，Java 程序只需面向 JVM 编写，无需关心底层系统差异**。

2. 跨平台的 “前提”：JVM 的 “平台相关性”

​	很多人会误解 “Java 跨平台是因为 JVM 跨平台”，但实际是：**JVM 本身是 “平台相关” 的，而 Java 程序是 “平台无关” 的**。

- 本质逻辑：微软为 Windows 开发 “Windows 版 JVM”，为 Linux 开发 “Linux 版 JVM”—— 这些 JVM 分别适配了不同系统的 API（如文件操作、内存管理、线程调度），但对外提供的 “字节码执行接口” 是统一的。

  Java 程序只需调用 JVM 提供的统一接口（如`System.out.println()`），无需直接调用 Windows 的`WriteConsole`或 Linux 的`printf`，从而实现 “一次编写，到处运行”。

五、IDE

​	IDE 是**集成开发环境（Integrated Development Environment）**的缩写。它是一种为程序开发人员提供全面软件开发工具的应用程序。

- **功能组件**：通常包括源代码编辑器、构建自动化工具和调试器，还可能集成编译器、解释器、版本控制系统，以及简化图形用户界面（GUI）构建的工具等。
- **特点优势**：IDE 旨在提高开发人员的生产力，简化开发过程，并提供更好的开发体验。它一般具有代码自动补全、语法高亮等功能，能让开发人员更高效地编写代码，快速发现语法错误等问题。
- **常见类型**：常见的 IDE 有用于多种编程语言开发的 Microsoft Visual Studio 系列，主要用于 Java 开发的 Eclipse、IntelliJ IDEA，专门用于 Python 开发的 PyCharm，用于 iOS 和 macOS 应用程序开发的 Xcode，以及用于 Android 应用程序开发的 Android Studio 等。

六、快捷键

| 快捷键                  | 作用                        |
| ----------------------- | --------------------------- |
| main/ psvm、sout、…     | 快速键入相关代码            |
| Ctrl + D                | 复制当前行数据到下一行      |
| Ctrl + Y                | 删除所在行，建议用(Ctrl+X） |
| Ctrl + ALT + L          | 格式化代码                  |
| ALT+SHIFT+↑,ALT+SHIFT+↓ | 上下移动当前代码            |
| CtrI+/,CtrI+Shift+/     | 对代码进行注释              |



## 第二章 基础语法

### 第一节 数据

一、注释

1. 概念：注释是写在程序中对代码进行解释说明的文字，方便自己和其他人查看，以便理解程序的。

2. 注释的写法

```java
/**
*这是一个文档注释，通常用在类和方法上方
*/

public class HelloWorld {
public static void main(String[] args){
//这是一个单行注释，有效范围是从//开始到当前行结尾
    
	System. out. println("HelloWorld");
/*
这是一个
多行注释
*/
	System. out. println("HelloWorld");
	}
}
```

3. 特点

- 注释不影响程序运行
- 注释只作用在写代码阶段，编译后的class文件中
  已经没有注释了，所以注释不会影响程序的执行。

二、字面量

1. 概念：程序中能直接书写的数据

2. 分类

|      分类      |                   描述                    |                         书写格式示例                         |                         关键注意事项                         |
| :------------: | :---------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      整数      |          表示没有小数部分的整数           | 十进制：`26`、`-100`、`0` <br>八进制：以`0`开头，如`012`<br>十六进制：以`0x`/`0X`开头，如`0x1A`（\ |  程序中默认是十进制，八进制 / 十六进制需加前缀，不能随意写   |
|      小数      |          表示有小数部分的数值）           | `18.9`、`-3.14`、`5.0`<br>科学计数法：`1.23e4`（即 12300）、`4.5e-2`（即 0.045） |         必须包含小数点（如`5`是整数，`5.0`才是小数）         |
|      字符      |       表示单个字符（如性别、符号）        | 用**单引号**包裹单个字符：`'A'`、`'a'`、`'1'`、`'+'`、`' '`（空格字符） | 单引号内必须只有 1 个字符（如`'AB'`错误)<br>特殊字符需用 “转义符`\`”，如换行`'\n'`、制表符`'\t'`、单引号`'\''` |
|     字符串     |  表示多个字符组成的文本（如姓名、标语）   | 用**双引号**包裹字符序列：`"Hello World"`、`"Java基础"`、`""`（空字符串） | 必须用双引号, 双引号内可包含 0 个或多个字符（空字符串合法）  |
|     布尔值     |     表示 “真” 或 “假”（用于逻辑判断）     |          仅两个固定值：`true`（真）、`false`（假）           | 必须**小写**（如`True`、`FALSE`都是错误的），不能用`1`/`0`代替（区别于 C 语言） |
|      空值      | 表示 “没有引用任何对象”（仅用于引用类型） |                            `null`                            | 必须小写（`Null`错误）<br>不能直接用于基本类型（如`int a = null`错误，仅能用于`String s = null`等引用类型） |
| 特殊字符字面量 |                如字符转义                 | 字符转义符：`'\n'`（换行）、`'\\'`（表示单个反斜杠）``\t``(表示缩进)、`'\u4E2D'`（Unicode 字符 “中”） |         需记住常用转义符，避免因特殊字符导致语法歧义         |

三、变量

1. 概念：变量（variables）就是内存中的一块区域，用于储存和管理数据

2. 格式：`数据类型 变量名称 = 数据；`   `int age = 18;`

3. 作用：
   - **存储临时数据**：承接程序运行中的中间结果（如计算`1+2`时，将结果`3`存入变量`sum`）；
   - **便于数据复用和灵活修改**

4. 变量里数据存储的原理

   - 底层逻辑：计算机只能识别二进制

     计算机硬件（如内存芯片）本质是 “数字电路”，无法直接存储我们日常使用的十进制数字（如 6、10）、字符（如 'a'）等，只能通过 **0（不通电）和 1（通电）**，这两种符号组成的 “二进制” ，就是计算机唯一能直接识别的 “语言”。

   - 字符数据的存储（ASCII 字符集）

     对于字符（如 'a'、'A'），计算机无法直接转换为二进制，需先通过**ASCII 字符集**（美国信息交换标准代码）给每个字符分配一个唯一的 “十进制编号”，再将编号转换为二进制存储。

5. 数据单位

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018170619966.png" alt="image-20251018170619966" style="zoom:50%;" />



6. Java的基本数据类型

|    大类    |    包含的具体类型    |  关键字   | 内存占用 |          数据范围（核心特点）           |
| :--------: | :------------------: | :-------: | :------: | :-------------------------------------: |
|  **整型**  |        字节型        |  `byte`   |  1 字节  |               -128 ~ 127                |
|            |        短整型        |  `short`  |  2 字节  |             -32768 ~ 32767              |
|            |     整型（默认）     |   `int`   |  4 字节  | -2³¹ ~ 2³¹-1（约 ±21 亿，日常开发首选） |
|            |        长整型        |  `long`   |  8 字节  |   -2⁶³ ~ 2⁶³-1（约 19位数，超大整数）   |
| **浮点型** |     单精度浮点型     |  `float`  |  4 字节  |  精度约 6-7 位有效数字（需加`f`后缀）   |
|            | 双精度浮点型（默认） | `double`  |  8 字节  |         精度约 15-17 位有效数字         |
| **字符型** |        字符型        |  `char`   |  2 字节  |                0 ~ 65535                |
| **布尔型** |        布尔型        | `boolean` |  1 字节  |       `true`（真）/ `false`（假）       |

```java
byte b = 10;
// byte b2 = 128; // 越界了，报错

short s = 20;
int i = 30;
// 注意：随便写一个整数字面量默认是int类型的，334254235555这个数据虽然没有超过long的范围，但是超过了int的范围，所以报错

// 如果希望334254235555这个是long类型，需要显示的指定，加上L或者L
long l1 = 334254235555L;
long l = 40;

// 2. 浮点型
// 注意：随便写一个浮点数字面量默认是double类型的，如果希望1.1是float类型的，必须加上f或者F
// float f2 = 1.1;
float f = 1.1f;
double d = 2.2;

// 3. 字符型
char c = 'a';

// 4. 布尔型
boolean flag = true;
```



四、关键字和标识符

1. 关键字(Keywords)

- 在Java中，关键字是指被编程语言本身预留的、具有特殊意义的单词，它们用于定义程序的结构、控制流程或者数据类型等。

- 开发者不能将关键字用作变量名、方法名或其他标识符。

- 例如：
  class: 用于定义一个类。

  public: 访问修饰符，表明其后的元素可以被任何其他类访问。

  if、else、while、for 等：用于控制程序的流程。

  void: 表示方法不返回任何值

  true、false: 布尔类型的字面值，表示真或假。

- Java中有大约50个这样的关键字，你需要逐渐熟悉它们。

2. 标识符(Identifiers)

- 标识符是程序员自定义的名称，用于给变量、方法、类、包等命名。标识符的规则如下：
  1. 以字母(a- z，A- Z)，美元符号（$），或者下划线（_）开头。数字不能作为标识符的后续。
  2. 区分大小写，myVariable和MyVariable是两个不同的标识符。
  3. 不能与Java中的关键字重名。

- 合法的标识符：myVariable, myVariable123, CalculateTotal, specialValue

### 第二节 方法

一、方法

1. 概念：方法是一种用于执行特定任务或操作的代码块，代表一个功能，它可以接收数据进行处理，并返回一个处理后的结果。

2. 格式

   ```java
   public static 返回值类型 方法名(形参列表) {
       // 方法体：处理数据的代码
       return 结果; // 若返回值类型非void，必须有return
   }
   
   eg:
   public static int max(int a , int b){
   	int max = a > b ? a : b;return max;
   }
   
   ```

   |    组成部分     |                           作用说明                           |                           注意事项                           |
   | :-------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
   | `public static` |                          方法修饰符                          |                                                              |
   |   返回值类型    | 声明方法最终返回数据的类型（如`int`、`String`）<br>无返回值则写`void` | 若声明为`void`，方法内**不能写`return 数据`**（可写单独`return;`直接结束方法）<br>若声明为具体类型，方法内**必须有`return 数据`**，且数据类型需匹配 |
   |     方法名      |      方法的 “功能标识”（如`getSum`、`printHelloWorld`）      |       不能用关键字（如`int`、`class`），不能以数字开头       |
   |    形参列表     |              声明方法需接收的数据；无参数则留空              |   形参仅为 “占位符”，不赋值；调用时需传 “实参”（真实数据）   |
   |     方法体      |                      实现功能的核心代码                      |          逻辑需围绕 “方法的核心任务”，避免冗余代码           |

3. 方法重载

- 方法重载是 Java 中**多态性的一种体现**，指在**同一个类中**，允许存在**多个方法名称相同，但形参列表不同**的方法。这些方法在调用时，JVM 会根据传入的参数（类型、个数、顺序）自动匹配对应的方法，无需记忆不同功能的方法名，极大提升了代码的可读性和易用性。

```java
public static void printVariable(int a) {
	System. out. println(a);
}

public static void printVariable(String str) {
	System. out. println(str);
}

public static void printVariable(int a, String str) {
	System. out. println(a);
	System. out. println(str);
}
```

-  为什么 “可以” 重载？

​	JVM 在调用方法时，会通过 **“方法签名”** 唯一识别方法。

​	Java 中 “方法签名” 的定义是：**方法名 + 形参列表（类型、个数、顺序）**

​	由于重载方法的 “方法签名” 不同（形参列表不同），JVM 能精准区分，不会出现调用冲突，因此允许重载。

- 为什么 “需要” 重载？

​	重载的核心价值是 **“简化调用，提升可读性”**，避免为相似功能定义不同名称的方法（如 `printInt`、`printString`、`printDouble`）。

4. 方法中可变参数（Varargs）

- 就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：`数据类型... 参数名`（如`int... numbers`）
- **本质**：对内是**数组**，Java 会自动将传入的参数封装为数组，因此可通过数组的操作方式（如索引、遍历、`length`属性）获取参数。
- 优点:可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。常常用来灵活的接收数据。
- 注意:
  - **数量限制**：一个方法的形参列表中**只能有 1 个可变参数**（若有多个，Java 无法区分参数归属，存在二义性）。
  - **位置限制**：可变参数必须放在形参列表的**最后一位**（若放前面，后续固定参数无法确定接收范围，导致编译报错）

二、类型转换

1. 自动类型转换

- 类型范围小的变量，可以直接赋值给类型范围大的变量。Java会自动完成转换

- 支持的转换方向

  `byte`（1 字节） < `short`（2 字节）/ `char`（2 字节） < `int`（4 字节） < `long`（8 字节） < `float`（4 字节） < `double`（8 字节）


- **注意**：虽然 `float`（4 字节）和 `long`（8 字节）的字节数不同，但 `float` 是浮点数，可表示的范围远大于 `long`（例如 `float` 可表示 `1.0e38`，而 `long` 最大仅为 `9e18`）。因此 `long + float` 的结果为 `float`，而非 `long`。

- 常见自动转换场景：

  - `byte` → `int`：如 `byte a = 12; int b = a;`（

  - `int` → `double`：如 `int c = 20; double d = c;`（结果为 `20.0`，浮点型自动补小数位）

  - `char` → `int`：如 `char ch = 'A'; int num = ch;`（`'A'` 的 ASCII 码是 65，自动转为整数 65）

2. 强制类型转换（显式转换）

- **类型范围大的变量，不能直接赋值给类型范围小的变量**，必须通过 “强制语法” 声明，强制将大范围数据 “压缩” 到小范围类型中。

- 语法格式

  ```java
  // 目标类型 变量名 = (目标类型) 源变量/源数据;
  
  byte b = (byte)a;
  ```
- 常见使用场景
  - `int → byte`：如 `int a = 20; byte b = (byte) a;`

    （20 在 byte 范围（-128~127）内，转换后仍为 20）

  - `double → int`：如 `double c = 3.14; int d = (int) c;`

    （直接丢弃小数位，结果为 3，非四舍五入）

  - `long → int`：如 `long e = 1500L; int f = (int) e;`

    （1500 在 int 范围（-2³¹~2³¹-1）内，转换后仍为 1500）

3. 表达式的自动类型提升

- 在 Java 中，当不同数据类型的变量或值参与运算组成**表达式**时，会触发 “自动类型提升” 机制 —— 即**小范围数据类型会自动转换为大范围数据类型后再参与运算**
- 最终表达式的结果类型由表达式中的 “最高数据类型” 决定。
- 这一机制的核心目的是**避免运算过程中出现数据精度丢失**，同时明确表达式结果的类型，为后续变量赋值、方法返回等操作提供依据。

- **注意： byte、short、char 三种类型的 “特殊提升”**

  `byte`、`short`、`char` 这三种类型在参与表达式运算时，**不会直接互相转换**，而是会**先自动提升为 int 类型**，再参与后续运算（即使运算双方都是这三种类型）

三、输入输出

1. 输出（Output）

- **定义**：将程序中的数据以可见形式展示出来，是程序与用户的 “信息输出通道”。
- `System.out.print()`/`System.out.println()`（控制台打印）；

2. 输入（Input）

- **定义**：将外部数据（如用户操作）传递给程序，实现程序与用户的 “交互”，避免数据 “写死” 在代码中。
- 常见形式
  - 基础阶段：**键盘输入**；
  - 进阶阶段：网页表单填写、摄像头捕捉、文件读取等。

3. 键盘输入的实现：Scanner API

​	Java 中实现键盘输入需依赖**JDK 自带的 Scanner 类**（属于 Java API），核心是 “调用已封装好的工具，无需自己编写底层逻辑”。

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018180832752.png" alt="image-20251018180832752" style="zoom:50%;" />

- 什么是 API？

  - 全称：**应用程序编程接口（Application Programming Interface）**；

  - 通俗理解：其他程序员（如 Sun 公司）写好的程序 / 工具类，放在 JDK 的 “核心类库” 中，供开发者直接调用（Java 开发中 90% 以上技术都是调用 API）；

四、运算符

1. 算术运算符：用于执行基本的数学运算（加减乘除、取余等）

| 运算符 |                           功能说明                           |                示例                 |
| ------ | :----------------------------------------------------------: | :---------------------------------: |
| `+`    | 1. 数值相加；<br>2. 字符串拼接（若有一个操作数是字符串，会将其他操作数转为字符串） |         `5+3` / `"Hello"+2`         |
| `-`    |             数值相减；也可表示负数（单目运算符）             |            `5-3` / `-5`             |
| `*`    | 数值相乘（注意：不能用`×`符号，视频中特别强调程序中必须用`*`） |                `5*3`                |
| `/`    | 1. 整数除法：结果只保留整数部分（无四舍五入）<br>2. 浮点数除法：结果保留小数 |         `10/3`  /  `10.0/3`         |
| `%`    |           计算除法后的余数（结果符号与被除数一致）           |          `10%3` / `-10%3`           |
| `++`   |                        操作数自身加 1                        | `int a=3; System.out.println(a++);` |
| `--`   |                        操作数自身减 1                        | `int a=3; System.out.println(--a);` |

- 注意：++、--如果在变量前后单独使用是没有区别的，如果不是单独使用（如在表达式中、或同时有其它操作），放在变量前后会存在明显区别
  ```java
  //在变量的前面，先对变量+1、-1，再拿变量的值运算。
  int a = 10;
  int rs = ++a;	（先加再用）
      
  //在变量的后面，先拿变量的值运算，再对变量的值+1、-1
  int b = 10;
  int rs = b++;（先用再加）
  ```

  

2. 赋值运算符

用于将右侧的值赋给左侧变量，可分为**基本赋值**和**复合赋值**（结合算术 / 位运算的简化写法）。

| 运算符 |    名称    |    示例    |  等价写法   |
| :----: | :--------: | :--------: | :---------: |
|  `=`   |  基本赋值  | `int a=5;` |             |
|  `+=`  |  加后赋值  |   `a+=3`   | `a = a + 3` |
|  `-=`  |  减后赋值  |   `a-=3`   | `a = a - 3` |
|  `*=`  |  乘后赋值  |   `a*=3`   | `a = a * 3` |
|  `/=`  |  除后赋值  |   `a/=3`   | `a = a / 3` |
|  `%=`  | 取余后赋值 |   `a%=3`   | `a = a % 3` |
- 注意：扩展的赋值运算符隐含了强制类型转换



3. 比较运算符（关系运算符）

用于比较两个值的关系，结果**只能是`true`（成立）或`false`（不成立）** ，常用于`if`、`for`等条件判断。

| 运算符 | 功能说明                                                     | 示例                    | 结果                            |
| ------ | ------------------------------------------------------------ | ----------------------- | ------------------------------- |
| `==`   | 判断两个值是否相等（注意：引用类型比较的是 “地址”，基本类型比较的是 “值”） | `5==3` / `"abc"=="abc"` | false /true（字符串常量池特性） |
| `!=`   | 判断两个值是否不相等（与`==`相反）                           | `5!=3`                  | true                            |
| `>`    | 判断左侧值是否大于右侧值                                     | `5>3`                   | true                            |
| `<`    | 判断左侧值是否小于右侧值                                     | `5<3`                   | false                           |
| `>=`   | 判断左侧值是否大于或等于右侧值                               | `5>=5`                  | true                            |
| `<=`   | 判断左侧值是否小于或等于右侧值                               | `5<=3`                  | false                           |

4. 逻辑运算符

用于连接多个布尔表达式（`true`/`false`），执行逻辑判断，结果仍为布尔值

核心是 “短路特性”（提高效率）。

| 运算符 | 功能说明                                                     | 短路特性                    | 示例           | 结果  |
| ------ | ------------------------------------------------------------ | --------------------------- | -------------- | ----- |
| `&&`   | 两侧表达式**都为`true`** 时，结果才为`true`；否则为`false`   | 左侧为`false`时，右侧不执行 | `(5>3)&&(2<4)` | true  |
| `||`   | 两侧表达式**至少一个为`true`** 时，结果为`true`；都为`false`时才为`false` | 左侧为`true`时，右侧不执行  | `(5<3)||(2<4)` | true  |
| `!`    | 对布尔值取反（单目运算符，只有一个操作数）                   | 无短路（仅操作一个值）      | `!(5>3)`       | false |
| `^`    | 逻辑异或，比较两个表达式结果是否相同,相同为false，不同为true | 无短路                      | `2>1^3>1`      | false |

5. 位运算符（操作二进制位）

直接对整数的**二进制位**进行运算，常用于底层开发（如网络通信、硬件控制），日常业务开发中较少直接使用。

| 运算符 | 名称       | 功能说明                                                     | 示例（以`6`的二进制`0110`为例）                | 结果（二进制→十进制）        |
| :----: | :--------: | :----------------------------------------------------------: | :--------------------------------------------: | :--------------------------: |
| `&`    | 按位与     | 对应位**都为 1**时，结果位为 1；否则为 0                     | `6 & 3`（3 是`0011`）                          | `0010`→2                     |
| `      | `          | 按位或                                                       | 对应位**至少一个为 1**时，结果位为 1；否则为 0 | `6|3`  | `0111`→7 |
| `^`    | 按位异或   | 对应位**不同**时，结果位为 1；相同则为 0（同 0 异 1）        | `6 ^ 3`                                        | `0101`→5                     |
| `~`    | 按位取反   | 对所有位取反（0 变 1，1 变 0，包括符号位）                   | `~6`（6 是`000...0110`）                       | `111...1001`→-7              |
| `<<`   | 左移       | 所有位向左移动 n 位，右侧补 0（等价于乘以`2^n`，效率高）     | `6 << 2`（左移 2 位）                          | `011000`→24                  |
| `>>`   | 右移       | 所有位向右移动 n 位，左侧补 “符号位”（正数补 0，负数补 1，等价于除以`2^n`） | `6 >> 2`（右移 2 位）                          | `0001`→1                     |
| `>>>`  | 无符号右移 | 所有位向右移动 n 位，左侧补 0（不考虑符号位，结果始终为非负） | `-6 >>> 2`                                     | 正数（具体值取决于整数位数） |

6. 三元运算符（三目运算符）

​	Java 中**唯一的三目运算符**，用于简化条件判断

​	格式为：`条件表达式 ? 表达式1 : 表达式2`。

- 若为`true`，执行并返回`表达式1`的结果；
- 若为`false`，执行并返回`表达式2`的结果。

- **注意**：`表达式1`和`表达式2`的**数据类型必须一致**（或可自动转换）。

  ```java
  int a = 5, b = 3;
  int max = (a > b) ? a : b; // 条件成立，返回a的值
  System.out.println(max); // 输出：5
  ```



### 第三节 程序流程控制

一、分支结构

1. if分支结构

```java
public class IfTempDemo {
    public static void main(String[] args) {
        int temp = 5; // 假设当前温度
        // 多分支判断温度区间
        if (temp < 0) {
            System.out.println("温度过低，注意防冻！");
        } else if (temp >= 0 && temp <= 10) {
            System.out.println("温度较低，建议穿外套！"); 
        } else {
            System.out.println("温度适宜，正常穿着即可！");
        }
    }
}
```

2. switch分支结构

- 通过比较**具体值是否相等**来决定执行哪条分支，本质是 “值匹配型” 分支结构，适用于固定值判断场景。case之后的值不允许重复

```java
switch(表达式) {
    case 值1:
        // 值1匹配时执行的代码
        break; // 跳出switch分支（关键，避免穿透）
   
    case 值2:
        // 值2匹配时执行的代码
        break;
    
        // ... 更多case
    default:
        // 所有case不匹配时执行的代码（可选，无需break）
}
```

**注意：**

- 表达式支持的类型有限

  - **支持的类型**：`byte`、`short`、`int`、`char`（基础类型）；`String`（JDK7 + 支持）、枚举（JDK5 + 支持）；
  - **不支持的类型**：`double`、`float`（小数在计算机中存储不精确，无法精准匹配）；`long`（取值范围过大，开发中极少用于分支判断）。

- 不可随意省略 break（否则触发穿透性）

  - **省略 break 的后果**：执行完当前`case`代码后，会继续执行下一个`case`的代码（无论值是否匹配），直到遇到`break`或`switch`结束



3. 穿透性的合理应用

​	穿透性原理：当`case`块后**没有 break**时，程序会 “穿透” 到下一个`case`，继续执行其代码，即使下一个`case`的值与表达式不匹配。

​	当多个 case 的执行逻辑完全相同时，可**利用穿透性合并代码**，减少重复。

```java
//示例（合并相同逻辑）：
//需求：周一至周四提示 “工作日”，周五提示 “整理代码”，周六至周日提示 “打游戏”。

String week = "周三";
switch(week) {
    case "周一":
    case "周二": // 无break，穿透到“周三”的case
    case "周三":
    case "周四": // 无break，穿透到下方代码
        System.out.println("工作日");
        break;
    case "周五":
        System.out.println("整理代码");
        break;
    case "周六":
    case "周日": // 无break，穿透到下方代码
        System.out.println("打游戏");
        break;
}
// 输出结果：工作日（周一至周四均执行同一逻辑，代码更简洁）
```

#### 二、循环结构

```java
for (初始化语句; 循环条件; 迭代语句) {
    // 循环体语句（需重复执行的代码）
}



int i = 0;
while (i < 3) {
    System.out.println("Hello World");
    i++;
}

//避免死循环：必须在循环体或循环外更新循环变量（如i++、principal更新），确保循环条件最终能变为false；
//初始化语句位置：while 循环的初始化语句在循环外，若需多次复用循环变量，需注意变量作用域；

// 1. 初始化语句
int i = 0;
do {
    System.out.println("Hello World");
    i++;
} while (i < 3);
```

 三种循环（for/while/do-while）的区别

|   循环类型    |    执行顺序    | 循环体执行次数 |                           适用场景                           |
| :-----------: | :------------: | :------------: | :----------------------------------------------------------: |
|   for 循环    | 先判断，后执行 |   0 次或多次   |        明确知道循环次数（如 “循环 3 次”“循环到 100”）        |
|  while 循环   | 先判断，后执行 |   0 次或多次   | 不清楚循环次数，仅知道循环终止条件（如 “直到输入‘退出’为止”） |
| do-while 循环 | 先执行，后判断 |   1 次或多次   | 必须先执行 1 次循环体，再根据结果决定是否重复（如抢票、菜单交互） |

#### 三、break和continue

- break：跳出并结束当前所在循环的执行。
- continue：用于跳出当前循环的当次执行，直接进入循环的下一次执行。
- 注意事项
  break：只能用于结束所在循环，或者结束所在switch分支的执行。
  continue：只能在循环中进行使用。



##### 数组定义

- Java 数组是**引用类型**（存储在堆内存），必须先 “声明 + 初始化” 才能使用，不允许直接操作内存地址，语法上强调 “类型一致性” 和 “安全性”。

```java
// 1. 静态初始化（简化版）：直接赋值，长度=元素个数（3）
int[] arr1 = {10, 20, 30}; 

// 2. 静态初始化（完整版）：显式用new，适合方法返回场景
int[] arr2 = new int[]{40, 50, 60}; 
public static int[] getArray() {
    return new int[]{1,2,3}; // 必须用完整版，不能直接return {1,2,3}
}

// 3. 动态初始化：指定数组类型和长度
// 元素默认初始化（int默认0，String默认null）
int[] arr3 = new int[5]; 
arr3[0] = 100; // 后续手动赋值，下标范围0~4
```





## 第三章 面向对象编程

### 第一节 类和对象

- **对象**：一种**特殊的数据结构**，用于存储 “一个具体事物的完整数据”，从而 “代表该事物”，让程序更贴近现实世界。
  - 关键特点：对象不能 “凭空创建”，必须基于 “模板” 生成（区别于数组可直接定义）。

- **类**：对象的 “模板 / 设计图”，定义了 “该类型对象能存储哪些数据”（即变量 / 属性）。
  - 类的结构：包含 “类名” 和 “属性（变量）”，属性需与事物的特征对应（如明星类需定义`String name`、`int age`、`double height`等）。

```java
// 类名首字母大写，需与事物类型对应（如明星类用Star）
public class 类名 {
    // 定义属性（变量）：存储该类型对象的特征数据
    数据类型 属性名1;
    数据类型 属性名2;
    // ... 更多属性
}
```

```java
//示例：定义明星类

public class Star {
    // 明星的属性：姓名、年龄、性别、身高、体重
    String name;   // 姓名（字符串类型）
    int age;       // 年龄（整数类型）
    String gender; // 性别（字符串类型）
    double height; // 身高（浮点型）
    double weight; // 体重（浮点型）
}
```



- 创建对象

```
类名 对象名 = new 类名();
```

```java
  // 1. 创建测试类（含main方法，程序入口）
  public class Test {
      public static void main(String[] args) {
          // 2. 基于Star类创建对象S1（代表王祖贤）
          Star S1 = new Star();
          // 3. 给S1的属性赋值（对象名.属性名 = 值）
          S1.name = "王祖贤";
          S1.age = 58;
          S1.gender = "女";
          S1.height = 172.0;
          S1.weight = 50.5;
  
          // 4. 同理创建对象S2（代表杨幂）并赋值
          Star S2 = new Star();
          S2.name = "杨幂";
          S2.age = 38;
          S2.gender = "女";
          S2.height = 171.0;
          S2.weight = 52.0;
  
          // 5. 访问对象属性（验证数据）
          System.out.println(S1.name); // 输出：王祖贤
          System.out.println(S2.age);  // 输出：38
      }
  }
```

- 关键注意事项

1.  **类与对象的关系**：类是 “模板”（抽象概念），对象是 “模板的实例”（具体事物）；一个类可创建无数个对象（如 Star 类可创建 S1、S2、S3...）
2.  **属性赋值与访问**：必须通过 “对象名.属性名” 操作（如`S1.name`），不同对象的属性互不干扰（S1 的 age 修改不会影响 S2 的 age）。

- 对象的内存原理：JVM 中的 “空间分配与引用逻辑”

  程序实际上是在内存中的 JVM虚拟机中运行的，虚拟机为了更好的执行程序，将内存分为三块：方法区、栈内存、堆内存。对象在 JVM（Java 虚拟机）中的存储位置和执行流程，核心是 **“三区域协作”**（）：

  | 内存区域 |          功能作用          |                         存储内容示例                         |
  | :------: | :------------------------: | :----------------------------------------------------------: |
  |  方法区  | 存放 class文件，类模板信息 | `Student`类的定义（包含`name`、`chinese`、`math`属性的结构） |
  |  栈内存  |  存放局部变量 和 main方法  | 局部变量：`main`方法中的`s1`、`s2`（仅存对象地址，不存实际数据）<br>方法执行：`main`方法、`printTotalScore()`方法执行时入栈，执行完出栈 |
  |  堆内存  |     存放实际创建的对象     | `new Student()`创建的对象（包含`name`、`chinese`、`math`的具体值，默认值为`null`/0）<br>对象内置 “**类地址**”：指向方法区中`Student`类的模板，确保知道自己由哪个类生成 |

  <img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018195607868.png" alt="image-20251018195607868" style="zoom:80%;" />

  关键执行流程（以`Student s1 = new Student();`为例）：

  1. **加载类模板**：JVM 先将`Student`类加载到**方法区**，确认对象的 “数据结构”；
  2. **创建局部变量**：在`main`方法（位于栈内存）中开辟空间，存储变量`s1`；
  3. **生成对象数据**：在**堆内存**中开辟一块区域，存储`Student`对象的实际数据（默认值），并记录 “指向方法区`Student`类的地址”；
  4. **建立引用关系**：将堆内存中对象的 “地址” 赋值给栈内存的`s1`，此时`s1`通过地址 “引用” 堆中的对象（类似 “钥匙对应房间”）；
  5. **操作数据**：当执行`s1.name = "波妞";`时，通过`s1`的地址找到堆中对象，修改`name`属性的值（即 “填表” 过程）。



### 第二节 类的具体语法

#### 2.1 构造器

1. 概念：构造器（constructor）是 Java 类中一种**特殊的 “方法”**，专门用于对象的创建与初始化

2. 特征

- **无返回值声明**：无需写`void`或具体数据类型（如`int`、`String`），连`return`语句也省略（若写`return`，也只能是`return;`，不能带值）。
- **名称与类名完全一致**：例如`Student`类的构造器，名称必须是`Student`（大小写敏感，如`student`会报错）。
- **属于类的 “专属成分”**：不能独立调用，仅在创建对象时由 JVM 自动调用

```java
// Student类
public class Student {
    // 1. 无参数构造器（无参构造）
    public Student() {
        System.out.println("无参构造器执行");
    }

    // 2. 有参数构造器（有参构造）- 可接收名字和年龄
    public Student(String name, int age) {
        System.out.println("有参构造器执行");
        this.name = name; // 为对象属性赋值
        this.age = age;
    }

    // 类的属性
    private String name;
    private int age;
}
```

3. 作用

- **触发对象创建**：配合`new`关键字使用时，JVM 会先在内存中创建对象，再自动调用构造器（构造器本身不创建对象，仅负责初始化）。
- **初始化对象属性**：通过有参构造器，可在创建对象时直接为属性赋值，避免 “创建对象后逐个点属性赋值” 的重复代码。

```java
//无参构造器
Student t1 = new Student();
t1.name = "石轩";
t1.age = 22;
t1.sex = '男';

//有参构造器
Student t2 = new Student(n:"dlei", a: 18, s:'男');
```

4. 注意事项

- 类默认就自带了一个无参构造器
- 如果为类定义了有参数构造器，类默认的无参数构造器就没有了。还想用无参数构造器，就必须自己手写一个无参数构造器出来。
- **构造器重载**：一个类中可定义多个构造器，只要 “形参列表不同”（参数个数、类型、顺序有一个不同），即构成 “构造器重载”，满足不同场景的对象初始化需求。

#### 2.2 this关键字

1. 概念：`this`是**方法内部的隐式变量**（无需手动定义，默认存在于**非静态方法**中），存储的是**调用当前方法的对象的内存地址**。哪个对象调用this，this就拿到哪个对象

2. 基础作用：访问对象成员


- 通过`this`可以直接访问当前对象的**成员变量**（对象的属性，如`name`、`age`），语法为`this.成员变量名`。
- 隐含规则：若方法中无局部变量与成员变量重名，直接写 “成员变量名” 等效于 “`this.成员变量名`”（**本质是编译器默认补充`this`**）。

```java
class Student {
    String name; 
    public void printName() {
        System.out.println(this.name); 
        // 等效于直接写name（无重名时）
    }
}

// 调用时
Student s1 = new Student();
s1.name = "张三";
s1.printName(); // 输出“张三”（this指向s1，访问s1的name）
```

3. 核心作用：解决变量名冲突

- 当**方法的局部变量（如形参）与对象的成员变量同名**时，会触发 “就近原则”（局部变量优先级更高），导致无法直接访问成员变量。此时必须通过`this`明确指定 “访问成员变量”，解决冲突。

```java
//场景 1：普通成员方法中的参数与成员变量重名

class Student {
    String name; 
    public void printHobby(String name) { 
        System.out.println(name + "喜欢" + name); 
    }
}


//解决方式（用this指定成员变量）：
public void printHobby(String name) {
    System.out.println(this.name + "喜欢" + name); 
}
//// this.name：成员变量（对象的名字）；name：局部变量（形参，爱好）
// 调用后输出“汪苏泷喜欢唱歌”（正确）
```



```java
//场景 2：构造器中的参数与成员变量重名（标准用法）

//构造器的核心作用是 “初始化对象成员变量”，若形参名与成员变量名一致必须用this赋值。


//错误示例（赋值无效，成员变量仍为 null）：
class Student {
    String name;
    int age;
    public Student(String name, int age) {
        name = name; // 局部变量赋值给自身（无效）
        age = age;   // 局部变量赋值给自身（无效）
    }
}


//正确示例（用this赋值成员变量）：
public Student(String name, int age) {
    this.name = name; // 形参name赋值给成员变量this.name
    this.age = age;   // 形参age赋值给成员变量this.age
}
// 调用构造器初始化
Student s = new Student("张三", 18);
System.out.println(s.name);
```



#### 2.3 封装

- 面向对象的三大特征：封装、继承、多态
- **封装**是面向对象编程中的一个核心概念，它涉及到将数据（属性）和代码（方法）绑定到一起，形成一个独立的单元或对象。

1. 概念理解
   - 类是封装：将对象的**数据（成员变量）** 和**数据处理逻辑（成员方法）** 封装在同一类中，形成独立的 “功能单元”。
   - 方法是封装：将特定功能的代码块封装成方法，对外提供调用入口，隐藏实现细节

2. 封装的设计规范：合理隐藏，合理暴露
   - 封装的核心原则是 “隐藏内部敏感信息，暴露安全的操作接口”
   - 合理隐藏：使用**`private`关键字**修饰成员变量，被`private`修饰的成员变量，**仅能在当前类内部直接访问**，其他类无法通过 “对象.变量名” 直接操作，避免外部随意赋值导致数据非法
   - 合理暴露：提供安全的访问接口，隐藏成员变量后，需通过**公开的方法**对外提供 “赋值” 和 “取值” 的接口，同时可在接口中添加数据校验逻辑，保证数据合法性

```java
public class Student {
	String name;
	// 1、如何隐藏：使用private关键字(私有，隐藏)修饰成员变量，就只能在本类中被访问，其他任何地方不能直接访问。
	private int age;
	private double chinese;
	private double math;
    
	// 2、如何暴露(合理暴露)：使用public修饰(公开)的get和set方法合理暴露
	public void setAge(int age) {//为年龄赋值
		if(age>0&& age<200){
				this. age= age;
			} 
        else{
			System. out. println("您赋值的年龄数据非法！");
		}
	}
    
    
	public int getAge() {//获取年龄
		return age;
	}
}
```



#### 2.4 Javabean 实体类

1. 概念：实体类（又称 Java Bean）是 Java 中一种**特殊的类**，专门用于封装数据（仅负责数据的 “存” 和 “取”），不包含复杂的业务逻辑处理，是项目开发中存储和传递数据的核心载体（类似 “数据容器”）

2. 要求：
   - 类中的成员变量全部私有，并提供public修饰的getter/setter方法
   - 类中需要提供一个无参数构造器，有参数构造器可选

3. 实体类的作用

   - **封装数据**：将零散的数据（如学生的姓名、成绩）封装成一个 “对象”，便于数据的统一管理和传递（如方法参数、返回值只需传递一个对象，而非多个单独变量）。
   - **数据存取**：通过 Get/Set 方法严格控制数据的读写，避免非法数据（如后续可在`setChinese()`中加 “成绩必须在 0-100 之间” 的校验）。
4. 关键应用场景：分层思想（数据与业务逻辑分离）

   - **缺点**：若在实体类中直接写业务逻辑（如计算学生总成绩、打印成绩），会导致 “数据存储” 和 “业务处理” 耦合，代码难以维护（如修改成绩计算规则时，需改动实体类）。

   - 解决方案：分层设计

     - **数据层**：实体类（如`Student`）仅负责存储数据，不写任何业务方法；
     - **业务层**：单独创建 “业务处理类”（如`StudentOperator`/`StudentService`），专门处理实体类的业务逻辑（如计算总成绩、打印成绩）；
     - **交互方式**：将实体类对象传递给业务类，由业务类通过 Get 方法获取数据并处理（解耦数据和业务）。

```java
// 1. 实体类：仅存数据
public class Student {
    private String name;
    private double chinese;
    private double math;
    // Get/Set方法 + 无参/有参构造器（略）
}

// 2. 业务类：仅处理业务
public class StudentOperator {
    // 接收要处理的学生对象
    private Student student;
    // 通过构造器接收实体类对象
    public StudentOperator(Student student) {
        this.student = student;
    }
    // 业务方法1：计算总成绩
    public double calculateTotal() {
        return student.getChinese() + student.getMath();
    }
    // 业务方法2：打印成绩信息
    public void printScore() {
        System.out.println(student.getName() + "总成绩：" + calculateTotal());
    }
}

// 3. 测试类：使用分层逻辑
public class Test {
    public static void main(String[] args) {
        // ① 创建实体类对象（存数据）
        Student s = new Student("波妞", 95, 100);
        // ② 创建业务类对象，传入实体类
        StudentOperator operator = new StudentOperator(s);
        // ③ 调用业务方法（处理数据）
        operator.printScore(); // 输出：波妞总成绩：195.0
    }
}
```



#### 2.5 static

1. 概念：`static`翻译为 “静态”，仅为语法标识，无实际语义，可修饰**成员变量**和**成员方法**
2. **核心作用**：区分 “属于类的资源” 和 “属于对象的资源”，解决 “数据共享” 与 “内存优化” 问题（避免重复存储相同数据）。

3. 成员变量的两种类型

|      对比      |           静态变量（Static Variable）           |             实例变量（Instance Variable）             |
| :------------: | :---------------------------------------------: | :---------------------------------------------------: |
|    **别称**    |                     类变量                      |                       对象变量                        |
|   **修饰符**   |                    `static`                     |                      无`static`                       |
|    **归属**    |                 属于**类本身**                  |                   属于**每个对象**                    |
|  **内存特性**  | 类加载时仅创建 1 份，存储在**堆内存的静态区域** | 每个对象创建时单独分配 1 份，存储在对象的堆内存空间中 |
| **数据共享性** |        只有一份数据，被类的全部对象共享         |           每个对象的数据独立，修改互不影响            |

4. 访问规则

- 静态变量的访问

​	推荐方式：通过类名.静态变量名访问（符合 “归属类” 的特性，语法清晰）

​	`Student.schoolName = "北京大学";`  (schoolName 为静态变量)

- 实例变量的访问

​	唯一方式：通过对象名.实例变量名访问（实例变量属于对象，必须先创建对象才能分配内存）

​	`Student s2 = new Student(); s2.age = 20;`（age 为实例变量）

5. 应用场景

- **当数据只需 1 份，且需要被所有对象共享或全局访问时，定义为静态变量**。

```java
//典型场景 1：统计对象创建次数

//需求：统计`User`类共创建了多少个对象。

1. 在User类中定义静态变量count（初始值 0），用于记录对象数量；

   public class User {
       // 静态变量：统计对象总数
       public static int count = 0;
       
       // 构造器：每次创建对象时自动调用，count自增1
       public User() {
           count++; // 同一类中访问静态变量可省略“类名.”
       }
   }

2. 测试类中创建对象，通过类名访问count获取结果：

   public class Test {
       public static void main(String[] args) {
           new User(); // count=1
           new User(); // count=2
           new User(); // count=3
           System.out.println("User类创建的对象总数：" + User.count); 
           // 输出3
       }
   }


   

//原理：构造器在每次`new`对象时必调用，静态变量`count`自增后保持唯一值，所有对象共享该计数。
```

- 其他常见场景

  - 存储全局配置（如数据库连接地址、系统版本号）；

  - 工具类的共享常量（如`Math.PI`，`Integer.MAX_VALUE`）；

  - 单例模式中的实例（确保全局仅 1 个对象）。

6. static修饰方法

|        对比        |                   静态方法（static 修饰）                    |                  实例方法（无 static 修饰）                  |
| :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      归属对象      |                 属于**类本身**，所有对象共享                 |              属于**单个对象**，每个对象独立持有              |
|      访问方式      |                    推荐：`类名.方法名()`                     |     只能通过`对象名.方法名()`访问，直接用类名访问会报错      |
|    是否依赖对象    |               不依赖对象，无需创建对象即可调用               |               依赖对象，必须先创建对象才能调用               |
| 访问成员变量的权限 | 只能访问**静态变量**，无法直接访问实例变量（因实例变量属于对象，静态方法调用时可能无对象） | 可访问**实例变量**和**静态变量**（实例方法关联对象，能获取对象的实例数据） |
|    核心使用场景    |              实现 “独立功能”（不依赖对象数据）               |            实现 “对象行为”（依赖对象的专属数据）             |

- 当方法仅用于完成**独立功能**，不需要访问对象的实例变量 / 实例方法时，定义为静态方法。

  优势：调用无需创建对象，节省内存，访问更便捷。

- 当方法是**对象的行为**，需要访问对象的实例变量（如对象的属性值）时，必须定义为实例方法。



7. main 方法为何是静态方法？

   Java 程序的入口`main`方法（`public static void main(String[] args)`）设计为静态方法，核心原因：

   - `main`方法是程序启动的第一个方法，启动时还未创建任何对象；
   - 静态方法可直接通过`类名.main()`调用（JVM 底层自动执行），无需依赖对象，确保程序能快速启动。



- C++ 与 Java `main`的核心区别（避免混淆）
- C++ 程序**必须且只能有一个`main`函数**（全局唯一），这是编译器和操作系统识别程序入口的唯一标准；
- 与 Java 不同：Java 的`main`方法是 “类的成员”，而 C++ 的`main`函数是**全局函数**（不隶属于任何类，C++ 支持面向对象，但`main`函数本身是 “全局级” 的，

|    对比    |                     C++ `main`函数                     |                Java `main`方法                 |
   | :--------: | :----------------------------------------------------: | :--------------------------------------------: |
   |  归属关系  |               全局函数（不隶属于任何类）               |      类的静态成员方法（必须定义在类内部）      |
   |  数量限制  |            程序必须且只能有 1 个`main`函数             |   一个项目可有多个`main`方法（需指定入口类）   |
   |  语法格式  | 仅支持`int main()`或`int main(int argc, char* argv[])` | 固定为`public static void main(String[] args)` |
   |   返回值   |             必须返回`int`（反馈执行状态）              |               无返回值（`void`）               |
   | 访问修饰符 |     无访问修饰符（全局函数无`public/private`概念）     |       必须用`public`（确保 JVM 可访问）        |
   |  静态修饰  |       无需`static`（本身是全局函数，不依赖对象）       |   必须用`static`（JVM 无需创建对象即可调用）   |

9. 静态方法的应用：工具类（Util）

   核心应用场景是**工具类设计**，解决通用功能的代码复用问题，调用方便。 

   - **定义**：工具类是包含多个**静态方法**的类，每个方法对应一个通用功能（如生成验证码、数据格式转换、文件操作等）；
   - **核心特征**：无需创建对象，直接通过 “类名。方法名 ()” 调用，提高代码复用性和开发效率。

- 工具类设计示例（以验证码工具类为例）

   ```java
   // 验证码工具类（命名规范：功能+Util，如VerificationCodeUtil）
   public class VerificationCodeUtil {
       // 1. 私有化构造器：禁止外部创建对象（工具类无需实例化）
       private VerificationCodeUtil() {
           // 空实现，仅用于私有化
       }
   
       // 2. 静态方法：生成指定长度的验证码
       public static String generateCode(int length) {
           // 逻辑：生成包含数字、字母的随机验证码
           String chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
           StringBuilder code = new StringBuilder();
           for (int i = 0; i < length; i++) {
               int index = (int) (Math.random() * chars.length());
               code.append(chars.charAt(index));
           }
           return code.toString();
       }
   }
   
   // 调用方式（无需创建对象）
   public class Test {
       public static void main(String[] args) {
           // 生成4位验证码
           String code4 = VerificationCodeUtil.generateCode(4);
           // 生成6位验证码
           String code6 = VerificationCodeUtil.generateCode(6);
           System.out.println(code4); // 示例输出：A3F7
           System.out.println(code6); // 示例输出：B92K7P
       }
   }
   ```

- 工具类设计的关键规范

   - **规范 1：私有化构造器**

     工具类无需创建对象，私有化构造器可**禁止外部通过`new`关键字实例化**，避免内存浪费（如 JDK 自带的`Math`类、`Arrays`类均私有化了构造器）。

   - **规范 2：方法全部静态化**

     所有功能方法用`static`修饰，确保外部可直接通过类名调用，无需依赖对象。

   - **规范 3：命名清晰**

     类名遵循 “功能 + Util”
     
     

10. 注意事项

- 静态方法中可以直接访问静态成员，不可以直接访问实例成员。
- 实例方法中既可以直接访问静态成员，也可以直接访问实例成员。
- 实例方法中可以出现 this关键字，静态方法中不可以出现 this关键字的。



11. 综合小项目

```java
//Movie.java
package com.itheima.movieDemo;

public class Movie {
    //实体类，需要提供get和set方法
        private int id; //编号
        private String name;
        private double price;
        private String actor;


        public Movie() {}

        //定义一个有参构造器
        public Movie(int id,String name,double price,String actor)
        {
            this.id=id;
            this.name=name;
            this.price=price;
            this.actor=actor;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public double getPrice() {
            return price;
        }

        public void setPrice(double price) {
            this.price = price;
        }

        public String getActor() {
            return actor;
        }

        public void setActor(String actor) {
            this.actor = actor;
        }


}

//MovieOperator.java
package com.itheima.movieDemo;

import java.util.Scanner;

public class MovieOperator {
    private Movie[] movies;//传入要操作的Movie数组对象

    public MovieOperator(Movie[] movies) {
        this.movies=movies;
    }
    /*
    数组属于引用数据类型——Movie[]
    movies这个变量本身不存储数组的所有元素，只存储数组在「堆内存」中的起始地址。
    因此，通过new MovieOperator(movies)传递数组时
    本质是把「数组的地址」传给了MovieOperator类的构造器。
    */

    public void printAllMovies() {
        for(int i=0;i<movies.length;i++)
        {
            Movie m=movies[i];
            System.out.println(m.getId()+"\t"+m.getName()+"\t"+m.getPrice()+"\t"+m.getActor()+"\t");
        }
    }

    public void searchMovieById() {
        System.out.println("请输入电影id");
        Scanner sc=new Scanner(System.in);
        int id=sc.nextInt();
        Movie m=movies[id-1];
        System.out.println(m.getId()+"\t"+m.getName()+"\t"+m.getPrice()+"\t"+m.getActor()+"\t");

    }
}


//Test.java
package com.itheima.movieDemo;

public class Test {
    public static void main(String[] args)
    {
        Movie[] movies=new Movie[6];
        //最开始都是默认值
        //利用数组来封装数据，后续会学习数据库来封装
        movies[0] = new Movie(1, "星际穿越", 9.6, "安妮海瑟薇");
        movies[1] = new Movie(2,"速度与激情8", 9.2,"瑞秋·费尔南多");
        movies[2] = new Movie(3,"夏洛特烦恼", 9.2, "沈腾");
        movies[3] = new Movie(4,"战狼2", 9.2, "吴京");
        movies[4] = new Movie(5,"让子弹飞", 9.2, "姜文");
        movies[5] = new Movie(6,"暗战", 9.2, "王大陆、渣渣辉");

        MovieOperator mo=new MovieOperator(movies);
        mo.printAllMovies();
        mo.searchMovieById();


    }
}

```



### 第三节 继承

1. 概念：通过`extends`关键字，让一个类（子类 / 派生类）与另一个类（父类 / 超类）建立**父子关系**，子类可直接使用父类的非私有成员（成员变量及成员方法），无需重复编写。
   - 例：`class Teacher extends People {}` 中，`Teacher`是子类，`People`是父类
   - 继承后，子类的对象是由子类、父类共同完成的

2. 继承的核心优势
- **提高代码重用性**：共性代码在父类写一次，所有子类可直接复用，无需重复编写。
- **减少代码冗余**：子类仅需关注自身独有的属性和方法，代码结构更简洁
- **为多态打基础**：继承是多态的前提，通过父子类关系，可实现 “同一行为的不同表现”。

3. 继承的规则

- **成员访问限制**：子类仅能继承父类的非私有成员（即public/protected修饰的属性和方法），private修饰的成员（父类内部属性）无法直接继承，但可通过父类的public/protected方法（如getter/setter）间接访问。

- **单一继承限制**：Java 中一个子类**只能继承一个父类**（不支持多继承），但支持 “多层继承”（如`class JavaTeacher extends Teacher{}`，`JavaTeacher`间接继承`People`）。

4. 权限修饰符

- 作用：用于**限制类的成员（成员变量、成员方法、构造器）的访问范围**，避免成员被不当访问，是 Java 封装特性的重要体现。

- 访问范围

|    权限修饰符    | 当前类 | 同一个包的其他类 | 其他包的普通类 | 其他包的子类 |       访问范围总结        |
| :--------------: | :----: | :--------------: | :------------: | :----------: | :-----------------------: |
|    `private`     |   ✅    |        ❌         |       ❌        |      ❌       |      仅当前类可访问       |
| 缺省（无修饰符） |   ✅    |        ✅         |       ❌        |      ❌       |      当前包内可访问       |
|   `protected`    |   ✅    |        ✅         |       ❌        |      ✅       | 当前包 + 其他包子类可访问 |
|     `public`     |   ✅    |        ✅         |       ✅        |      ✅       |      任意地方可访问       |

5. 继承的特点

- **单继承**：一个类只能有**一个直接父类**，语法上表现为`class 子类 extends 父类`，不能写`class 子类 extends 父类1, 父类2`（多继承语法直接报错）。
- **支持多层继承**：子类可继承父类，父类可继续继承祖父类，形成 “子类→父类→祖父类” 的层级关系（如`class C extends B`，`class B extends A`，则 C 间接继承 A 的成员）。不支持多继承，Java 不允许一个类同时继承多个直接父类，核心原因是避免 “二义性”
- **子类访问成员的规则--就近原则**：子类访问成员（成员变量、成员方法）时，遵循 “先找自身，再找父类，无则报错” 的顺序，若需强制访问父类成员，需使用`super`关键字。

```java
//访问父类成员变量
class Father {
    String name = "父类名"; // 父类成员变量
}
class Son extends Father {
    String name = "子类名"; // 子类成员变量
    public void show() {
        String name = "局部名"; // 局部变量
        System.out.println(name); // 就近原则：输出“局部名”
        System.out.println(this.name); // 强制访问子类成员变量：输出“子类名”
        System.out.println(super.name); // 强制访问父类成员变量：输出“父类名”
    }
}

//访问父类成员方法
class Father {
    public void run() {
        System.out.println("父类run");
    }
}
class Son extends Father {
    public void run() {
        System.out.println("子类run");
    }
    public void test() {
        run(); // 就近原则：执行子类run()，输出“子类run”
        super.run(); // 强制访问父类run()，输出“父类run”
    }
}

```



- **object类**：java 中**所有类（包括自定义类、系统类）都直接或间接继承 Object 类**，Object 是 Java 类层级结构的顶层父类。Object 类中定义了所有 Java 对象通用的方法（如`hashCode()`、`equals()`、`toString()`、`notify()`等），由于所有类都继承 Object，因此**所有对象都能直接使用这些通用方法**，（例如任何对象都能调用`toString()`打印自身信息）。



6. 方法重写

- 概念：当子类继承父类后，若父类的某个方法**无法满足子类需求**（或子类有更具体的实现），子类可定义一个与父类方法**名称、参数列表完全相同**的方法，覆盖父类的该方法，这个过程称为 “方法重写”。

- **核心逻辑**：子类 “替换” 父类的同名方法，调用时优先执行子类重写后的方法（就近原则）

- 注意事项：

  - 推荐添加`@Override`标志注解
    - **语法校验**：强制要求子类方法的名称、参数列表与父类被重写方法完全一致，不一致则编译器直接报错，避免低级错误。
    - **提高可读性**：明确标记该方法是 “重写父类的方法”，其他开发者可快速识别代码逻辑。
  - 子类重写方法的访问权限（如`public`、缺省）**不能小于**父类被重写方法的权限：

  - 子类重写的方法返回值类型，必须与父类被重写方法的返回值类型一样，或者范围更小。

  - 私有方法`private`和静态方法`static`不能重写

- 应用：子类重写toString（方法）

```java
public class overrideDemo {
    public static void main(String[] args) {
        Student s=new Student("赵明",'a',25);
        System.out.println(s);  //会打印s对象在堆空间中的地址--com.itheima.movieDemo.Student@b4c966a
        System.out.println(s.toString());  //作用相同
        //注意：直接输出对象，默认会调用toString方法，可以省略，返回对象的地址信息
    }

}

class Student{
    private String name;
    private char sex;
    private int age;

    @Override
    public String toString(){
        return "Student{name="+ name + ",sex="+ sex + ",age="+ age +"}";
    }

	//省略get、set函数及构造器
}
```



7. 子类构造器的特点

- 这是 Java 继承的设计逻辑：子类依赖父类的属性和方法，必须先确保父类数据初始化完成，子类才能正常使用继承的资源。

  - **默认调用父类无参构造器**：子类的**所有构造器（无论无参 / 有参）**，在执行自身代码前，会**默认先调用父类的无参构造器**（即使不写`super()`，JVM 也会自动隐式添加在子类构造器的第一行）。

  - **可主动指定调用父类有参构造器**：若父类**没有无参构造器**（或无参构造器被`private`修饰），子类构造器会直接报错，此时必须通过`super(参数)`**显式指定调用父类的有参构造器**，且`super(参数)`必须放在子类构造器的**第一行**。


- 应用场景：高效初始化对象

  通过子类有参构造器调用父类有参构造器，可**一行代码同时初始化父类和子类的属性**，代码更简洁、优雅：

  - 父类（`people`）：提供有参构造器初始化父类属性

```java
    public class People {
        private String name;
        private int age;
        public People(String name, int age) {
            this.name = name;
            this.age = age;
        }
        // getter/setter省略
    }
```

  子类（`teacher`）：通过`super(参数)`调用父类有参构造

```java
    public class Teacher extends People {
        private String skill;
        // 子类有参构造器：先初始化父类，再初始化子类
        public Teacher(String name, int age, String skill) {
            super(name, age); // 调用父类有参构造，初始化name和age
            this.skill = skill; // 初始化子类的skill
        }
        // getter/setter省略
    }
```

  - 调用方式：一行代码创建完整对象

```java
Teacher t = new Teacher("张三", 30, "Java"); // 直接完成所有属性初始化
```

8. this（）语法关键字

- `this()` 是 Java 中的语法关键字，作用是**在当前类的某个构造器中，调用本类的其他构造器（即 “兄弟构造器”）**

```java
// 学校默认为“黑马程序员”
public Student(String name, char sex, int age){
	this(name, sex, age, schoolName:"黑马程序员");
}

public Student(String name, char sex, int age, String schoolName){
	this. name = name;
	this. sex = sex;
	this. age = age;
	this. schoolName = schoolName;
}
```



- `this()` 的使用有严格语法限制，核心规则可总结为 “两个必须、一个不能”：

  | 规则类别 |                           具体要求                           |                           原因解释                           |
  | :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  | 位置要求 |             `this()` 必须写在构造器的**第一行**              | 保证 “先调用兄弟构造器”，而兄弟构造器中若有 `super()`（调用父类构造器），能确保父类优先初始化（Java 规定 “父类对象必须先于子类对象创建”）。 |
  | 共存限制 |    `this()` 与 `super()` **不能同时出现在同一个构造器中**    | 若同时存在，会导致父类构造器被调用两次，违背 “父类对象仅初始化一次” 的原则。 |
  | 调用限制 | `this()` 只能调用**本类的其他构造器**，不能调用父类或其他类的构造器 | `this()` 的设计初衷就是 “复用本类构造逻辑”，跨类调用需用 `super()`（父类）或 `new`（其他类）。 |

### 第四节 多态

#### 4.1 概述

1. 概念：多态是**继承/实现关系下的一种现象**，核心表现为**对象多态**和**行为多态**，是面向对象的最后一大核心特征。
2. 对象多态：同一父类类型的变量，可指向不同子类类型的对象（即 “父类引用指向子类对象”）

```java
// 父类Animal的变量a1，指向子类Wolf的对象
Animal a1 = new Wolf(); 
// 父类Animal的变量a2，指向子类Tortoise的对象
Animal a2 = new Tortoise(); 

//核心原理：编译看左，运行看右
//编译时：检查父类（左边）是否有该方法（如 Animal 是否有 run ()），无则编译报错；
//运行时：实际执行子类（右边）重写后的方法，因此表现出不同效果
```

3. 行为多态：同一父类的方法，在不同子类对象中调用时，表现出不同的执行效果（核心依赖 “方法重写”）

```java
class Animal {
    public void run() {} 
}

class Wolf extends Animal {
    @Override
    public void run() {
        System.out.println("狼跑的贼溜"); 
    }
}
class Tortoise extends Animal {
    @Override
    public void run() {
        System.out.println("乌龟跑的贼慢"); 
    }
}

// 调用同一父类方法，执行效果不同（行为多态）
a1.run(); // 输出“狼跑的贼溜”（实际执行Wolf的run()）
a2.run(); // 输出“乌龟跑的贼慢”（实际执行Tortoise的run()）
```

4. 多态的实现前提：

- **存在继承关系**：父类与子类之间有 extends 关系（如 Animal 与 Wolf、Tortoise）；
- **父类引用指向子类对象**：即 “Animal a = new Wolf ()” 的语法形式（对象多态的体现）；
- **子类重写父类方法**：若无方法重写，调用父类方法时执行效果一致，无法体现行为多态（行为多态的核心依赖）

5. 注意：**成员变量无多态**，只有方法有多态的概念

```java
class Animal {
    String name = "动物"; // 父类变量
}
class Wolf extends Animal {
    String name = "狼"; // 子类变量（与父类同名）
}

// 父类引用指向子类对象
Animal a = new Wolf(); 
System.out.println(a.name); // 输出“动物”（而非“狼”，变量无多态）
```



#### 4.2 优点与不足

1. 优点：
   - 右侧对象解耦合，**便于扩展与维护**
     - **核心逻辑**：多态语法（`父类类型 变量名 = new 子类对象()`）中，“右侧的子类对象” 与左侧的父类变量是 “松耦合” 关系，可灵活替换子类对象，无需修改后续代码。
   - 父类类型形参可接收所有子类对象，扩展性更强
     - **核心逻辑**：定义方法时，若将形参类型设为 “父类类型”，则该方法可接收**所有子类的对象**，无需为每个子类单独定义方法，极大提升代码灵活性。

```java
// 不使用多态：只能接收狼对象
public void go(Wolf w) { 
    w.run(); 
}
// 需额外为乌龟写方法，代码冗余
public void go(Tortoise t) { 
    t.run(); 
}

// 多态写法：父类Animal作为形参，接收所有子类对象
public void go(Animal a) { 
    a.run(); // 执行时自动调用子类重写的run方法（狼跑/乌龟跑）
}
```

2. 不足：**无法直接调用子类独有功能**

```java
class Animal {
    public void run() {} // 父类通用方法
}

class Wolf extends Animal {
    @Override
    public void run() { 
        System.out.println("狼跑的贼溜"); 
    }
    // 子类独有方法：父类中没有
    public void eatSheep() { 
        System.out.println("狼吃羊"); 
    }
}

class Tortoise extends Animal {
    @Override
    public void run() { 
        System.out.println("乌龟跑的贼慢"); 
    }
    // 子类独有方法：父类中没有
    public void shrinkHead() { 
        System.out.println("乌龟缩头"); 
    }
}

//这时再调用子类独有方法会报错，因为“编译看左边，运行看右边”
```



#### 多态下的类型转换

- 用于解决多态下，父类类型的变量无法直接调用子类的独有功能问题。分为自动类型转换和强制类型转换

|     类型     |                             定义                             |            语法            |                   特点 / 适用场景                   |
| :----------: | :----------------------------------------------------------: | :------------------------: | :-------------------------------------------------: |
| 自动类型转换 | 子类对象赋值给父类类型变量，是多态的默认实现形式（“小范围→大范围”） | `Animal a = new Turtle();` | 编译 / 运行均无异常，无需手动处理；用于构建多态基础 |
| 强制类型转换 | 将父类类型的变量 “强制转回” 子类类型，需显式声明目标子类类型 |  `Turtle t = (Turtle) a;`  |       需手动写转换语法；用于调用子类独有功能        |

- 注意事项
  - 存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。
  - 运行时，如果发现对象的真实类型与强转后的类型不同，就会报错 -- **类型转换异常(Class Cast Exception)**。

- 为避免`ClassCastException`，Java 官方建议：**强制类型转换前，先通过`instanceof`判断对象的真实类型**，确认一致后再转换

- `instanceof`判断 “某个对象的真实类型” 是否为 “指定类（或其子类）”，返回`boolean`值（`true`/`false`）。

  ```java
  // 格式：对象变量 instanceof 目标类
  if (a instanceof Turtle) {
      // 确认a真实类型是Turtle，再强转
      Turtle t = (Turtle) a;
      t.shrinkHead(); // 安全调用子类独有功能
  } else if (a instanceof Wolf) {
      Wolf w = (Wolf) a;
      w.eatSheep(); // 调用Wolf的独有功能（吃羊）
  }
  ```
