#java基础

1. 如何理解OOP面向对象

OOP面向对象是一种以对象为核心的编程思想，将现实事务抽象成程序中的对象，并给对象定义一系列的属性和行为，通过对象之间的交互来实现业务逻辑，而非像面向过程那样按 “步骤 / 流程” 线性编写代码。这种思想的核心是 “**高内聚、低耦合**”：每个对象只负责自己的职责（内聚），对象之间通过接口交互，而非直接操作对方的内部数据（低耦合）。让代码更易维护、更易扩展。

核心特点：

封装：将对象的属性（数据）和行为（方法）包裹在类中，对外隐藏内部的实现细节，只暴露统一的访问接口（如get/set方法，业务方法）。类是一种封装，方法也是一种封装

继承：让一个类（子类 / 派生类）复用另一个类（父类 / 基类）的属性和方法，同时可以扩展自己的特有逻辑。Java 中通过`extends`实现，且只支持单继承（但可通过接口实现多继承效果）。

多态：同一行为在不同的对象上表现出不同形态，核心是“父类引用指向子类对象”+“方法重写”

java如何实现OOP思想？

类和对象，访问控制（封装如何合理暴露），extends关键字，多态，**子类访问成员的规则--就近原则**：子类访问成员（成员变量、成员方法）时，遵循 “先找自身，再找父类，无则报错” 的顺序，若需强制访问父类成员，需使用`super`关键字。

概念：当子类继承父类后，若父类的某个方法**无法满足子类需求**（或子类有更具体的实现），子类可定义一个与父类方法**名称、参数列表完全相同**的方法，覆盖父类的该方法，这个过程称为 “方法重写”。



2. 重载（Overload）和重写（Override）有什么区别？

重载（Overload）和重写（Override）是 Java 中实现多态的两种核心方式，区别主要在于

- 定义的位置不同：重载是同一个类中多个方法间的关系，方法名相同但参数列表不同；重写是子类与父类（或者接口与实现类）之间的关系，子类重新实现父类中已有的方法

- **方法签名要求不同**

  重载要求**方法名相同，参数列表必须不同**（包括参数个数、类型、顺序）

  重写要求**方法名、参数列表、返回值类型必须完全一致**，且子类方法的访问修饰符不能比父类更严格，抛出的异常范围不能比父类更大。私有方法`private`和静态方法`static`不能重写

- **绑定时期不同**

  重载是**编译期绑定**，也叫静态多态，编译器在编译阶段就根据传入的参数类型确定要调用的方法；

  重写是**运行期绑定**，也叫动态多态，JVM 在程序运行时才根据对象的实际类型确定要调用的方法。

- **设计目的不同**

  重载的目的是**方便同一类中同一行为的不同参数适配**，比如 `System.out.println()` 支持传入字符串、整数等不同类型的参数；

  重写的目的是**让子类定制父类的行为**，实现多态核心，比如父类 `Animal` 有 `makeSound()` 方法，子类 `Dog` 重写为 “汪汪叫”，`Cat` 重写为 “喵喵叫”。



3. 接口和抽象类有什么区别？

接口和抽象类是 Java 实现抽象的两种核心方式，区别主要在于：

- 设计定位不同

  抽象类核心是抽取一组**相关类的共性特征**，既包含共性属性也包含共性方法，侧重代码复用和继承关系，体现的是 “is-a” 的关系（比如 Animal 抽象类，Dog 子类是一种 Animal）；

  接口是 “纯抽象的行为规范”，核心只定义**一组行为标准**，不关注类的共性属性，只关注类能做什么，侧重行为约束和解耦扩展，体现的是 “can-do” 的关系（比如 Runnable 接口，只要类实现它，就具备可运行的行为）。

-  核心语法规则不同

  - 成员变量：抽象类可以定义普通成员变量（比如 String name），也支持静态变量、常量；而接口中的成员变量**默认且只能是 public static final 修饰的常量**，无法定义普通变量。

  - 方法类型：抽象类可同时包含抽象方法、普通非抽象方法、静态方法；接口在 JDK8 + 后，默认方法是抽象方法，也支持定义 default 默认方法和 static 静态方法，但所有方法默认都是 public 修饰，不能用 private/protected。

  - 继承 / 实现规则：子类通过 extends 关键字继承抽象类，**Java 中只能单继承**；类通过 implements 关键字实现接口，**一个类可以同时实现多个接口**，接口之间也能通过 extends 实现多继承。

    

4. 解释一下深拷贝和浅拷贝

深拷贝和浅拷贝是 Java 中对象拷贝的两种方式，核心区别在于**是否复制对象的引用类型成员**

- 深拷贝：不仅复制对象本身和基本数据类型属性，还会递归复制所有引用类型属性指向的对象（即新对象的引用属性指向全新的内存地址，与原对象的引用属性完全独立）
- 浅拷贝：只复制对象本身（基本数据类型属性直接复制值），但对于引用类型属性（如 List、自定义对象），仅复制其引用地址（即新对象和原对象的引用属性指向同一个内存地址）；



5. 什么是自动拆装箱,int和Integer有什么区别

是 JDK5 引入的语法糖，核心是**编译器自动完成基本数据类型与对应包装类的转换**，无需手动调用方法`intvalue（）`和`valueof（）`,因为集合框架（List、Map 等）只能存储引用类型（Object 子类），没有自动拆装箱时，存储 int 需要手动封装为 Integer，取出时又要手动拆箱，代码繁琐且易出错；

int 和 Integer 的核心区别

1. **数据类型归属不同**：
   - int 是**基本数据类型**，不属于对象，直接存储数值，占用 4 字节；
   - Integer 是 int 的**包装类**（引用数据类型），是 Object 的子类，存储的是对象引用（指向堆中存储数值的对象）。

2. **存储位置与缓存机制不同**：

- int 值存储在栈（局部变量）或堆（成员变量），无缓存；
- Integer 对象：① 通过`new Integer(10)`创建的对象，每次都在堆中新建；② 通过自动装箱 /`Integer.valueOf(10)`创建的对象，会复用`-128~127`范围内的缓存对象（JVM 默认缓存区间），比如`Integer a = 10; Integer b = 10;`，`a == b`为 true；超出范围则新建对象，`==`判断为 false。



6. sleep和wait方法的区别

sleep 和 wait 是 Java 中用于线程暂停的两个核心方法

1. 归属类不同

- sleep 是`java.lang.Thread`类的**静态方法**，直接通过`Thread.sleep(毫秒数)`调用，属于线程自身的行为；
- wait 是`java.lang.Object`类的**成员方法**，需通过对象锁（如`obj.wait()`）调用，依赖对象的监视器锁（monitor），所有对象都可调用。

2. 释放锁机制不同（核心区别）

- sleep：线程执行 sleep 时，释放cpu给其它线程，**不会释放持有的对象锁**，只是让线程进入 TIMED_WAITING 状态，休眠时间到后自动恢复就绪状态；比如同步代码块中调用 sleep，其他线程仍无法获取该锁；
- wait：线程执行 wait 时，**会立即释放持有的对象锁**，让线程进入 WAITING/TIMED_WAITING 状态，直到被唤醒或超时，重新竞争锁后才能继续执行；这是实现线程间协作的核心特性。

3. 唤醒方式不同

- sleep：无需手动唤醒，**到达设定的休眠时间后自动唤醒**；也可通过`interrupt()`中断 sleep，抛出`InterruptedException`；
- wait：分两种情况：① 无参`wait()`需通过其他线程调用该对象的`notify()`/`notifyAll()`手动唤醒；② 有参`wait(毫秒数)`可超时自动唤醒，也可被`notify()`/`notifyAll()`提前唤醒，同样可被`interrupt()`中断。

4. 使用场景不同

- sleep：适用于**单纯的线程延时执行**，比如定时任务、循环中短暂休眠减少 CPU 占用，不涉及线程间通信；
- wait：适用于**线程间协作 / 通信**，比如生产者 - 消费者模型中，消费者线程无数据时调用 wait 释放锁，生产者生产数据后调用 notify 唤醒消费者，实现线程间的同步。

另外补充：wait 必须在同步代码块 / 同步方法中调用（持有对象锁时），否则抛`IllegalMonitorStateException`；sleep 无此限制



7. #### ==和equals区别

- `==`：是运算符，判断的是 “内存地址是否相同”（即是否为同一个对象）：
  - 对基本数据类型（如 int、char）：直接比较值是否相等；
  - 对引用数据类型（如 String、Object）：比较对象的内存地址，只有指向同一个对象时才返回 true。
- `equals()`：是`Object`类的**成员方法**，默认逻辑和`==`一致（比较内存地址），但可被重写，重写后通常用于判断 “对象的内容是否相等”（而非地址）比如String类。



8. #### String能被继承吗 为什么用final修饰

String 类**不能被继承**，核心原因是 String 类被`final`关键字修饰

String 常被用作 HashMap、HashSet 等集合的键，其哈希值基于字符内容计算后会缓存（`hash`成员变量）。若 String 可被继承，子类修改字符内容会导致哈希值变化，进而引发集合查找、存储异常（比如存进去的键和取出来的键哈希值不一致）；`final`修饰类杜绝了这种风险，保证哈希值一旦计算就稳定。

String 常用于存储敏感信息（如密码、网络地址），不可变性保证其内容不会被恶意篡改；若可继承，子类可能通过重写方法篡改内容，引发安全漏洞

：String 是 Java 中使用最频繁的类之一，`final`修饰让 JVM 可对 String 相关操作（如字符串拼接、常量池复用）做优化

本质是为了**强制保证其不可变性**，进而支撑线程安全、常量池复用、哈希值稳定等核心特性，同时兼顾性能和安全性





9. String buffer和String builder区别

- StringBuffer 和 StringBuilder 都是 Java 中用于处理可变字符串的类,其中的方法和功能完全是等价的，
- 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，会通过加锁保证操作的原子性，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是非线程安全的，多线程同时操作时可能会出现字符串拼接错误，数据丢失等并发问题
- 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低



10. #### final、finally、finalize

- final：修饰符，用于修饰类、变量和方法。修饰类时，说明这个类不可被继承。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，说明方法不能在子类中被重写。
- finally：异常处理机制的一部分，通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM没有强制退出都能执行，可以将释放资源的代码写在finally块中，保证资源被回收，避免内存泄漏。
- finalize：Object类中定义的方法，属于 Java 垃圾回收（GC）机制的一部分。Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理



11. Object类中有哪些常用方法

**object类**：java 中**所有类（包括自定义类、系统类）都直接或间接继承 Object 类**，Object 是 Java 类层级结构的顶层父类。Object 类中定义了所有 Java 对象通用的方法（如`hashCode()`、`equals()`、`toString()`、`notify()`等），由于所有类都继承 Object，因此**所有对象都能直接使用这些通用方法**，（例如任何对象都能调用`toString()`打印自身信息）。

Object 类是 Java 所有类的根父类，所有对象（包括数组）都直接 / 间接继承其方法，核心常用方法有 9 个，

一、核心通用方法

1. **equals(Object obj)**：判断两个对象是否 “相等”，默认实现是比较内存地址（等同于`==`），子类可重写（如 String 重写为比较内容）；
2. **hashCode()**：返回对象的哈希值，默认基于内存地址计算；遵循 “equals 相等则 hashCode 必相等” 的约定，常用于 HashMap 等集合；
3. **toString()**：返回对象的字符串表示，默认格式是 “类名 @哈希值十六进制”，子类重写后可输出业务属性（如 User 类返回 “User {id=1, name=' 张三 '}”）；
4. **getClass()**：返回对象的运行时类（Class 对象），是反射的基础，且方法被 final 修饰，无法重写（如`user.getClass()`获取 User.class）。

 二、线程协作方法（用于多线程通信）

1. **wait()**：让当前线程释放对象锁并进入等待状态，需在同步代码块 / 方法中调用，可被 notify ()/notifyAll () 唤醒；

2. **notify()**：唤醒等待该对象锁的单个线程（随机唤醒）；

3. notifyAll()：唤醒等待该对象锁的所有线程；

   （注：wait () 有重载方法 wait (long timeout)、wait (long timeout, int nanos)，支持超时自动唤醒）

三、对象生命周期相关方法

1. **finalize()**：GC 回收对象前调用，给对象最后释放资源的机会，已过时（JDK9+），不推荐依赖；

 四、克隆方法

1. **clone()**：创建并返回对象的拷贝，默认是浅拷贝；使用前需实现 Cloneable 接口，否则抛 CloneNotSupportedException。



12. 集合体系

Java 集合体系核心是为了存储 / 操作一组对象，整体分为**Collection**（单列集合）和**Map**（双列集合）两大根接口，核心结构和特点如下：

![img](https://i-blog.csdnimg.cn/blog_migrate/3d8f208789483d9d11df9bcd2de32796.png)

一、Collection（单列集合：存储单个元素）

按是否有序、是否可重复分为两大分支：

1. List：有序、可重复，支持索引访问
   - 核心实现：ArrayList（基于数组实现，查询快、增删慢，非线程安全）、LinkedList（基于链表实现，增删快、查询慢）
2. Set：无序、不可重复（基于 equals/hashCode 保证）
   - 核心实现：HashSet（基于 HashMap，哈希表实现，无序）、TreeSet（基于 TreeMap，红黑树实现，自然排序）、LinkedHashSet（继承 HashSet，链表 + 哈希表，有序（插入顺序））。

二、Map（双列集合：存储 key-value 键值对，key 不可重复）

核心实现：

1. HashMap：哈希表实现，key 无序，非线程安全，JDK8 后数组 + 链表 + 红黑树优化，允许 key/value 为 null；
2. Hashtable：哈希表实现，线程安全（方法加 synchronized），性能低，不允许 key/value 为 null；
3. TreeMap：红黑树实现，key 自然排序；
4. LinkedHashMap：继承 HashMap，链表 + 哈希表，key 按插入顺序排序；



13. #### ArrarList和LinkedList区别 

- ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
- 对于随机访问get和set，ArrayList效率优于LinkedList，因为LinkedList要移动指针。
- 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。
  

14. #### HashMap底层是 数组+链表+红黑树，为什么要用这几类结构

HashMap 底层采用 “数组 + 链表 + 红黑树” 的组合结构，核心是**平衡查询、插入、删除的性能**

- 数组：作为基础存储，保证快速定位，数组的核心优势是**通过索引随机访问的时间复杂度为 O (1)**，这是 HashMap 查询高效的基础
- 链表：解决哈希冲突，兼容少量冲突场景，当多个 key 哈希到同一个数组下标时（哈希冲突），链表用于串联这些冲突的键值对：

- 红黑树：优化长链表，降低查询复杂度

  JDK8 引入红黑树，当链表长度超过阈值（默认 8）且数组容量≥64 时，链表转为红黑树，提升查询性能，从原来的O(n)到O(logn)



15. #### HashMap和HashTable区别

1. 线程安全（核心区别）

- HashMap：**非线程安全**，所有方法未加同步锁，多线程并发修改（如同时 put/remove）会引发数据错乱（如死循环、数据丢失），但无锁开销，性能更高；
- Hashtable：**线程安全**，所有核心方法（put/get/remove）都被`synchronized`修饰（全局锁），多线程下能保证操作原子性

2. 空值支持不同

- HashMap：允许`key`为 null（仅一个，因为 key 不可重复）、`value`为 null（多个）；
- Hashtable：不允许`key`或`value`为 null，否则直接抛出`NullPointerException`。（HashSet的底层原理）

3. 性能与优化不同

- HashMap：JDK8 引入 “数组 + 链表 + 红黑树” 结构，链表长度≥8 且数组容量≥64 时转红黑树，查询复杂度从 O (n) 降为 O (logn)；哈希算法引入扰动函数，减少哈希冲突；
- Hashtable：始终基于 “数组 + 链表” 实现，无红黑树优化，哈希算法简单（直接取模），冲突概率更高，且全局锁导致并发性能远低于 HashMap（及 ConcurrentHashMap）。

4. 初始容量与扩容不同
   - HashMap：默认初始容量 16，扩容因子 0.75，扩容时容量翻倍（16→32→64）；
   - Hashtable：默认初始容量 11，扩容因子 0.75，扩容时容量变为 “原容量 ×2+1”（11→23→47）。



16. 线程的创建方式

1. 继承 Thread 类（基础方式）

- 核心：自定义类继承`Thread`，重写`run()`方法（封装线程执行逻辑），通过`start()`方法启动线程（JVM 会调用`run()`，直接调用`run()`只是普通方法执行）；
- 缺点：Java 单继承限制，继承 Thread 后无法继承其他类，耦合度高；

2. 实现 Runnable 接口（推荐基础方式）

- 核心：自定义类实现`Runnable`接口，重写`run()`方法，将该类实例传入`Thread`构造器，通过`Thread.start()`启动；
- 优势：规避单继承限制，线程逻辑与线程对象解耦，更符合面向对象设计；

3. 实现 Callable 接口（带返回值 / 异常处理）

- 核心：自定义类实现`Callable<V>`接口，重写`call()`方法（支持返回值、抛出受检异常），结合`FutureTask`（实现 Runnable）封装，再传入`Thread`启动；
- 优势：可获取线程执行结果（通过`FutureTask.get()`），能处理异常，弥补前两种无返回值的缺陷；

补充：线程池创建（实际开发主流）

以上三种是基础创建方式，实际开发中几乎不用手动`new Thread()`，而是通过`Executors`或`ThreadPoolExecutor`创建线程池（如`Executors.newFixedThreadPool(5)`），将`Runnable/Callable`任务提交给线程池执行；

- 优势：复用线程、控制并发数、避免频繁创建销毁线程的性能开销，是企业级开发的标准做法。



17. #### 线程的状态转换有什么（生命周期）

Java 线程的生命周期核心分为**6 种状态**（定义在`Thread.State`枚举中），状态转换围绕 “启动 - 运行 - 阻塞 - 结束” 展开，核心状态及转换逻辑如下：

![img](https://i-blog.csdnimg.cn/blog_migrate/07a5293c06bac45357d0da0c90d306e9.jpeg)

**核心 6 种状态**

1. **NEW（新建状态）**：线程对象已创建（`new Thread()`），但未调用`start()`方法，此时仅为普通对象，未与操作系统线程绑定；

2. RUNNABLE（可运行状态）：调用`start()`后进入该状态，说明线程已就绪，等待 CPU 调度；

   （JVM 层面不区分就绪 / 运行，统一归为 RUNNABLE）；

3. 运行状态(Running)：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。

4. 阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
  
   - 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
   - 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
   - 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join(）等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
   
5. 死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
  
18. #### Java中有几种类型的流

![img](https://i-blog.csdnimg.cn/blog_migrate/8f2443cd9bc4cd6d5337a1b97bbb30be.png)

![img](https://i-blog.csdnimg.cn/blog_migrate/b2ad5fb7dcbe4cf135a42f29ab74ac4d.png)

按处理数据单位分（最核心分类）

1. **字节流**：以字节（8 位）为单位处理数据，适用于所有类型文件（如图片、视频、二进制文件、文本文件），底层无编码限制；
   - 抽象基类：`InputStream`（输入字节流）、`OutputStream`（输出字节流）；
   - 常用实现：`FileInputStream`/`FileOutputStream`（文件字节流）、`BufferedInputStream`/`BufferedOutputStream`（缓冲字节流）、`ByteArrayInputStream`/`ByteArrayOutputStream`（字节数组流）。
2. **字符流**：以字符（按编码转换，如 UTF-8、GBK）为单位处理数据，仅适用于文本文件，避免字节流处理文本时的编码乱码问题；
   - 抽象基类：`Reader`（输入字符流）、`Writer`（输出字符流）；
   - 常用实现：`FileReader`/`FileWriter`（文件字符流）、`BufferedReader`/`BufferedWriter`（缓冲字符流）、`InputStreamReader`/`OutputStreamWriter`（转换流，字节流→字符流）。



19. #### 请写出你最常见的5个RuntimeException

1. NullPointerException（空指针异常）

- **核心场景**：调用了`null`对象的方法 / 属性，是开发中最高频的异常；
- **示例**：`String str = null; str.length();`（调用 null 的 length () 方法）。

2. ArrayIndexOutOfBoundsException（数组下标越界异常）

- **核心场景**：访问数组时下标超出数组长度范围；
- **示例**：`int[] arr = new int[3]; arr[5] = 10;`（数组长度为 3，下标最大为 2，访问 5 越界）。

3. ClassCastException（类型转换异常）

- **核心场景**：强制类型转换时，两个类型无继承 / 实现关系，转换失败；
- **示例**：`Object obj = "abc"; Integer num = (Integer) obj;`（字符串无法转为 Integer）。

4. IllegalArgumentException（非法参数异常）

- **核心场景**：方法接收到不符合规则的参数（如参数为负数、null 但业务不允许）；
- **示例**：`Integer.parseInt("abc");`（字符串非数字，无法转为整数）、自定义方法中传入负数年龄等。

5. IndexOutOfBoundsException（下标越界异常，子类含 List/Set 等集合越界）

- **核心场景**：访问集合（List/Set 等）时下标超出范围（常用子类`IndexOutOfBoundsException`）；
- **示例**：`List<String> list = new ArrayList<>(); list.add("a"); list.get(1);`（集合仅 1 个元素，下标 1 越界）。

20. 编译时异常

典型示例：

- `ParseException`（日期解析异常，如将格式不匹配的字符串转为`Date`对象）；
- `FileNotFoundException`（文件未找到异常，如读取不存在的文件）；
- `IOException`（IO 流异常，如写入文件时磁盘空间不足）。



20. 对反射的理解

反射是 Java 的核心特性之一，本质是**程序运行时能够获取自身的类信息、调用类的属性 / 方法，甚至创建对象**，突破了编译期的访问限制，是实现框架（如 Spring、MyBatis）的核心底层技术。

Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method;其中class代表的时类对 象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组成部分。

1. **Java 反射机制提供功能**

在运行时判断任意一个对象所属的类。

在运行时构造任意一个类的对象。

在运行时判断任意一个类所具有的成员变量和方法。

在运行时调用任意一个对象的方法

三、核心应用场景

反射是 “框架的灵魂”，日常开发中很少直接写反射，但框架底层大量依赖：

1. **Spring 容器**：通过反射扫描注解（如`@Component`），动态创建 Bean 实例，注入依赖（如`@Autowired`）；
2. **MyBatis**：通过反射将数据库查询结果映射为 Java 实体类对象（封装 ResultSet 到 POJO）；
3. **动态代理**：如 Spring AOP 的 JDK 动态代理，通过反射调用目标方法；
4. **序列化 / 反序列化**：如 JSON 框架（FastJSON、Jackson），通过反射读取 / 设置对象属性；
5. **通用工具类**：如 BeanUtils.copyProperties，通过反射拷贝对象属性。



21. #### 什么是 java 序列化，如何实现 java 序列化

序列化（Serialization）是一种用来处理对象流的机制，指将 Java 对象的**状态（属性值）** 转换为**字节序列**的过程；对应的，反序列化是将字节序列恢复为原有对象的过程。

核心目的：突破对象仅存在于 JVM 内存的限制，实现对象的**持久化**（如存入文件、数据库）或**网络传输**（如分布式系统间的对象通信）—— 因为 JVM 停止 / 进程结束后，内存中的对象会消失，而字节序列可存储 / 传输，反序列化后能还原出与原对象状态一致的新对象。

序 列 化 的 实 现 ： 将 需 要 被 序 列 化 的 类 实 现 Serializable 接 口 ， 该 接 口 没 有 需 要 实 现 的 方 法 ， implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用 ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。



22. Http 常见的状态码

- 200 OK      //客户端请求成功

- 301      Permanently Moved （永久移除)，请求的 URL 已移走。Response 中应该包含一个 Location URL, 说明资源现在所处的位置
- 302      Temporarily Moved  临时重定向
- 400      Bad Request //客户端请求有语法错误，不能被服务器所理解
- 401      Unauthorized //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
- 403      Forbidden //服务器收到请求，但是拒绝提供服务
- 404      Not Found //请求资源不存在，eg：输入了错误的 URL
- 500      Internal Server Error //服务器发生不可预期的错误
- 503      Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常



23. #### GET 和POST 的区别

1. 请求参数位置（核心直观区别）

- GET：参数通过 URL 传递，拼接在 URL 末尾（格式为`?key1=value1&key2=value2`），可直接在地址栏看到,就是把数据放置在 HTTP 协议头中

  示例：

  ```
  https://xxx.com/user?id=1&name=张三
  ```

- POST：参数放在请求体（Request Body）中，不会出现在 URL 里，地址栏不可见；

  示例：URL 仅为`https://xxx.com/user`，参数通过请求体传递（如 form-data、json 格式）。

2. 数据大小与类型限制

- **GET**：受浏览器 / 服务器对 URL 长度的限制（如 Chrome 默认限制 2KB 左右），仅支持 ASCII 字符，无法传输二进制数据（如文件）；
- **POST**：无严格的大小限制（取决于服务器配置，如 Tomcat 默认 8MB），支持任意类型数据（如 json、form 表单、二进制文件），可传输大体积数据（如文件上传）。

3. 安全性（非绝对，仅相对）

- **GET**：参数暴露在 URL 中，易被浏览器缓存、历史记录、网络监控捕获，不适合传输敏感数据（如密码、token）；
- **POST**：参数在请求体中，相对隐蔽（但未加密的 POST 仍可通过抓包获取，敏感数据需配合 HTTPS），适合传输隐私数据。

4. 缓存与幂等性

- **GET**：默认可被浏览器缓存（如刷新页面不会重新发起请求，直接读取缓存），且符合 “幂等性”（多次请求结果一致，无副作用），比如查询数据、分页列表；
- **POST**：默认不被缓存，且非幂等（多次提交可能产生副作用），比如创建订单、提交表单、修改数据（重复提交可能生成多个订单）。



24. #### Cookie 和Session 的区别

Cookie 和 Session 是 Web 开发中实现**状态保持**的核心机制（HTTP 协议无状态，需额外手段记录用户状态）

Cookie 是**服务器发送给客户端浏览器的一小段文本数据**（键值对形式），浏览器会将其保存（内存或本地文件），后续请求同一服务器时，会自动携带该 Cookie 到请求头中，让服务器识别用户。

- 核心特点：存储在客户端（浏览器），大小受限（通常 4KB 以内），可设置过期时间（临时 Cookie 在浏览器关闭后失效，持久 Cookie 可保存到指定时间）。

Session 是**服务器端为每个用户创建的专属存储空间**（本质是服务器内存 / 缓存 / 数据库中的键值对），用于存储用户的会话信息（如登录状态、购物车数据）。

- 核心特点：服务器生成唯一的 SessionID（会话标识），并通过 Cookie（默认）发送给客户端；客户端后续请求携带 SessionID，服务器通过该 ID 找到对应的 Session，从而识别用户；Session 存储在服务器，无大小限制，但会占用服务器资源。

1. 存储位置（核心区别）

- **Cookie**：存储在**客户端浏览器**（本地文件 / 内存），由服务器响应时通过`Set-Cookie`头下发，后续请求时浏览器自动携带 Cookie 到服务器；
- **Session**：存储在**服务器端**（内存 / 数据库 / Redis），服务器为每个用户生成唯一的 SessionID（字符串），并通过 Cookie（默认）或 URL 重写传递给客户端。

2. 数据安全性

   - Cookie：数据暴露在客户端，易被篡改、窃取（如 XSS 攻击窃取 Cookie），仅适合存储非敏感、少量数据（如用户偏好、登录状态标识）；

     可通过设置`HttpOnly`（防止 JS 读取）、`Secure`(仅 HTTPS 传输）、`SameSite`（防止 CSRF）提升安全性，但本质仍在客户端；

- **Session**：数据存储在服务器，客户端仅持有 SessionID，无法直接获取 Session 中的数据（如用户信息、权限），安全性更高，适合存储敏感、核心数据。

3. 存储大小与类型限制

- **Cookie**：有严格限制 —— 单个 Cookie 大小≤4KB，单个域名下 Cookie 数量≤20 个，仅支持字符串类型；
- **Session**：无大小限制（取决于服务器存储能力），可存储任意 Java 对象（如 User、Map），能承载更多、更复杂的数据。

4. 生命周期

- Cookie：生命周期可控：
  - 临时 Cookie：未设置`expires`/`max-age`，浏览器关闭即失效；
  - 持久 Cookie：设置`expires`（绝对时间）/`max-age`（相对秒数），到期前一直保存在客户端；
- Session：默认依赖服务器内存，生命周期由服务器控制：
  - 超时失效：服务器设置 Session 超时时间（如 30 分钟），无请求则自动销毁；
  - 主动销毁：调用`session.invalidate()`可手动清除；
  - 服务器重启：内存中的 Session 会丢失（需结合 Redis 等分布式存储解决）。





- Java的跨平台特性

Java 的 “跨平台” 特性（即 “一次编写，到处运行”，Write Once, Run Anywhere）是其核心优势之一，其实现原理并非直接让 Java 代码与操作系统交互，而是通过**中间层（JVM）** 实现 “平台隔离”，本质是 “Java 代码不直接依赖操作系统，而是依赖统一的 JVM 标准”。

 1.核心支撑：JVM（Java 虚拟机）是跨平台的 “桥梁”

​	Java 跨平台的核心是 **JVM（Java Virtual Machine，Java 虚拟机）**，它是一个 “虚拟的计算机”—— 对 Java 程序而言，JVM 提供了统一的运行环境；对操作系统而言，JVM 是一个普通的可执行程序（如 Windows 上的`jvm.dll`、Linux 上的`libjvm.so`）。

​	

​	很多人会误解 “Java 跨平台是因为 JVM 跨平台”，但实际是：**JVM 本身是 “平台相关” 的，而 Java 程序是 “平台无关” 的**。

- 本质逻辑：微软为 Windows 开发 “Windows 版 JVM”，为 Linux 开发 “Linux 版 JVM”—— 这些 JVM 分别适配了不同系统的 API（如文件操作、内存管理、线程调度），但对外提供的 “字节码执行接口” 是统一的。

	Java 程序只需调用 JVM 提供的统一接口（如`System.out.println()`），无需直接调用 Windows 的`WriteConsole`或 Linux 的`printf`，从而实现 “一次编写，到处运行”。



- 对象的内存原理：JVM 中的 “空间分配与引用逻辑”

	程序实际上是在内存中的 JVM虚拟机中运行的，虚拟机为了更好的执行程序，将内存分为三块：方法区、栈内存、堆内存。对象在 JVM（Java 虚拟机）中的存储位置和执行流程，核心是 **“三区域协作”**（）：

	| 内存区域 |         功能作用         |                         存储内容示例                         |
	| :------: | :----------------------: | :----------------------------------------------------------: |
	|  方法区  |  存放 class，类模板信息  | `Student`类的定义（包含`name`、`chinese`、`math`属性的结构） |
	|  栈内存  | 存放局部变量 和 main方法 | 局部变量：`main`方法中的`s1`、`s2`（仅存对象地址，不存实际数据）<br>方法执行：`main`方法、`printTotalScore()`方法执行时入栈，执行完出栈 |
	|  堆内存  |    存放实际创建的对象    | `new Student()`创建的对象（包含`name`、`chinese`、`math`的具体值，默认值为`null`/0）<br>对象内置 “**类地址**”：指向方法区中`Student`类的模板，确保知道自己由哪个类生成 |

	<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251018195607868.png" alt="image-20251018195607868" style="zoom:80%;" />

	关键执行流程（以`Student s1 = new Student();`为例）：

	1. **加载类模板**：JVM 先将`Student`类加载到**方法区**，确认对象的 “数据结构”；
	2. **创建局部变量**：在`main`方法（位于栈内存）中开辟空间，存储变量`s1`；
	3. **生成对象数据**：在**堆内存**中开辟一块区域，存储`Student`对象的实际数据（默认值），并记录 “指向方法区`Student`类的地址”；
	4. **建立引用关系**：将堆内存中对象的 “地址” 赋值给栈内存的`s1`，此时`s1`通过地址 “引用” 堆中的对象（类似 “钥匙对应房间”）；
	5. **操作数据**：当执行`s1.name = "波妞";`时，通过`s1`的地址找到堆中对象，修改`name`属性的值（即 “填表” 过程）。



- static关键字

1. 概念：`static`翻译为 “静态”，仅为语法标识，无实际语义，可修饰**成员变量**和**成员方法**
2. **核心作用**：区分 “属于类的资源” 和 “属于对象的资源”，解决 “数据共享” 与 “内存优化” 问题（避免重复存储相同数据）。



- main 方法为何是静态方法？

	Java 程序的入口`main`方法（`public static void main(String[] args)`）设计为静态方法，核心原因：

	- `main`方法是程序启动的第一个方法，启动时还未创建任何对象；
	- 静态方法可直接通过`类名.main()`调用（JVM 底层自动执行），无需依赖对象，确保程序能快速启动。



- ArrayList与LinkList

### ArrayList

#### 优点

1. 随机访问（`get(int index)`、`set(int index, E e)`）性能碾压 LinkedList；
2. 遍历效率高（普通 for 循环），缓存友好（连续内存）；
3. 实现简单，底层数组是最基础的数据结构，开销低。

#### 缺点

1. 中间 / 头部增删需移动大量元素，效率低；
2. 扩容时复制数组，存在性能损耗；
3. 预留内存导致空间浪费，大数据量下内存占用更高。

### LinkedList

#### 优点

1. 已知节点的增删操作（如迭代器 `remove()`）无需移动元素，效率高；
2. 无扩容开销，内存按需分配，空间利用率高；
3. 支持双端队列操作，可作为栈、队列、双端队列使用。

#### 缺点

1. 随机访问性能极差，无法直接通过索引定位；
2. 普通 for 循环遍历效率极低，必须用迭代器；
3. 每个节点存储前后指针，内存开销比 ArrayList 大；
4. 非连续内存，缓存命中率低，遍历性能略逊于 ArrayList（迭代器遍历除外）。



- Lambda 能简化的原理：上下文推断

​	Lambda 之所以能省略 “接口声明”“方法名” 等冗余信息，核心依赖 **Java 编译器的上下文推断机制**。通过上下文联动，编译器可自动补全 Lambda 省略的结构，确保代码逻辑正确。



- 线程同步的实现方式



- （1）**测试方法的 4 个强制要求**

  | 要求       | 说明                                                         |
  | ---------- | ------------------------------------------------------------ |
  | 访问修饰符 | 必须为`public`（保证框架可调用）                             |
  | 参数列表   | 必须无参（测试方法无需外部传入参数）                         |
  | 返回值类型 | 必须无返回值（测试结果通过框架报告展示，无需返回）           |
  | 核心注解   | 方法上必须添加`@Test`注解（标记该方法为 JUnit 可执行的测试方法） |

   （2）测试方法的核心逻辑

  测试方法内部需完成 “调用目标方法 + 验证结果”，分为两种场景：

  - **场景 1：验证无返回值方法**（如打印方法）：调用目标方法后，观察控制台输出是否符合预期；

  - 场景 2：验证有返回值方法（如计算、获取索引）：需通过`Assert`类的断言方法验证 “实际结果” 与 “预期结果” 是否一致，核心断言方法为：

    ```java
    // 断言实际结果与预期结果相等，若不相等则测试失败并显示提示信息
    Assert.assertEquals("断言失败提示信息", 预期结果, 实际结果);
    ```

    示例：测试 “获取字符串最大索引” 方法（正确逻辑应为 “长度 - 1”）：

    ```java
    @Test
    public void testMaxIndex() {
        // 1. 调用被测试方法（实际结果）
        int actual = StringUtil.getMaxIndex("ABCDEFG"); // 字符串长度7，正确索引应为6
        // 2. 断言（预期结果=6）
        Assert.assertEquals("获取最大索引业务异常，请检查", 6, actual);
    }
    ```






- 对反射的理解

反射是 Java 的核心特性之一，**允许程序在运行时（而非编译时）获取类的完整信息，并操作类 / 对象的属性、方法、构造器等成员**，无需提前知道类的具体名称。

#### 核心特点

1. **打破封装**：能访问类的私有成员（私有属性、私有方法等），绕过编译期的访问限制；
2. **动态性**：运行时才确定要操作的类，灵活适配不同场景（如框架开发）；
3. **基于 Class 类**：所有类的字节码文件（.class）加载后，JVM 都会为其创建一个`Class`对象，反射的所有操作都基于这个对象。

- **优点**：灵活性极高，是 Spring、MyBatis 等框架的核心底层（如 Spring 的 IOC 动态创建 Bean、MyBatis 的 ORM 映射）；
- **缺点**：破坏封装性、性能略低（运行时解析）、代码可读性下降。

获取 Class 对象的 3 种方式

获取`Class`对象是反射的**第一步**（相当于拿到 “类的钥匙”），共有 3 种常用方式，且三种方式获取的`Class`对象完全相同（内存中唯一）：

|          方式          |                         语法示例                         |                   适用场景                   |
| :--------------------: | :------------------------------------------------------: | :------------------------------------------: |
|       类名.class       |           `Class<Student> c1 = Student.class;`           |       已知类的具体类型，编译期可确定类       |
| Class.forName (全类名) |         `Class.forName("com.itheima.Student");`          | 仅知道类的全路径名（如配置文件中读取的类名） |
|    对象.getClass ()    | `Student s = new Student(); Class<?> c3 = s.getClass();` |    已有类的实例对象，需通过对象反推类信息    |



- 对动态代理的理解

动态代理是 Java 基于**反射**实现的设计模式，核心作用是：**在不修改目标类源码的前提下，动态为目标对象创建一个代理对象，通过代理对象间接调用目标方法，从而在调用前后插入额外逻辑（如日志、权限校验、事务控制）**。

#### 核心特点

1. **动态性**：代理类不是编译期写死的，而是运行时由 JVM 动态生成；
2. **无侵入**：无需修改目标类代码，符合 “开闭原则”；
3. **基于接口**（JDK 动态代理）：目标类需实现接口，代理类和目标类共用同一接口（CGLIB 可代理无接口类）。

#### 两种核心实现方式（简单区分）

| 类型           | 依赖条件           | 底层原理                        |
| -------------- | ------------------ | ------------------------------- |
| JDK 动态代理   | 目标类必须实现接口 | 反射（Proxy+InvocationHandler） |
| CGLIB 动态代理 | 目标类无需实现接口 | 字节码生成（继承目标类）        |

**动态代理的优势？**

- **消除代码冗余**：将 “性能统计” 等通用逻辑抽离到代理中，所有业务方法复用同一套代理逻辑，无需重复编写。
- **职责单一化**：被代理对象仅关注核心业务，非核心功能（如性能统计、日志、事务）由代理统一处理，代码结构更清晰。
- **功能自动增强**：新增业务方法（如`select2()`）时，无需额外编写增强逻辑，代理会自动对新方法生效（只要新方法属于接口定义的方法）。
- **低侵入性**：无需修改被代理对象的代码，即可通过代理新增功能，符合 “开闭原则”（对扩展开放，对修改关闭）。



动态代理与 Spring 框架、AOP 的关联

- **Spring 的本质：代理工厂**
  - 类比：将 Spring 理解为 “高级代理工厂”，开发者将 Java 对象（被代理对象）交给 Spring 管理，Spring 会返回一个 “增强后的代理对象”。
  - 例：若将`UserServiceImpl`交给 Spring，Spring 可自动为其生成代理对象，代理对象可新增 “事务管理、日志记录、权限校验” 等功能，无需开发者手动编写代理代码。
- **AOP（面向切面编程）的底层：动态代理**
  - AOP 思想：将 “性能统计、日志、事务” 等**横切逻辑**（跨越多个业务方法的通用逻辑）抽离为 “切面”，在不修改业务代码的情况下，将切面逻辑 “织入” 到业务方法的指定位置（如方法前、方法后）。

**动态代理是 Spring AOP 的底层实现技术**，Spring AOP 是动态代理的 “上层应用”——Spring 通过封装动态代理（JDK/CGLIB），实现了 AOP 的 “面向切面编程” 能力，让开发者无需手写代理逻辑，就能便捷地实现代码增强。

### 三层关系拆解（极简版）

1. **AOP（面向切面）**：是一种编程思想 / 目标

   核心是将**日志、事务、权限**等通用逻辑（切面）与**业务逻辑**分离，在不修改业务代码的前提下，将通用逻辑 “织入” 到业务方法的执行流程中（如方法执行前 / 后）。

2. **动态代理**：是实现 AOP 的 “技术手段”

   Spring AOP 无法直接实现 “无侵入增强”，必须依赖动态代理：

   - 当目标类有接口时，Spring 用**JDK 动态代理**生成代理对象；

   - 当目标类无接口时，Spring 自动切换为

     CGLIB 动态代理；

     代理对象会拦截目标方法调用，先执行切面逻辑（如日志），再执行原业务逻辑。

3. **Spring 框架**：是 AOP + 动态代理的 “封装者”

   Spring 将动态代理的复杂逻辑封装（如`Proxy`、`Enhancer`等底层 API），提供了`@Aspect`、`@Before`、`@After`等简单注解，开发者只需定义 “切面” 和 “织入点”，Spring 会自动创建代理对象、完成增强逻辑的织入，无需手动处理代理创建、方法拦截等细节。



AOP（Aspect-Oriented Programming，面向切面编程）是 Java 中补充 OOP（面向对象编程）的一种编程思想，核心是**将分散在业务代码中的通用横切逻辑（如日志、事务、权限校验）抽离出来，单独封装为 “切面”，再动态植入到业务方法的指定位置**，实现代码解耦和复用。

### 核心作用

解决 OOP 中 “横切逻辑分散” 的问题：比如每个接口都要加日志、登录校验，若直接写在业务代码里会重复且难维护；AOP 可把这些逻辑抽成独立模块，不修改业务代码就能统一生效。

### 核心概念（以 Spring AOP 为例）

1. **切面（Aspect）**：封装横切逻辑的类（如日志切面、事务切面）；

2. **连接点（JoinPoint）**：程序执行的某个时机（如方法调用前 / 后、异常抛出时）；

3. **切入点（Pointcut）**：指定切面要作用的具体方法（如所有 `com.service` 包下的方法）；

4. 通知（Advice）

	：切面的具体执行逻辑，包括：

	- 前置通知（Before）：方法执行前执行；
	- 后置通知（After）：方法执行后（无论是否异常）执行；
	- 返回通知（AfterReturning）：方法正常返回后执行；
	- 异常通知（AfterThrowing）：方法抛出异常时执行；
	- 环绕通知（Around）：包裹方法执行，可控制方法是否执行。

### 核心实现方式

Spring AOP 基于**动态代理**实现：

- 对实现接口的类，用 JDK 动态代理；
- 对未实现接口的类，用 CGLIB 动态代理；
- 运行时动态生成代理对象，将切面逻辑植入到目标方法中。

### 一句话总结

AOP 是 “无侵入式” 复用通用逻辑的方式，通过 “切面” 抽离横切逻辑，动态植入业务方法，让业务代码只关注核心逻辑，提升代码可维护性。



Bean 声明方式的选择

|            场景            |       推荐        |                        核心注解                        |
| :------------------------: | :---------------: | :----------------------------------------------------: |
| 自定义类（项目内手写的类） |   类上直接标注    | `@Component`、`@Controller`、`@Service`、`@Repository` |
| 第三方类（外部依赖中的类） | 配置类 + 方法标注 |               `@Configuration` + `@Bean`               |



一\ Spring 框架的痛点与 SpringBoot 的诞生

1. Spring 框架的繁琐之处
	- **依赖配置繁琐**：在`pom.xml`中需自行寻找项目所需依赖，还要匹配依赖的配套依赖及对应版本，否则易出现版本冲突。
	- **框架配置复杂**：使用 Spring 开发需在配置文件中进行大量 Bean 声明与配置，导致入门难度大、学习成本高。
2. **SpringBoot 的定位**：Spring 官方在 Spring 4.x 版本后推出 SpringBoot，用于简化 Spring 框架开发（非替代），是目前 Spring 家族子项目中最流行的框架，官方推荐基于其构建 Java 项目以提升开发效率。

二、SpringBoot 简化开发的核心功能

SpringBoot 能简化开发，核心依赖两大底层功能：

- **起步依赖**：解决 Spring 框架中依赖配置繁琐的问题，大幅简化`pom.xml`中依赖配置。
- **自动配置**：简化框架使用时 Bean 的声明与配置，引入起步依赖后，项目常见配置已默认完成，可直接使用（本视频暂未深入讲解，后续展开）。