#### （1）Select 语句完整的执行顺序

1. **FROM/JOIN**：先确定数据源，处理表连接（笛卡尔积、ON 筛选）；
2. **WHERE**：筛选 FROM 阶段的行（排除不满足条件的数据）；
3. **GROUP BY**：按指定字段分组；
4. **HAVING**：对 GROUP BY 分组后的结果集进行过滤；
5. **SELECT**：选取字段（含计算 / 聚合、别名）；
6. **DISTINCT**：去重 SELECT 的结果；

```mysql
select dinstinct 字段 from 表名；
```



7. **ORDER BY**：按字段排序（可使用 SELECT 别名）；

8. **LIMIT/OFFSET**：限制返回行数 / 分页。

简言之：**先找表→筛行→分组→筛组→选字段→去重→排序→限行数**。



#### （2）事务的基本要素（ACID）

1. **原子性（Atomicity）**：事务是不可分割的最小单位，要么全执行，要么全回滚；
2. **一致性（Consistency）**：事务完成时，必须使所有数据都保持一致状态；
3. **隔离性（Isolation）**：多个事务并发执行时，相互隔离、互不干扰；
4. **持久性（Durability）**：事务提交后，修改永久生效，不受故障（崩溃、断电）影响。



#### （3）事务的隔离级别以及事务的并发问题

 一、MySQL 事务隔离级别（由低到高）

1. **读未提交（Read Uncommitted）**：能读取其他事务未提交的数据（脏读），隔离性最差；
2. **读已提交（Read Committed）**：只能读取其他事务已提交的数据，解决脏读，但可能出现不可重复读；
3. **可重复读（Repeatable Read）**：**MySQL 默认级别**，同一事务内多次读取结果一致，解决不可重复读，仍可能有幻读；
4. **串行化（Serializable）**：最高隔离级，事务串行执行，解决并发问题，但性能最差。

```sql
select @@transaction_isolation; // 查看事务隔离级别
```

默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务

 二、事务并发问题（由轻到重）

1. **脏读**：读取到其他事务未提交的、可能回滚的数据；
2. **不可重复读**：同一事务内，多次读同一数据，结果因其他事务提交修改而不同；
3. **幻读**：同一事务内，多次执行同一查询，结果集行数因其他事务插入 / 删除而变化。

简言之：隔离级别越高，并发问题越少，性能越低；默认的可重复读已解决脏读、不可重复读，InnoDB 通过间隙锁进一步降低幻读概率。

三、如何解决？

1. **脏读**：

	最低需设置「读已提交（Read Committed）」隔离级别，或更高。

2. **不可重复读**：

	升级到「可重复读（Repeatable Read）」隔离级别（MySQL 默认），InnoDB 通过多版本并发控制（MVCC）实现，规避其他事务修改带来的不一致。

3. **幻读**：

	- 方案 1：设置最高级别「串行化（Serializable）」，强制事务串行执行，彻底杜绝幻读（但性能损耗大）；
	- 方案 2：保留「可重复读」，InnoDB 通过「间隙锁 + 行锁」（Next-Key Lock）锁定数据范围，阻止其他事务插入 / 删除，大幅降低幻读；



#### （5）MyISAM和InnoDB的区别

MySQL 存储引擎是负责数据存储、检索、更新的方式，不同存储引擎存储的机制是不同的，在一个数据库下的多张表，可以选择不同的存储引擎

|      | MyISAM | InnoDB     |
| ---- | ------ | ---------- |
| 事务 | 不支持 | 支持       |
| 锁   | 表锁   | 表锁、行锁 |
| 外键 | 不支持 | 支持       |

- Memory引擎的表数据是存储在内存中的，访问速度快，但断电会丢失数据，只能将这些表作为临时表或缓存使用，默认是哈希索引



#### （6）聚簇索引和非聚簇索引

**索引(index)**是帮助MySQL**高效获取数据**的**数据结构(有序)**

- B＋树相对于B-Tree区别：

①所有的数据都会出现在叶子节点
②叶子节点形成一个单向链表

- MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能

![](C:\Users\Silence\OneDrive\Pictures\Screenshots\屏幕截图 2025-10-04 124442.png)

索引分类

|   分类   |                     含义                     |           特点           | 关键字  |
| :------: | :------------------------------------------: | :----------------------: | :-----: |
| 主键索引 |           针对于表中主键创建的索引           | 默认自动创建，只能有一个 | primary |
| 唯一索引 |       避免同一个表中某数据列中的值重复       |        可以有多个        | unique  |
| 常规索引 |               快速定位特定数据               |        可以有多个        |    ✕    |
| 全文索引 | 查找的是文本中的关键字，而不是比较索引中的值 |        可以有多个        | fulltxt |

- 在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

1. 聚簇索引（Clustered Index）

	索引与数据行物理存储在一起，索引的叶子节点直接存放整行数据；InnoDB 中默认主键为聚簇索引，无主键则选唯一非空索引，无则隐式生成。

2. 非聚簇索引（Non-Clustered Index）/二级索引

	索引叶子节点仅存主键值（而非整行数据），需通过主键值回表查询（查聚簇索引）才能获取完整数据。

优势:

1、查询通过聚簇索引可以直接获取数据，效率要高

2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的

3、聚簇索引适合用在排序的场合，非聚簇索引不适合



#### （7）mysql什么情况下会索引失效

1. **索引字段做函数 / 运算处理**：如`WHERE SUBSTR(name,1,2)='xx'`、`WHERE age+1=20`；
2. **使用模糊查询前缀 %**：如`WHERE name LIKE '%张三'`（后缀 % 不失效）；
3. **索引字段用 OR 连接（一侧无索引）**：如`WHERE idx_col=1 OR no_idx_col=2`；
5. **违背最左前缀原则**：联合索引`(a,b,c)`，查询仅用`b`/`c`/`b+c`；
6. **用 NOT IN/< > 等否定操作**：优化器易放弃索引走全表；
7. **数据分布极端（如全表数据近似）**：如果MySQL评估使用索引比全表更慢,则不使用索引
8. **IS NULL/IS NOT NULL（视索引类型）**：部分场景（如非空索引查 IS NULL）失效。



（8）B+tree 与 B-tree区别

B-Tree 的每个节点（包括叶子节点）都存储数据，非叶子节点也会存放完整的键值与数据；

而 B+Tree 仅叶子节点存储完整数据（所有数据都在叶子节点），非叶子节点仅存键值作为索引，

且叶子节点通过双向链表相连，范围查询时无需回溯上层节点，更适配数据库 / 文件系统的范围查询、顺序遍历场景

同时 B+Tree 的非叶子节点仅存索引，相同内存下能存储更多索引，降低树的高度，减少磁盘 IO 次数。

MySQL 索引默认用 B + 树，正是利用其范围查询和 IO 高效的特点。



（9）如何处理慢查询

可以通过查询慢查询日志来确认哪些SQL语句需要优化

慢查询的优化首先要搞明白慢的原因是什么?是查询条件没有命中索引?是加载了不需要的数据列?还是数据量太大?

所以优化也是针对这三个方向来的

- 首先分析语句，看看是否加载了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。

- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。

- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。




#### （10）数据库分表操作

目的：解决单表数据量过大（如千万级 +）导致的**查询慢、索引失效、性能下降**等问题，拆分后单表数据量可控。

分库是把单库拆成多库（缓解单库存储 / 连接数压力）

- 垂直分库把将一个数据库的表拆分到不同的库中（每个库的表结构都不一样）
- 水平分库将一个库的数据拆分到多个库中（每个库的表结构都一样）

分表是把单表拆成多表（解决单表索引过大、查询慢问题）

- 垂直分表按字段属性将不同字段拆分到不同表中
- 水平分表将一个表的数据拆分到多个表中

利用数据库分表分库中间件MyCat实现分库分表，它能在应用与数据库之间搭建一层代理，自动处理分表分库的复杂逻辑，让应用无需感知数据的拆分细节。

通过配置文件定义**逻辑表与物理节点间的映射、分片规则**，将对逻辑表的 SQL 解析到对应的物理库表执行，最终合并结果返回；



#### （11）MySQL优化

① 优先优化索引（建合适索引、避免失效，并且定时清理未使用的索引）；

② 简化 SQL 逻辑（减少联表 / 子查询，用 JOIN 替代子查询、避免 SELECT *）；

③ 优化执行计划（用 EXPLAIN 分析，避免all类型的全表扫描）；

④ 控制数据量（分页查询、过滤无关数据）；

⑤ 适配存储引擎特性（InnoDB 用行级锁、避免长事务），最终通过减少全表扫描、索引失效、冗余计算，提升查询 / 更新效率。



（12）如何设计数据库

① 需求分析：梳理业务场景、数据实体（如用户、订单）及关系（一对一 / 一对多 / 多对多）；

② 概念设计：用 ER 图抽象实体、属性、关系，明确主键 / 外键

③ 逻辑设计：按三大范式（字段原子化，非主键字段完全依赖于主键）设计表结构，平衡范式与性能，定义字段类型 / 约束（非空、唯一、索引）；

④ 物理设计：结合存储引擎（如 InnoDB）、索引（B+Tree）、分库分表（高数据量）等优化



- ### MySQL 外键 简单说明

  外键（Foreign Key）是 MySQL 中**用于关联两个表的字段约束**，核心作用是保证关联表的数据不会出现无效、不一致的情况。

  #### 核心概念

  - **主表（父表）**：被参照的表（通常有主键 / 唯一键）；
  - **从表（子表）**：设置外键的表，外键字段的值必须匹配主表的主键 / 唯一键值（或为 NULL）。

  #### 核心作用

  1. **约束数据有效性**：从表插入 / 更新数据时，外键值必须在主表中存在，否则操作失败（比如 “订单表” 的用户 ID，必须是 “用户表” 中已存在的 ID）；
  2. **级联操作（可选）**：可配置主表数据变更时，从表自动同步（如主表删除某用户，级联删除该用户的所有订单）。

  #### 简单示例

  ```sql
  -- 1. 主表：用户表（有主键id）
  CREATE TABLE user (
      id INT PRIMARY KEY,
      name VARCHAR(20)
  );
  
  -- 2. 从表：订单表（设置外键user_id关联用户表的id）
  CREATE TABLE order_info (
      order_id INT PRIMARY KEY,
      goods VARCHAR(50),
      user_id INT,
      -- 定义外键约束
      FOREIGN KEY (user_id) REFERENCES user(id)
      -- 可选级联操作：主表删除时，从表对应数据也删除
      ON DELETE CASCADE
  );
  
  //*no action*（默认），有外键则不允许删除或更新 == restrict
  //set null，set default 
  ```
  
  #### 关键注意事项
  
  1. **存储引擎**：仅 InnoDB 引擎支持外键（MyISAM 不支持）；
  2. **数据类型匹配**：外键字段与主表被参照字段的类型必须完全一致（比如都是 INT）；
  3. **灵活性权衡**：外键会增加数据库开销，高并发场景（如电商）有时会舍弃外键，改由业务代码保证数据一致性。
  
  #### 一句话总结
  
  外键是 MySQL 给表之间加的 “数据关联锁”，确保关联表的数据不会乱，要么匹配主表数据，要么不许动。



####  删除/更新行为

- 添加了外键后，再删除父表数据时产生的约束行为，称删除/更新行为，具体分以下几种

  |        行为         |                             说明                             |
  | :-----------------: | :----------------------------------------------------------: |
  | *no action*（默认） | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与*restrict*一致) |
  |     *restrict*      | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与*no action*一致） |
  |  *cascade*（级联）  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |
  |     *set null*      | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取*null*） |
  |    *set default*    | 父表有变更时，子表将外键列设置成一个默认的值（*Innodb*不支持） |

- 语法：

  ```sql
  alter table 表名 add constraint 外键名称 foreign key （外键名称） references 主表名 （主表字段名）on update cascade on delete cascade;
  
  -- 举例：
  alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade;
  
  alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update set null on delete cascade set null;
  ```





- MySQL体系结构

核心分为**连接层、服务层、存储引擎层、文件系统层**四层

连接层处理客户端连接与用户认证等功能；

服务层完成大部分核心功能（SQL 解析 / 优化、查询缓存、事务管理、权限控制等），是跨存储引擎的通用逻辑层；

存储引擎层真正的负责了MySQL中数据的存储和提取，根据不同的存储引擎实现不同的功能；

文件系统层将数据持久化到磁盘文件（如 InnoDB 的 ibd 数据文件、binlog 二进制日志、redo/undo 日志）

各层解耦且职责明确，支撑 MySQL 的灵活扩展与核心功能实现。



（）innoDB存储引擎的特点

InnoDB 是 MySQL 默认的存储引擎，适用于事务处理和高并发场景设计，

核心特点是、

- 支持 ACID 事务，保证数据操作的原子性与一致性
- 行级锁、基于行而非表加锁，减少并发下的锁冲突，大幅提升高并发读写场景的性能。
- **支持外键约束**，保证数据参照的完整性。
- **聚簇索引设计**：数据与主键索引存储在同一 B + 树中，主键查询效率极高；非聚簇索引回表查询完整数据。
- **崩溃恢复能力**：依托 redo log 实现崩溃后的数据恢复，保证数据持久性；同时支持缓冲池（Buffer Pool），缓存数据与索引，减少磁盘 IO。

补充：相比 MyISAM，InnoDB 写性能稍低，但因事务和行锁特性，相比 MyISAM 更侧重数据一致性与并发安全。是 Java 后端开发中电商、金融等核心业务的首选引擎。



（）MySQL的索引结构

##### 索引结构

MySQL的索引是在**存储引擎层**实现的，不同的存储引擎有不同的结构，主要包含以下几种：

|        索引结构         |                             描述                             |
| :---------------------: | :----------------------------------------------------------: |
|     *B+ Tree* 索引      |        **最常见的索引类型，大部分引擎都支持B+树索引**        |
|       *Hash* 索引       | 底层数据结构是用**哈希表**实现的，只有**精确匹配**索引列的查询才有效，不支持范围查询 |
|  *R-tree*（空间索引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于**地理空间数据类型**，通常使用较少 |
| *Full-text*（全文索引） | 是一种通过建立**倒排索引**，快速匹配文档的方式。类似于Lucene,Solr,ES |

![](C:\Users\Silence\OneDrive\Pictures\Screenshots\屏幕截图 2025-10-04 122931.png)



MySQL的MVCC多版本控制

MVCC（Multi-Version Concurrency Control，多版本并发控制）就是通过维护一个数据的多个版本，使得读写操作没有冲突，是 InnoDB **实现事务隔离**的核心机制

原理（极简版）

1. **数据行版本化**：InnoDB **为每行数据增加隐藏列**（行 ID、事务 ID、回滚指针），事务修改数据时，不会直接覆盖原数据，而是生成新的数据版本，并通过回滚指针关联旧版本；
2. **undo log（回滚日志）**：用于记录数据被修改前的信息,旧数据版本存储在 undo log 中，事务回滚或读取历史版本时，通过回滚指针追溯；
3. **Read View（读视图）**：事务读取数据时，生成 Read View,记录并维护系统当前活跃的事务（未提交的）id，通过对比数据行的事务 ID 与 Read View，判断该版本是否对当前事务可见，只读取 “可见版本”。

这样既能避免读写阻塞，又能保证事务隔离性，是 InnoDB 支持高并发的关键。

> 不同的隔离级别，生成ReadView的时机不同：
>
> - read committed(RC)：在事务中每一次执行快照读时生成ReadView。
> - repeatable read(RR)：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。



()MySQL主从复制

MySQL 主从复制是一种**数据同步机制**，核心是将主库（Master）的更新操作同步到一个 / 多个从库（Slave），

1. **主库记录日志**：主库执行写操作后，将操作语句写入二进制日志（binlog）；
2. **从库拉取日志**：从库通过 IO 线程连接主库，请求获取主库的 binlog，并将其写入本地的中继日志（relay log）；
3. **从库执行日志**：从库的 SQL 线程读取中继日志，逐条执行其中的 SQL 语句，复刻主库的数据变更，保证主从数据一致。

核心作用（面试高频）

- 读写分离：主库负责写操作（增删改），从库负责读操作（查询），缓解单库读写压力；
- 故障容灾：主库故障时，可将切换到从库，减少服务中断时间；

核心作用是读写分离、故障备份，提升数据库并发和可用性。




