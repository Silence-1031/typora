#### （1）Select 语句完整的执行顺序

1. **FROM/JOIN**：先确定数据源，处理表连接（笛卡尔积、ON 筛选）；
2. **WHERE**：筛选 FROM 阶段的行（排除不满足条件的数据）；
3. **GROUP BY**：按指定字段分组；
4. **HAVING**：筛选分组后的结果（仅针对分组聚合值）；
5. **SELECT**：选取字段（含计算 / 聚合、别名）；
6. **DISTINCT**：去重 SELECT 的结果；

```mysql
select dinstinct 字段 from 表名；
```



7. **ORDER BY**：按字段排序（可使用 SELECT 别名）；

8. **LIMIT/OFFSET**：限制返回行数 / 分页。

简言之：**先找表→筛行→分组→筛组→选字段→去重→排序→限行数**。



#### （2）事务的基本要素（ACID）

1. **原子性（Atomicity）**：事务是不可分割的最小单位，要么全执行，要么全回滚；
2. **一致性（Consistency）**：事务执行前后，数据库从一个合法状态到另一个合法状态（数据规则不破坏）；
3. **隔离性（Isolation）**：多个事务并发执行时，相互隔离、互不干扰；
4. **持久性（Durability）**：事务提交后，修改永久生效，不受故障（崩溃、断电）影响。



#### （3）事务的隔离级别以及事务的并发问题

### 一、MySQL 事务隔离级别（由低到高）

1. **读未提交（Read Uncommitted）**：能读取其他事务未提交的数据（脏读），隔离性最差；
2. **读已提交（Read Committed）**：只能读取其他事务已提交的数据，解决脏读，但可能出现不可重复读；
3. **可重复读（Repeatable Read）**：MySQL 默认级别，同一事务内多次读取结果一致，解决不可重复读，仍可能有幻读；
4. **串行化（Serializable）**：最高隔离级，事务串行执行，解决所有并发问题，但性能最差。

### 二、事务并发问题（由轻到重）

1. **脏读**：读取到其他事务未提交的、可能回滚的数据；
2. **不可重复读**：同一事务内，多次读同一数据，结果因其他事务提交修改而不同；
3. **幻读**：同一事务内，多次执行同一查询，结果集行数因其他事务插入 / 删除而变化。

简言之：隔离级别越高，并发问题越少，性能越低；默认的可重复读已解决脏读、不可重复读，InnoDB 通过间隙锁进一步降低幻读概率。

三、如何解决？

1. **脏读**：

	最低需设置「读已提交（Read Committed）」隔离级别，或更高；InnoDB 默认的「可重复读」也可彻底解决（仅读取已提交数据，拒绝未提交脏数据）。

2. **不可重复读**：

	升级到「可重复读（Repeatable Read）」隔离级别（MySQL 默认），InnoDB 通过多版本并发控制（MVCC）保证同一事务内多次读取数据一致，规避其他事务修改带来的不一致。

3. **幻读**：

	- 方案 1：设置最高级别「串行化（Serializable）」，强制事务串行执行，彻底杜绝幻读（但性能损耗大）；
	- 方案 2：保留「可重复读」，InnoDB 通过「间隙锁 + 行锁」（Next-Key Lock）锁定数据范围，阻止其他事务插入 / 删除，大幅降低幻读；
	- 补充：部分场景可通过加锁查询（如`SELECT ... FOR UPDATE`）显式锁定，避免幻读。



#### （5）MyISAM和InnoDB的区别

|          | MyISAM | InnoDB     |
| -------- | ------ | ---------- |
| 事务     | 不支持 | 支持       |
| 锁       | 表锁   | 表锁、行锁 |
| 文件存储 | 3个    | 1个        |
| 外键     | 不支持 | 支持       |



（6）聚簇索引和非聚簇索引

1. 聚簇索引（Clustered Index）

	索引与数据行物理存储在一起，索引的叶子节点直接存放整行数据；InnoDB 中默认主键为聚簇索引，无主键则选唯一非空索引，无则隐式生成。

2. 非聚簇索引（Non-Clustered Index）

	又称二级索引，索引叶子节点仅存主键值（而非整行数据），需通过主键值回表（查聚簇索引）才能获取完整数据。

优势:

1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询(非覆盖索引的情况下)效率要高

2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的

3、聚簇索引适合用在排序的场合，非聚簇索引不适合

劣势;

1、维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(pagesplit)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZETABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片

2、表因为使用uuId(随机ID)作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键

3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值，过长的主键值，会导致非叶子节点占用占用更多的物理空间



#### （7）mysql什么情况下会索引失效

1. **索引字段做函数 / 运算处理**：如`WHERE SUBSTR(name,1,2)='xx'`、`WHERE age+1=20`；
2. **使用模糊查询前缀 %**：如`WHERE name LIKE '%张三'`（后缀 % 不失效）；
3. **索引字段用 OR 连接（一侧无索引）**：如`WHERE idx_col=1 OR no_idx_col=2`；
4. **隐式类型转换**：如字符串索引字段匹配数字（`WHERE phone=13800138000`）；
5. **违背最左前缀原则**：联合索引`(a,b,c)`，查询仅用`b`/`c`/`b+c`；
6. **用 NOT IN/<> 等否定操作**：优化器易放弃索引走全表；
7. **数据分布极端（如全表数据近似）**：优化器判定全表扫描更高效；
8. **IS NULL/IS NOT NULL（视索引类型）**：部分场景（如非空索引查 IS NULL）失效。



（8）B+tree 与 B-tree区别

1. 节点数据存储
	- B 树：非叶子节点、叶子节点都存数据 + 索引；
	- B + 树：仅叶子节点存数据（索引 + 完整数据 / 主键），非叶子节点只存索引，无数据。
2. 叶子节点关联
	- B 树：叶子节点无关联；
	- B + 树：叶子节点通过链表串联，支持范围查询更高效。
3. 查询效率
	- B 树：查询不同数据可能停在不同层级，效率不稳定；
	- B + 树：所有查询最终落到叶子节点，查询效率稳定，且范围查询无需回退上层节点。
4. 空间利用
	- B 树：非叶子节点存数据，占用空间大，树高度更高；
	- B + 树：非叶子节点仅存索引，空间利用率高，树更矮（IO 次数更少）。

简言之：B + 树仅叶子存数据、叶子链表串联、查询稳定 / 范围查优；B 树节点都存数据、无链表、效率不均。MySQL 索引默认用 B + 树，正是利用其范围查询和 IO 高效的特点。



（9）如何处理慢查询

在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么?是查询条件没有命中索引?是加载了不需要的数据列?还是数据量太大?

所以优化也是针对这三个方向来的

首先分析语句，看看是否加载了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。

分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。

如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。



（10）数据库分表操作

#### 1. 核心目的

解决单表数据量过大（如千万级 +）导致的查询慢、索引失效、性能下降等问题，拆分后单表数据量可控。

#### 2. 核心类型

- **水平分表（最常用）**：按行拆分，将一张大表的不同行数据分散到多张结构相同的子表（如按用户 ID 取模：user_0、user_1…user_9）；
- **垂直分表**：按列拆分，将一张大表的不同列（如高频查询列 / 低频大字段列）拆分到多张结构不同的子表（如 user_base（基础信息）、user_ext（扩展信息））。

#### 3. 关键实现思路

- 水平分表：按规则（范围、哈希、时间、地域）路由数据，如按订单创建时间拆分为 order_2024、order_2025；
- 垂直分表：按列的访问频率 / 大小拆分，减少单表列数和数据量，提升查询效率。



（11）MySQL优化 
（1）尽量选择较小的列

（2）将where中用的比较频繁的字段建立索引

（3）select子句中避免使用‘*’

（4）避免在索引列上使用计算、not in 和<>等操作

（5）当只需要一行数据的时候使用limit 1

（6）保证单表数据不超过200W，适时分割表。针对查询较慢的语句，可以使用explain 来分析该语句具体的执行情况。

（7）避免改变索引列的类型。

（8）选择最有效的表名顺序，from字句中写在最后的表是基础表，将被最先处理，在from子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。

（9）避免在索引列上面进行计算。

（10）尽量缩小子查询的结果



（12）如何设计数据库

#### 1. 第一范式（1NF）：原子性

要求表中每一列的值都是**不可再拆分的最小单元**，两列的属性值相近或者一样的,尽量合并到一列或者分表,确保数据不冗余。

例：避免将 “姓名 + 电话” 存在同一列，需拆分为`name`、`phone`两列。

#### 2. 第二范式（2NF）：唯一性

基于 1NF，要求**非主键列完全依赖于主键**（消除部分依赖），仅适用于联合主键表。

例：订单表联合主键`(订单ID, 商品ID)`，`商品名称`仅依赖`商品ID`（部分依赖），需拆分到商品表，仅保留与订单 + 商品共同相关的字段。

#### 3. 第三范式（3NF）：独立性

基于 2NF，要求**非主键列不传递依赖于主键**（消除传递依赖）。数据不能存在传递关系,每个属性都跟主键有直接关联而不是间接关联。

例：用户表中，`省名称`依赖`省ID`，`省ID`依赖`用户ID`（传递依赖），需拆分出省份表，用户表仅存`省ID`，通过关联查询省名称。

简言之：1NF 保列原子，2NF 保列全依赖主键，3NF 保列无传递依赖；核心是减少数据冗余、避免更新异常。



- ### MySQL 外键 简单说明

  外键（Foreign Key）是 MySQL 中**用于关联两个表的字段约束**，核心作用是保证数据的**参照完整性**（即关联表的数据不会出现无效、不一致的情况）。

  #### 核心概念

  - **主表（父表）**：被参照的表（通常有主键 / 唯一键）；
  - **从表（子表）**：设置外键的表，外键字段的值必须匹配主表的主键 / 唯一键值（或为 NULL）。

  #### 核心作用

  1. **约束数据有效性**：从表插入 / 更新数据时，外键值必须在主表中存在，否则操作失败（比如 “订单表” 的用户 ID，必须是 “用户表” 中已存在的 ID）；
  2. **级联操作（可选）**：可配置主表数据变更时，从表自动同步（如主表删除某用户，级联删除该用户的所有订单）。

  #### 简单示例

  ```sql
  -- 1. 主表：用户表（有主键id）
  CREATE TABLE user (
      id INT PRIMARY KEY,
      name VARCHAR(20)
  );
  
  -- 2. 从表：订单表（设置外键user_id关联用户表的id）
  CREATE TABLE order_info (
      order_id INT PRIMARY KEY,
      goods VARCHAR(50),
      user_id INT,
      -- 定义外键约束
      FOREIGN KEY (user_id) REFERENCES user(id)
      -- 可选级联操作：主表删除时，从表对应数据也删除
      ON DELETE CASCADE
  );
  ```

  #### 关键注意事项

  1. **存储引擎**：仅 InnoDB 引擎支持外键（MyISAM 不支持）；
  2. **数据类型匹配**：外键字段与主表被参照字段的类型必须完全一致（比如都是 INT）；
  3. **灵活性权衡**：外键会增加数据库开销，高并发场景（如电商）有时会舍弃外键，改由业务代码保证数据一致性。

  #### 一句话总结

  外键是 MySQL 给表之间加的 “数据关联锁”，确保关联表的数据不会乱，要么匹配主表数据，要么不许动。



####  删除/更新行为

- 添加了外键后，再删除父表数据时产生的约束行为，称删除/更新行为，具体分以下几种

  |        行为         |                             说明                             |
  | :-----------------: | :----------------------------------------------------------: |
  | *no action*（默认） | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与*restrict*一致) |
  |     *restrict*      | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与*no action*一致） |
  |  *cascade*（级联）  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |
  |     *set null*      | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取*null*） |
  |    *set default*    | 父表有变更时，子表将外键列设置成一个默认的值（*Innodb*不支持） |

- 语法：

  ```sql
  alter table 表名 add constraint 外键名称 foreign key （外键名称） references 主表名 （主表字段名）on update cascade on delete cascade;
  
  -- 举例：
  alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade;
  
  alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update set null on delete cascade set null;
  ```



- 事务：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作**作为一个整体**一起向系统提交或撤销操作请求，这些操作要么同时成功，要么同时失败
- 默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务



- MySQL体系结构

### 1. 连接层（客户端交互层）

作为 MySQL 与客户端的交互入口，核心负责**客户端连接管理、身份认证、权限校验**：

- 接收客户端（如 Java 程序通过 JDBC）的连接请求，通过 TCP/IP 协议建立通信；
- 验证账号密码、校验客户端 IP / 用户的操作权限，通过后分配连接线程（基于线程池复用，减少创建开销）；
- 常见组件：连接器（Connector）、线程池（Thread Pool）。

### 2. 服务层（核心功能层）

MySQL 的 “大脑”，实现所有核心业务逻辑，与存储引擎无关，是跨引擎的公共功能层：

- **SQL 接口**：接收并解析客户端的 SQL 语句（如 DQL、DML），返回执行结果；
- **解析器**：对 SQL 进行语法分析、语义校验，生成抽象语法树（AST）；
- **优化器**：基于成本计算最优执行计划（如选择索引、调整 JOIN 顺序）；
- **执行器**：调用存储引擎接口执行优化后的 SQL；
- **其他核心组件**：查询缓存（MySQL 8.0 已移除）、内置函数（聚合 / 字符串等）、事务管理器（实现 ACID）、锁管理器（行锁 / 表锁）。

### 3. 存储引擎层（数据存储适配层）

MySQL 的 “存储接口”，负责**数据的实际存储与读取**，采用插件式设计，可按需选择（如 InnoDB/MyISAM）：

- 每个存储引擎对应一套数据存储 / 检索逻辑，仅关注数据物理存储；
- 主流引擎：InnoDB（默认，支持事务、行锁、外键，适配高并发业务）、MyISAM（不支持事务，读写速度快，适配静态数据）；
- 核心职责：数据增删改查、索引管理、事务实现（仅 InnoDB）、缓存管理等。

### 4. 文件系统层（物理存储层）

底层物理存储载体，存储引擎将数据 / 日志持久化到磁盘文件：

- 核心文件类型：数据文件（.ibd/MyISAM 的.MYD）、索引文件、日志文件（binlog/redo log/undo log）、配置文件（my.cnf）等；
- 数据最终落地到操作系统的文件系统（如 ext4、NTFS），完成持久化。



（）innoDB存储引擎的特点

InnoDB 是 MySQL 默认的存储引擎，专为事务处理和高并发场景设计，核心特点可简洁总结为以下 5 点：

1. **支持事务**：遵循 ACID 原则，通过 redo log（重做日志）、undo log（回滚日志）实现事务的提交与回滚，支持四种隔离级别（默认可重复读）。
2. **行级锁机制**：基于行而非表加锁，减少并发下的锁冲突，大幅提升高并发读写场景的性能（仅在 WHERE 命中索引时生效，否则退化为表锁）。
3. **支持外键约束**：可定义表间外键关联，保证数据的参照完整性，适合有复杂关联关系的业务表（如订单表与用户表）。
4. **聚簇索引设计**：数据与主键索引存储在同一 B + 树中，主键查询效率极高；辅助索引叶子节点存储主键值，需回表查询完整数据。
5. **崩溃恢复能力**：依托 redo log 实现崩溃后的数据恢复，保证数据持久性；同时支持缓冲池（Buffer Pool），缓存数据与索引，减少磁盘 IO。

补充：相比 MyISAM，InnoDB 写性能稍低，但因事务和行锁特性，是 Java 后端开发中电商、金融等核心业务的首选引擎。



（）MySQL的索引结构

##### 索引结构

MySQL的索引是在**存储引擎层**实现的，不同的存储引擎有不同的结构，主要包含以下几种：

|        索引结构         |                             描述                             |
| :---------------------: | :----------------------------------------------------------: |
|     *B+ Tree* 索引      |        **最常见的索引类型，大部分引擎都支持B+树索引**        |
|       *Hash* 索引       | 底层数据结构是用**哈希表**实现的，只有**精确匹配**索引列的查询才有效，不支持范围查询 |
|  *R-tree*（空间索引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于**地理空间数据类型**，通常使用较少 |
| *Full-text*（全文索引） | 是一种通过建立**倒排索引**，快速匹配文档的方式。类似于Lucene,Solr,ES |

![](C:\Users\Silence\OneDrive\Pictures\Screenshots\屏幕截图 2025-10-04 122931.png)



（）为什么数据库采用B+Tree索引

数据库选择 B + 树作为索引结构，是和数据库的存储、访问特性高度匹配的，核心优势可以从**磁盘 IO 优化、查询效率、并发适配、数据有序性**这几个核心角度来理解：

1. 适配磁盘的 IO 特性

   

   数据库的数据是存储在磁盘中的，磁盘的 IO 操作是按「页」（一般是 4KB）为单位进行的，B + 树的每个节点的大小会被设计为刚好对应一个磁盘页，每次读取一个节点就只需要 1 次磁盘 IO，最大化利用磁盘的预读特性，相比二叉树这类结构，能大幅减少磁盘 IO 的次数。

2. 查询的稳定性更高

   

   B + 树的所有数据都存储在叶子节点，非叶子节点只存储索引键，所以不管查询什么数据，最终都需要遍历到叶子节点，查询的路径长度是固定的，不会出现二叉树那种极端情况下（比如单边树）查询效率暴跌的情况，保证了查询的稳定性。

3. 范围查询效率更高

   

   B + 树的叶子节点之间是通过双向链表串联起来的，在进行范围查询（比如查询 id 从 100 到 200 的数据）的时候，只需要找到范围的起始叶子节点，然后顺着链表往后遍历即可，不需要像 B 树一样反复回溯非叶子节点，非常适合数据库中常见的范围查询场景。

4. 更适合高并发场景

   

   非叶子节点只存储索引键，占用的空间更小，所以同样的内存空间，可以缓存更多的索引节点，减少磁盘 IO 的概率；同时叶子节点的链表结构，也方便数据库做并发的范围查询处理。



MySQL的MVCC多版本控制

MVCC（Multi-Version Concurrency Control，多版本并发控制）是 InnoDB 实现事务隔离的核心机制，通过为数据行维护多个版本、读写分离的方式，避免读写冲突，实现高并发下的高效访问（如读不阻塞写、写不阻塞读），是 InnoDB 默认隔离级别（可重复读）的底层支撑。

### 核心原理（极简版）

1. **数据行版本化**：InnoDB 为每行数据增加隐藏列（行 ID、事务 ID、回滚指针），事务修改数据时，不会直接覆盖原数据，而是生成新的数据版本，并通过回滚指针关联旧版本；
2. **undo log（回滚日志）**：用于记录数据被修改前的信息,旧数据版本存储在 undo log 中，事务回滚或读取历史版本时，通过回滚指针追溯；
3. **Read View（读视图）**：事务读取数据时，生成 Read View,记录并维护系统当前活跃的事务（未提交的）id，通过对比数据行的事务 ID 与 Read View，判断该版本是否对当前事务可见，只读取 “可见版本”。

### 核心优势

- 读写不阻塞：读操作（如 SELECT）无需加锁，直接读取数据的历史版本，不会阻塞写操作；写操作仅锁定当前数据版本，不影响读操作；
- 保证隔离性：不同事务看到的数据版本不同，满足可重复读（同一事务内多次读取结果一致）、读已提交等隔离级别的要求；
- 减少锁冲突：相比纯锁机制，大幅降低高并发下的锁竞争，提升数据库吞吐量。

### 面试简化表述

MVCC 是 InnoDB 的多版本并发控制机制，核心是给数据行存多个版本，读操作读历史版本、写操作生成新版本，通过 Read View 判断版本可见性，既能避免读写阻塞，又能保证事务隔离性，是 InnoDB 支持高并发的关键。



()MySQL主从复制

MySQL 主从复制是一种**数据同步机制**，核心是将主库（Master）的更新操作（增删改）同步到一个 / 多个从库（Slave），实现读写分离、故障备份、负载均衡，是提升 MySQL 可用性和并发能力的核心方案。

### 核心流程（极简版）

1. **主库记录日志**：主库执行写操作后，将操作语句写入二进制日志（binlog）；
2. **从库拉取日志**：从库通过 IO 线程连接主库，请求获取主库的 binlog，并将其写入本地的中继日志（relay log）；
3. **从库执行日志**：从库的 SQL 线程读取中继日志，逐条执行其中的 SQL 语句，复刻主库的数据变更，保证主从数据一致。

### 核心作用（面试高频）

- 读写分离：主库负责写操作（增删改），从库负责读操作（查询），缓解单库读写压力；
- 故障容灾：主库故障时，可将流量切换到从库，减少服务中断时间；
- 数据备份：从库可作为主库的热备，避免直接备份主库影响业务。

### 面试简化表述

MySQL 主从复制是主库把写操作记录到 binlog，从库通过 IO 线程拉取 binlog 到中继日志，再用 SQL 线程执行日志实现数据同步；核心作用是读写分离、故障备份，提升数据库并发和可用性。



()MySQL分库分表

MySQL 分库分表是应对**单库单表数据量过大（如千万级以上）、性能瓶颈（IO / 查询 / 写入慢）** 的水平扩展方案，核心是将原本存储在一个库 / 一张表的数据，拆分到多个库 / 多张表中，分散存储压力、提升读写效率。

### 核心分类（极简版）

#### 1. 分库

- **垂直分库**：按业务模块拆分（如电商系统，把用户库、订单库、商品库拆成独立数据库），降低单库业务耦合，缓解单库资源占用；
- **水平分库**：同一业务的数据，按规则分散到多个数据库（如订单数据按用户 ID 哈希，分散到 db1、db2、db3），解决单库存储和并发上限问题。

#### 2. 分表

- **垂直分表**：按字段拆分（如用户表，把常用的基础字段和不常用的扩展字段拆成两张表），减少单表字段数，提升查询时的行数据读取效率；
- **水平分表**：同一表的数据，按规则拆分到多张表（如订单表按时间拆成 order_2024、order_2025，或按订单 ID 哈希拆成 order_1、order_2），解决单表数据量过大导致的索引失效、查询缓慢问题。

### 核心拆分规则（面试高频）

常用规则：范围拆分（时间 / ID 区间）、哈希拆分（用户 ID / 订单 ID 哈希）、地域拆分（按用户所在地区），核心是保证数据均匀分布，避免 “数据倾斜”。

### 面试简化表述

MySQL 分库分表是解决单库单表数据量大、性能差的方案，分库分垂直（按业务）和水平（按数据规则），分表也分垂直（按字段）和水平（按数据规则）；核心是把数据拆到多库多表，分散压力、提升读写效率。





()mycat如何实现分库分表

MyCat 是基于 MySQL 的开源分布式数据库中间件，核心通过**SQL 解析、路由分发、结果聚合** 三大核心步骤，屏蔽底层分库分表的复杂性，让应用层像访问单库单表一样访问分布式数据库。

### 核心实现流程（极简版）

1. **配置规则先行**

   提前在 MyCat 配置文件（如 schema.xml、rule.xml）中定义：

   - 逻辑库 / 逻辑表（对应应用层访问的 “虚拟表”）与物理库 / 物理表的映射关系；
   - 分库分表规则（如按 ID 哈希、按时间范围、按地域等），比如配置 “订单表按用户 ID 模 10 拆分到 10 个物理表”。

2. **SQL 解析与路由**

   - MyCat 接收应用层的 SQL 请求后，先解析 SQL（提取表名、WHERE 条件、分库分表字段等）；
   - 根据预配置的拆分规则，判断这条 SQL 该路由到哪些物理库 / 物理表（比如 “查询用户 ID=100 的订单”，计算 100 模 10=0，路由到 order_0 表）。

3. **请求分发与结果聚合**

   - MyCat 将解析后的 SQL 改写为适配物理库表的语句，分发到对应的 MySQL 节点执行；
   - 收集所有物理节点的执行结果，按 SQL 语义聚合（如排序、分页、求和），最终返回统一结果给应用层。

### 核心关键（面试简化表述）

MyCat 作为中间件，先配置逻辑表与物理表的映射、分库分表规则；接收应用 SQL 后解析并按规则路由到对应物理库表，执行后聚合结果返回；核心是替应用层处理分库分表的路由和聚合，让开发无需关注底层分布式细节。
