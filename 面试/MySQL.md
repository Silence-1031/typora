#### （1）Select 语句完整的执行顺序

1. **FROM/JOIN**：先确定数据源，处理表连接（笛卡尔积、ON 筛选）；
2. **WHERE**：筛选 FROM 阶段的行（排除不满足条件的数据）；
3. **GROUP BY**：按指定字段分组；
4. **HAVING**：筛选分组后的结果（仅针对分组聚合值）；
5. **SELECT**：选取字段（含计算 / 聚合、别名）；
6. **DISTINCT**：去重 SELECT 的结果；
7. **ORDER BY**：按字段排序（可使用 SELECT 别名）；
8. **LIMIT/OFFSET**：限制返回行数 / 分页。

简言之：**先找表→筛行→分组→筛组→选字段→去重→排序→限行数**。



#### （2）事务的基本要素（ACID）

1. **原子性（Atomicity）**：事务是不可分割的最小单位，要么全执行，要么全回滚；
2. **一致性（Consistency）**：事务执行前后，数据库从一个合法状态到另一个合法状态（数据规则不破坏）；
3. **隔离性（Isolation）**：多个事务并发执行时，相互隔离、互不干扰；
4. **持久性（Durability）**：事务提交后，修改永久生效，不受故障（崩溃、断电）影响。



#### （3）事务的隔离级别以及事务的并发问题

### 一、MySQL 事务隔离级别（由低到高）

1. **读未提交（Read Uncommitted）**：能读取其他事务未提交的数据（脏读），隔离性最差；
2. **读已提交（Read Committed）**：只能读取其他事务已提交的数据，解决脏读，但可能出现不可重复读；
3. **可重复读（Repeatable Read）**：MySQL 默认级别，同一事务内多次读取结果一致，解决不可重复读，仍可能有幻读；
4. **串行化（Serializable）**：最高隔离级，事务串行执行，解决所有并发问题，但性能最差。

### 二、事务并发问题（由轻到重）

1. **脏读**：读取到其他事务未提交的、可能回滚的数据；
2. **不可重复读**：同一事务内，多次读同一数据，结果因其他事务提交修改而不同；
3. **幻读**：同一事务内，多次执行同一查询，结果集行数因其他事务插入 / 删除而变化。

简言之：隔离级别越高，并发问题越少，性能越低；默认的可重复读已解决脏读、不可重复读，InnoDB 通过间隙锁进一步降低幻读概率。

三、如何解决？

1. **脏读**：

	最低需设置「读已提交（Read Committed）」隔离级别，或更高；InnoDB 默认的「可重复读」也可彻底解决（仅读取已提交数据，拒绝未提交脏数据）。

2. **不可重复读**：

	升级到「可重复读（Repeatable Read）」隔离级别（MySQL 默认），InnoDB 通过多版本并发控制（MVCC）保证同一事务内多次读取数据一致，规避其他事务修改带来的不一致。

3. **幻读**：

	- 方案 1：设置最高级别「串行化（Serializable）」，强制事务串行执行，彻底杜绝幻读（但性能损耗大）；
	- 方案 2：保留「可重复读」，InnoDB 通过「间隙锁 + 行锁」（Next-Key Lock）锁定数据范围，阻止其他事务插入 / 删除，大幅降低幻读；
	- 补充：部分场景可通过加锁查询（如`SELECT ... FOR UPDATE`）显式锁定，避免幻读。



#### （5）MyISAM和InnoDB的区别

|          | MyISAM | InnoDB     |
| -------- | ------ | ---------- |
| 事务     | 不支持 | 支持       |
| 锁       | 表锁   | 表锁、行锁 |
| 文件存储 | 3个    | 1个        |
| 外键     | 不支持 | 支持       |



（6）聚簇索引和非聚簇索引

1. 聚簇索引（Clustered Index）

	索引与数据行物理存储在一起，索引的叶子节点直接存放整行数据；InnoDB 中默认主键为聚簇索引，无主键则选唯一非空索引，无则隐式生成。

2. 非聚簇索引（Non-Clustered Index）

	又称二级索引，索引叶子节点仅存主键值（而非整行数据），需通过主键值回表（查聚簇索引）才能获取完整数据。

优势:

1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询(非覆盖索引的情况下)效率要高

2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的

3、聚簇索引适合用在排序的场合，非聚簇索引不适合

劣势;

1、维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(pagesplit)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZETABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片

2、表因为使用uuId(随机ID)作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键

3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值，过长的主键值，会导致非叶子节点占用占用更多的物理空间



#### （7）mysql什么情况下会索引失效

1. **索引字段做函数 / 运算处理**：如`WHERE SUBSTR(name,1,2)='xx'`、`WHERE age+1=20`；
2. **使用模糊查询前缀 %**：如`WHERE name LIKE '%张三'`（后缀 % 不失效）；
3. **索引字段用 OR 连接（一侧无索引）**：如`WHERE idx_col=1 OR no_idx_col=2`；
4. **隐式类型转换**：如字符串索引字段匹配数字（`WHERE phone=13800138000`）；
5. **违背最左前缀原则**：联合索引`(a,b,c)`，查询仅用`b`/`c`/`b+c`；
6. **用 NOT IN/<> 等否定操作**：优化器易放弃索引走全表；
7. **数据分布极端（如全表数据近似）**：优化器判定全表扫描更高效；
8. **IS NULL/IS NOT NULL（视索引类型）**：部分场景（如非空索引查 IS NULL）失效。



（8）B+tree 与 B-tree区别

1. 节点数据存储
	- B 树：非叶子节点、叶子节点都存数据 + 索引；
	- B + 树：仅叶子节点存数据（索引 + 完整数据 / 主键），非叶子节点只存索引，无数据。
2. 叶子节点关联
	- B 树：叶子节点无关联；
	- B + 树：叶子节点通过链表串联，支持范围查询更高效。
3. 查询效率
	- B 树：查询不同数据可能停在不同层级，效率不稳定；
	- B + 树：所有查询最终落到叶子节点，查询效率稳定，且范围查询无需回退上层节点。
4. 空间利用
	- B 树：非叶子节点存数据，占用空间大，树高度更高；
	- B + 树：非叶子节点仅存索引，空间利用率高，树更矮（IO 次数更少）。

简言之：B + 树仅叶子存数据、叶子链表串联、查询稳定 / 范围查优；B 树节点都存数据、无链表、效率不均。MySQL 索引默认用 B + 树，正是利用其范围查询和 IO 高效的特点。



（9）如何处理慢查询

在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么?是查询条件没有命中索引?是加载了不需要的数据列?还是数据量太大?

所以优化也是针对这三个方向来的

首先分析语句，看看是否加载了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。

分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。

如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。



（10）数据库分表操作

#### 1. 核心目的

解决单表数据量过大（如千万级 +）导致的查询慢、索引失效、性能下降等问题，拆分后单表数据量可控。

#### 2. 核心类型

- **水平分表（最常用）**：按行拆分，将一张大表的不同行数据分散到多张结构相同的子表（如按用户 ID 取模：user_0、user_1…user_9）；
- **垂直分表**：按列拆分，将一张大表的不同列（如高频查询列 / 低频大字段列）拆分到多张结构不同的子表（如 user_base（基础信息）、user_ext（扩展信息））。

#### 3. 关键实现思路

- 水平分表：按规则（范围、哈希、时间、地域）路由数据，如按订单创建时间拆分为 order_2024、order_2025；
- 垂直分表：按列的访问频率 / 大小拆分，减少单表列数和数据量，提升查询效率。



（11）MySQL优化 
（1）尽量选择较小的列

（2）将where中用的比较频繁的字段建立索引

（3）select子句中避免使用‘*’

（4）避免在索引列上使用计算、not in 和<>等操作

（5）当只需要一行数据的时候使用limit 1

（6）保证单表数据不超过200W，适时分割表。针对查询较慢的语句，可以使用explain 来分析该语句具体的执行情况。

（7）避免改变索引列的类型。

（8）选择最有效的表名顺序，from字句中写在最后的表是基础表，将被最先处理，在from子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。

（9）避免在索引列上面进行计算。

（10）尽量缩小子查询的结果



（12）如何设计数据库

#### 1. 第一范式（1NF）：原子性

要求表中每一列的值都是**不可再拆分的最小单元**，两列的属性值相近或者一样的,尽量合并到一列或者分表,确保数据不冗余。

例：避免将 “姓名 + 电话” 存在同一列，需拆分为`name`、`phone`两列。

#### 2. 第二范式（2NF）：唯一性

基于 1NF，要求**非主键列完全依赖于主键**（消除部分依赖），仅适用于联合主键表。

例：订单表联合主键`(订单ID, 商品ID)`，`商品名称`仅依赖`商品ID`（部分依赖），需拆分到商品表，仅保留与订单 + 商品共同相关的字段。

#### 3. 第三范式（3NF）：独立性

基于 2NF，要求**非主键列不传递依赖于主键**（消除传递依赖）。数据不能存在传递关系,每个属性都跟主键有直接关联而不是间接关联。

例：用户表中，`省名称`依赖`省ID`，`省ID`依赖`用户ID`（传递依赖），需拆分出省份表，用户表仅存`省ID`，通过关联查询省名称。

简言之：1NF 保列原子，2NF 保列全依赖主键，3NF 保列无传递依赖；核心是减少数据冗余、避免更新异常。