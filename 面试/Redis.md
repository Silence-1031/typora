（1）简单介绍一下redis

Redis全称（Remote Dictionary Server）本质上是一个Key-Value类型的内存数据库，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。

**Redis** 是一款 **开源、高性能的键值对（Key-Value）内存数据库**，同时支持持久化，常被用于缓存、分布式锁、消息队列等场景。

核心特点简单总结：

1. **内存存储，速度快**：数据默认存于内存，读写性能极高（每秒可处理数十万请求），远超传统磁盘数据库。
2. **数据类型丰富**：不止支持字符串（String），还支持哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set）等多种结构，满足复杂业务需求。
3. **支持持久化**：可通过 RDB（快照）、AOF（日志追加）两种方式，将内存数据落地到磁盘，避免重启后数据丢失。
4. **高可用与分布式**：支持主从复制、哨兵模式（自动故障转移）、集群模式（分片扩容），满足大规模部署需求。
5. **原子操作与丰富功能**：提供事务、发布订阅、过期时间、Lua 脚本等功能，支持分布式锁等典型应用。

简言之：Redis 是**快、灵活、可靠**的内存数据库，是后端开发中提升系统性能的核心组件。



（2）redis常用数据类型

| 数据类型 | 核心特点                      | 典型场景                     |
| -------- | ----------------------------- | ---------------------------- |
| String   | 最基础，存字符串 / 数字       | 缓存验证码、计数器、分布式锁 |
| Hash     | 键值对集合，适合存对象        | 缓存用户信息、商品属性       |
| List     | 有序可重复，双向链表          | 消息队列、最新评论列表       |
| Set      | 无序不可重复，支持交集 / 并集 | 抽奖、好友关注关系、去重     |
| ZSet     | 有序不可重复，带分数排序      | 排行榜、延时任务、限流       |



（3）redis提供了哪些持久化方式

RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。

AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。

如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。

你也可以同时开启两种持久化方式，在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。

1. **RDB（Redis Database）**：
	- 原理：按指定规则（定时 / 手动）生成内存数据的快照文件（.rdb），落地到磁盘；
	- 特点：文件体积小、恢复速度快，但可能丢失两次快照间的数据，适合对数据完整性要求不高的场景。
2. **AOF（Append Only File）**：
	- 原理：记录所有写操作命令（如 SET、HSET）到日志文件，重启时重放命令恢复数据；
	- 特点：可配置 “实时 / 每秒” 刷盘，数据丢失风险极低，但日志文件体积大、恢复速度慢，适合对数据一致性要求高的场景。

**补充**：Redis 支持 RDB+AOF 混合模式，兼顾 RDB 的快速恢复和 AOF 的低数据丢失。



（4）redis为什么快

1)完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

2)数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的

3)采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗

4)使用I/O多路复用模型，非阻塞IO

5)使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求



（5）redis为什么是单线程的

Redis 性能瓶颈在「内存读写」而非 CPU，单线程可避免线程切换、锁竞争（如多线程的互斥锁）带来的额外开销，简化设计且减少并发问题。

官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了Redis利用队列技术将并发访问变为串行访问

1）绝大部分请求是纯粹的内存操作

2）采用单线程,避免了不必要的上下文切换和竞争条



（6）redis服务器的内存是多大



（7）为什么Redis的操作是原子性的，怎么保证原子性的

1. **核心原因**：Redis 命令执行是**单线程**的，同一时刻仅能处理一个命令，且单个命令执行过程无中断，要么全执行，要么全不执行。
2. 保证方式
	- 基础保障：单线程模型避免多线程并发修改，命令执行 “一气呵成”；
	- 原生命令：Redis 内置命令（如 INCR、HSET）本身设计为原子操作，无需额外锁；
	- 复杂场景：通过 Lua 脚本（将多命令封装为单个脚本执行，执行中不中断）、事务（MULTI/EXEC，虽弱事务但能保证命令批量原子执行）强化原子性。

简言之：单线程确保命令执行无并发中断，原生命令 / 脚本 / 事务进一步保障操作不可拆分



（8）redis有事务吗

Redis是有事务的，redis中的事务是一组命令的集合，这组命令要么都执行，要不都不执行，

redis事务的实现，需要用到MULTI（事务的开始）和EXEC（事务的结束）命令 ;

![img](https://i-blog.csdnimg.cn/blog_migrate/8be8f6bfa3b748c83d8626dd5eaa9f51.jpeg)

当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了两个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。

Redis的事务除了保证所有命令要不全部执行，要不全部不执行外，还能保证一个事务中的命令依次执行而不被其他命令插入。同时，redis的事务是不支持回滚操作的。



（9）Redis数据和MySQL数据库的一致性如何实现

一、 延时双删策略

        在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。具体步骤是：
    
        1）先删除缓存
    
        2）再写数据库
    
        3）休眠500毫秒（根据具体的业务时间来定）
    
        4）再次删除缓存。
    
        那么，这个500毫秒怎么确定的，具体该休眠多久呢？
    
        需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
    
        当然，这种策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。

二、设置缓存的过期时间

        从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存
    
        结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。

三、如何写完数据库后，再次删除缓存成功？

        上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时，可能就会出现数据不一致的情况。这里，我们需要提供一个保障重试的方案。

1、方案一具体流程

        （1）更新数据库数据； 
    
        （2）缓存因为种种问题删除失败；
    
        （3）将需要删除的key发送至消息队列；
    
        （4）自己消费消息，获得需要删除的key；
    
        （5）继续重试删除操作，直到成功。
    
        然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。 

2、方案二具体流程

        （1）更新数据库数据；
    
        （2）数据库会将操作信息写入binlog日志当中；
    
        （3）订阅程序提取出所需要的数据以及key； 
    
        （4）另起一段非业务代码，获得该信息；
    
        （5）尝试删除缓存操作，发现删除失败； 
    
        （6）将这些信息发送至消息队列；
    
        （7）重新从消息队列中获得该数据，重试操作。


（10）缓存击穿，缓存穿透，缓存雪崩的原因和解决方案(或者说使用缓存的过程中有没有遇到什么问题，怎么解决的）

1. 缓存穿透：

是指查询一个不存在的数据，由于缓存无法命中，将去查询数据库，但是数据库也无此记录，并且出于容错考虑，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

解决方案：空结果也进行缓存，可以设置一个空对象，但它的过期时间会很短，最长不超过五分钟。 或者用布隆过滤器也可以解决，Redisson框架中有布隆过滤器。

2. 缓存雪崩：

是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方案：原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

3. 缓存击穿

是指对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：如果这个key在大量请求同时进来之前正好失效，那么所有对这个key的数据查询都落到DB，我们称为缓存击穿。

解决方案：在分布式的环境下，应使用分布式锁来解决，分布式锁的实现方案有多种，比如使用Redis的setnx、使用Zookeeper的临时顺序节点等来实现

| 问题类型     | 核心原因                                                     | 解决方案                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **缓存穿透** | 请求**不存在的数据**，缓存和 DB 都查不到，请求直击 DB，压垮数据库 | 1. 空值缓存：查不到的数据也缓存（设短过期时间，如 5 分钟）2. 布隆过滤器：提前过滤不存在的 Key，拦截无效请求 |
| **缓存击穿** | 热点 Key（如秒杀商品）**突然失效**，大量请求瞬间打到 DB      | 1. 热点 Key 永不过期：手动维护热点 Key 的缓存有效期2. 互斥锁：缓存失效时，加分布式锁，仅一个线程查 DB 并重建缓存，其他线程等待 |
| **缓存雪崩** | 大量缓存 Key **同一时间失效**，或缓存服务宕机，所有请求压垮 DB | 1. 过期时间随机化：给不同 Key 加随机过期时间（如基础时间 ±10 分钟），避免集体失效2. 缓存集群高可用：部署 Redis 哨兵 / 集群，防止单点故障3. 降级限流：缓存宕机时，对 DB 请求限流或返回兜底数据 |



（11）哨兵模式是什么样的    难度系数：⭐⭐
如果Master异常，则会进行Master-Slave切换，将其中一Slae作为Master，将之前的Master作为Slave

下线：

①主观下线：Subjectively Down，简称 SDOWN，指的是当前 Sentinel 实例对某个redis服务器做出的下线判断。

②客观下线：Objectively Down， 简称 ODOWN，指的是多个 Sentinel 实例在对Master Server做出 SDOWN 判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，然后开启failover.

工作原理：

（1）每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令 ；

（2）如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线；

（3）如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态；

（4）当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 ；

（5）在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令

（6）当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 ；

（7）若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除；

若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除；



（12）Redis常见性能问题和解决方案    难度系数：⭐
(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件

(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内

(4) 尽量避免在压力很大的主库上增加从库

(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...

这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。



（13）MySQL里有大量数据，如何保证Redis中的数据都是热点数据

redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

数据淘汰策略：

noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）

allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。

volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。

allkeys-random: 回收随机的键使得新添加的数据有空间存放。

volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。

volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。



（14）redis集群方案应该怎么做，有哪些方案

Redis 集群方案按演进阶段分为 3 类，适配不同规模场景：

#### 1. 主从复制（基础高可用）

- **做法**：1 主 N 从，主节点写数据，从节点只读；主节点宕机需手动切换到从节点。
- **适用**：小流量场景，仅解决 “读负载分担 + 数据备份”，无自动故障转移。

#### 2. 哨兵模式（Sentinel，自动故障转移）

- **做法**：基于主从架构，部署 3 + 个哨兵节点监控主从状态；主节点宕机时，哨兵自动投票选举新主节点，并通知客户端切换。
- **核心能力**：自动故障转移、主从切换，解决主从架构的手动运维问题；但仍单主写入，无法横向扩容。
- **适用**：中小规模场景，需高可用但写入压力不大。

#### 3. Redis Cluster（集群模式，分片扩容）

- **做法**：将数据按哈希槽（共 16384 个）分片，分布到多个主节点（至少 3 主 3 从），每个主节点对应若干从节点；支持自动分片、故障转移、横向扩容。
- **核心能力**：解决单主写入瓶颈，支持多主并行写入，可线性扩容；客户端自动路由到对应节点。
- **适用**：大规模高并发场景，需高可用 + 高扩容性。



（15）redis哈希槽的概念

Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。



（16）redis的适合场景

| 场景分类      | 核心数据结构 | 核心优势                 |
| ------------- | ------------ | ------------------------ |
| 热点数据缓存  | String/Hash  | 高读写性能，减轻 DB 压力 |
| 计数器 / 限流 | String       | 原子操作，高并发精确计数 |
| 分布式锁      | String       | 轻量级，支持自动过期     |
| 消息队列      | List/Stream  | 低延迟，支持阻塞消费     |
| 排行榜        | ZSet         | 实时排序，快速范围查询   |
| 分布式会话    | Hash         | 跨机器共享，自动过期     |
| 延迟任务      | ZSet         | 简单高效，无需依赖第三方 |