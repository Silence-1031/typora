（1）简单介绍一下redis

Redis本质上是一个Key-Value类型的内存数据库，整个数据库统统加载在内存当中进行操作，定期通过异步操作（ RDB快照、AOF日志追加两种方式）把数据库数据flush到硬盘上进行保存。

因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。

且数据类型丰富不止支持字符串（String），还支持哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set）等多种结构，满足复杂业务需求。

支持主从复制、哨兵模式（自动故障转移）、集群模式（分片扩容），满足大规模部署需求。

 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。



（2）redis常用数据类型

| 数据类型 | 核心特点                      | 典型场景                     |
| -------- | ----------------------------- | ---------------------------- |
| String   | 最基础，存字符串 / 数字       | 缓存验证码、计数器、分布式锁 |
| Hash     | 键值对集合，适合存对象        | 缓存用户信息、商品属性       |
| List     | 有序可重复，双向链表          | 消息队列、最新评论列表       |
| Set      | 无序不可重复，支持交集 / 并集 | 抽奖、好友关注关系、去重     |
| ZSet     | 有序不可重复，带分数排序      | 排行榜、延时任务、限流       |

#### redis常用操作

#### 1. 通用 / 键操作（所有数据类型通用）

| 命令             | 作用                                         | 示例                                    |
| ---------------- | -------------------------------------------- | --------------------------------------- |
| `KEYS pattern`   | 匹配符合规则的键（慎用，O (n)）              | `KEYS user:*`（匹配 user 开头的键）     |
| `SCAN cursor`    | 分批遍历键（替代 KEYS，非阻塞）              | `SCAN 0 MATCH user:* COUNT 10`          |
| `EXISTS key`     | 判断键是否存在                               | `EXISTS user:1001`（返回 1/0）          |
| `DEL key`        | 删除键（支持批量）                           | `DEL user:1001 order:2001`              |
| `EXPIRE key ttl` | 设置键过期时间（秒）                         | `EXPIRE user:1001 3600`（1 小时过期）   |
| `TTL key`        | 查看键剩余过期时间（-1 永不过期，-2 已过期） | `TTL user:1001`                         |
| `TYPE key`       | 查看键的数据类型                             | `TYPE user:1001`（返回 string/hash 等） |

#### 2. 字符串（String）- 最常用类型

| 命令                       | 作用                             | 示例                                                         |
| -------------------------- | -------------------------------- | ------------------------------------------------------------ |
| `SET key value`            | 设置键值（支持过期）             | `SET user:1001 "zhangsan"` / `SET user:1001 "zhangsan" EX 3600` |
| `GET key`                  | 获取键值                         | `GET user:1001`                                              |
| `MSET key1 val1 key2 val2` | 批量设置键值                     | `MSET a 1 b 2 c 3`                                           |
| `MGET key1 key2`           | 批量获取键值                     | `MGET a b c`                                                 |
| `INCR key`                 | 数值自增 1（原子操作，适合计数） | `INCR view:article:100`（文章阅读量 + 1）                    |
| `DECR key`                 | 数值自减 1（原子操作）           | `DECR stock:goods:200`（商品库存 - 1）                       |
| `APPEND key value`         | 追加字符串到值末尾               | `APPEND user:1001 "_vip"`                                    |

#### 3. 哈希（Hash）- 适合存储对象

| 命令                    | 作用                               | 示例                                         |
| ----------------------- | ---------------------------------- | -------------------------------------------- |
| `HSET key field value`  | 设置哈希字段值                     | `HSET user:1001 name "zhangsan" age 25`      |
| `HGET key field`        | 获取哈希字段值                     | `HGET user:1001 name`                        |
| `HMSET key f1 v1 f2 v2` | 批量设置哈希字段                   | `HMSET user:1001 phone "123456" addr "北京"` |
| `HMGET key f1 f2`       | 批量获取哈希字段                   | `HMGET user:1001 name age`                   |
| `HGETALL key`           | 获取哈希所有字段和值（慎用大哈希） | `HGETALL user:1001`                          |
| `HSCAN key cursor`      | 分批遍历哈希字段（替代 HGETALL）   | `HSCAN user:1001 0 COUNT 5`                  |
| `HDEL key field`        | 删除哈希字段                       | `HDEL user:1001 addr`                        |

#### 4. 列表（List）- 有序可重复，适合队列 / 栈

| 命令                   | 作用                           | 示例                                  |
| ---------------------- | ------------------------------ | ------------------------------------- |
| `LPUSH key value`      | 从列表左侧插入元素             | `LPUSH queue:order 1001 1002`         |
| `RPUSH key value`      | 从列表右侧插入元素             | `RPUSH queue:order 1003`              |
| `LPOP key`             | 从列表左侧弹出元素（原子操作） | `LPOP queue:order`（取出 1002）       |
| `RPOP key`             | 从列表右侧弹出元素             | `RPOP queue:order`（取出 1003）       |
| `LRANGE key start end` | 获取列表指定范围元素           | `LRANGE queue:order 0 -1`（所有元素） |
| `LLEN key`             | 获取列表长度                   | `LLEN queue:order`                    |

#### 5. 集合（Set）- 无序不可重复，适合去重 / 交集

| 命令                   | 作用                           | 示例                                   |
| ---------------------- | ------------------------------ | -------------------------------------- |
| `SADD key member`      | 添加集合元素                   | `SADD user:1001:tags "java" "redis"`   |
| `SMEMBERS key`         | 获取集合所有元素（慎用大集合） | `SMEMBERS user:1001:tags`              |
| `SISMEMBER key member` | 判断元素是否在集合中           | `SISMEMBER user:1001:tags "java"`      |
| `SINTER key1 key2`     | 获取多个集合的交集             | `SINTER user:1001:tags user:1002:tags` |
| `SUNION key1 key2`     | 获取多个集合的并集             | `SUNION user:1001:tags user:1002:tags` |
| `SREM key member`      | 删除集合元素                   | `SREM user:1001:tags "redis"`          |

#### 6. 有序集合（ZSet）- 有序不可重复，适合排序 / 排名

| 命令                                | 作用                                          | 示例                                   |
| ----------------------------------- | --------------------------------------------- | -------------------------------------- |
| `ZADD key score member`             | 添加有序集合元素（score 为排序权重）          | `ZADD rank:score 95 user1 88 user2`    |
| `ZRANGE key start end [WITHSCORES]` | 按 score 升序取元素（带 WITHSCORES 返回分数） | `ZRANGE rank:score 0 -1 WITHSCORES`    |
| `ZREVRANGE key start end`           | 按 score 降序取元素（排名场景）               | `ZREVRANGE rank:score 0 9`（前 10 名） |
| `ZSCORE key member`                 | 获取元素的 score 值                           | `ZSCORE rank:score user1`              |
| `ZREM key member`                   | 删除有序集合元素                              | `ZREM rank:score user2`                |



（3）redis提供了哪些持久化方式

**RDB（Redis Database）**持久化方式能够**在指定的时间间隔能对你的数据进行快照存储**。

**AOF（Append Only File）**持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据，数据丢失风险极低，但日志文件体积大、恢复速度慢，适合对数据一致性要求高的场景。

Redis 支持 RDB+AOF 混合模式，兼顾 RDB 的快速恢复和 AOF 的低数据丢失。



（4）redis为什么快

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于`HashMap`，`HashMap`的优势就是查找和操作的时间复杂度都是O(1)

- 数据结构简单，对数据操作也简单
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，也没有因为可能出现死锁而导致的性能消耗

- 使用I/O多路复用模型，非阻塞IO





（5）redis为什么是单线程的

Redis 绝大部分请求是纯粹的内存操作，单线程避免了不必要的上下文切换和竞争条带来的额外开销，简化设计且减少并发问题。



（6）redis服务器的内存是多大

Redis 默认没有强制限制内存大小，通常会在`redis.conf`中通过`maxmemory`参数手动设置内存上限，这个值根据服务器的总内存和业务需求来决定



（7）为什么Redis的操作是原子性的，怎么保证原子性的

**核心原因**：Redis 命令执行是**单线程**的，同一时刻仅能处理一个命令，且单个命令执行过程无中断，要么全执行，要么全不执行。Redis 内置命令（如 INCR、HSET）本身设计为原子操作，无需额外锁；

**复杂场景**：通过 Lua 脚本（将多命令封装为单个脚本执行，执行中不中断）、事务（MULTI/EXEC，虽弱事务但能保证命令批量原子执行）强化原子性。



（8）redis有事务吗

Redis是有事务的，redis中的事务是一组命令的集合，这组命令要么都执行，要不都不执行，

redis事务的实现，需要用到MULTI（事务的开始）和EXEC（事务的结束）命令 ;

![img](https://i-blog.csdnimg.cn/blog_migrate/8be8f6bfa3b748c83d8626dd5eaa9f51.jpeg)

当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了两个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。

redis的事务是不支持回滚操作的。这是因为 Redis 简化了事务实现，不记录命令执行的中间状态，也没有回滚所需的回滚日志，以此换取高性能。



#### 






（10）缓存击穿，缓存穿透，缓存雪崩的原因和解决方案(或者说使用缓存的过程中有没有遇到什么问题，怎么解决的）

1. 缓存穿透：是指查询一个不存在的数据，由于缓存无法命中，将去查询数据库，但是数据库也无此记录，并且出于容错考虑，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

解决方案：空结果也进行缓存，可以设置一个空对象，但它的过期时间会很短，最长不超过五分钟。 或者用布隆过滤器也可以解决，Redisson框架中有布隆过滤器。

2. 缓存雪崩：是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方案：原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

3. 缓存击穿：是指对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，而在访问时正好失效，那么所有对这个key的数据查询都落到DB，可能会压垮DB，我们称为缓存击穿。

解决方案：在分布式的环境下，应使用分布式锁来解决，分布式锁的实现方案有多种，比如使用Redis的setnx、使用Zookeeper的临时顺序节点等来实现



（12）Redis常见性能问题和解决方案

1. 内存溢出 / 内存占用过高：Redis 内存耗尽触发 OOM，或内存占用过高导致系统卡顿，缓存淘汰频繁

- 配置`maxmemory`设置内存上限，搭配`maxmemory-policy`（如`allkeys-lru`）自动淘汰冷数据；
- 给所有缓存设置合理过期时间（5~15 分钟），避免永久缓存；

2. 慢查询导致阻塞：执行复杂命令（如`KEYS *`、`HGETALL`）导致 Redis 单线程阻塞，其他请求超时
3. 并发竞争（缓存击穿 / 穿透 / 雪崩）
4. 持久化阻塞：RDB 快照 / AOF 重写时，Redis 主线程阻塞，请求延迟升高





（13）MySQL里有大量数据，如何保证Redis中的数据都是热点数据

redis内存数据集达到`maxmemory`上限时，就会施行数据淘汰策略。

- noeviction：不淘汰任何数据，内存满时拒绝写入操作（读操作正常），返回 OOM 错误

- allkeys-lru:：从所有键中尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。

- volatile-lru：从所有过期的键中尝试回收最少使用的键（LRU）

- allkeys-random: 回收随机的键使得新添加的数据有空间存放。

- volatile-random: 从所有过期的键中随机回收键使得新添加的数据有空间存放

- volatile-ttl: 从过期 key 中，优先回收存活时间（ttl）较短的 key




（16）redis的适合场景

| 场景分类      | 核心数据结构 | 核心优势                 |
| ------------- | ------------ | ------------------------ |
| 热点数据缓存  | String/Hash  | 高读写性能，减轻 DB 压力 |
| 计数器 / 限流 | String       | 原子操作，高并发精确计数 |
| 分布式锁      | String       | 轻量级，支持自动过期     |
| 消息队列      | List/Stream  | 低延迟，支持阻塞消费     |
| 排行榜        | ZSet         | 实时排序，快速范围查询   |
| 分布式会话    | Hash         | 跨机器共享，自动过期     |
| 延迟任务      | ZSet         | 简单高效，无需依赖第三方 |