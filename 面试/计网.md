（1）CS和BS架构:Web的两种常见系统架构

**CS 架构（Client/Server，客户端 / 服务器架构）**客户端需要单独下载软件，再与服务器进行交互，运行速度通常更快，能实现的功能更丰富；但需要单独适配不同的操作系统，且维护成本高（微信QQ等）

**BS 架构（Browser/Server，浏览器 / 服务器架构）**没有独立的客户端，用户只需要通过浏览器（比如 Chrome、Edge），访问对应的网址就能使用系统，所有的业务逻辑都在服务器端运行跨平台性更强；但运行速度受浏览器和网络的影响更大，能实现的功能会受浏览器的一些限制（网页版的淘宝、企业的 OA 系统网页端）



（2）网络编程三要素

| 要素    | 作用                                                         | 类比理解                                              |
| ------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| IP 地址 | 设备在网络中的**唯一标识**，用于定位设备                     | 设备的 “身份证号”                                     |
| 端口    | 应用程序在设备中的**唯一标识**，用于区分设备上的不同程序     | 设备的 “门牌号”（如微信对应特定端口，避免与 QQ 冲突） |
| 协议    | 网络中数据传输的**规则**（如连接方式、数据格式、是否需确认） | 通信双方的 “对话准则”                                 |



（3）TCP/IP协议

TCP/IP 协议是互联网的**通信规则集合**，是设备能在互联网上互联互通的基础，把复杂的通信过程拆分成了 4 个层级，每一层负责不同的工作：

1. **应用层**：直接对接用户使用的软件，为应用程序提供通信接口。比如我们常用的 HTTP（网页访问）、HTTPS（加密网页访问）、FTP（文件传输）都属于这一层

2. 传输层：负责在两台设备的应用程序之间建立 “数据传输的通道”，核心是TCP/UDP两个协议：

3. **网络层**：负责找到数据要去的目标设备，核心是 IP 协议，给每一台联网设备分配唯一的 IP 地址

4. **数据链路层**：负责物理设备之间的直接通信，包括以太网，ARP（地址解析）等



（4）传输层核心协议：UDP 与 TCP

（1）UDP 协议（用户数据报协议-User Datagram Protocol）

- 核心特点：**无连接、不可靠、高效率**,适用于对可靠性要求低、对实时性要求高的场景，如**视频直播、语音通话**（丢失少量数据不影响整体体验）
  - 无连接：通信前无需建立连接，直接发送数据包 (包含：自己的IP、端口、目的地IP、端口和数据等)；
  - 不可靠：发送方不确认接收方是否在线，数据丢失不重发，接收方收到数据也不返回确认；
  - 高效率：无需连接和确认流程，传输速度快；
  - 数据限制：单个数据包最大为 64KB。

 （2）TCP 协议（传输控制协议-Tansmission Control Protocol）

- 核心特点：**面向连接、可靠、低效率**，适用于对可靠性要求高、不允许数据丢失的场景，如**网页下载、文件传输、支付功能**
  - 面向连接：通信前必须通过 “三次握手” 建立可靠连接；
  - 可靠：通过 “数据确认”“重传机制”确保数据不丢失、不重复；
  - 低效率：连接和确认流程会增加耗时；
  - 数据无限制：可传输大量数据（如文件、大文本）。



4. TCP 协议的关键机制

 （1）三次握手（建立连接）

- **目的**：确保通信双方 “既能发消息，也能收消息”（全双工模式），避免连接建立后一方无法收发的问题。
- 流程逻辑：
  - 客户端 → 服务端：“我要连接你”（服务端收到后，确认 “客户端能发”）；
  - 服务端 → 客户端：“我收到你的请求了”（客户端收到后，确认 “服务端能收也能发”）；
  - 客户端 → 服务端：“好的，开始连接”（服务端收到后，确认 “客户端能收”）。

 （2）四次挥手（断开连接）

- **目的**：确保双方已完成所有数据收发，避免断开后残留未处理数据。
- 流程逻辑：
  - 客户端 → 服务端：“我要断开连接”（服务端收到后，确认 “断开请求已送达”）；
  - 服务端 → 客户端：“收到请求，稍等我处理剩余数据”（客户端收到后，等待服务端收尾）；
  - 服务端 → 客户端：“我处理完了，可以断开了”（客户端收到后，确认 “服务端无残留数据”）；
  - 客户端 → 服务端：“好的，断开”（服务端收到后，正式断开连接）。

（3）数据可靠性保障补充

- **确认机制**：服务端收到数据后，会向客户端返回 “确认信号”；若客户端未收到确认，会重发数据，直到服务端确认。
- **去重机制**：每个数据包携带唯一 “消息 ID”，服务端收到重复 ID 的数据包时，会直接拒绝并返回确认，避免重复数据。



（5）BS 架构的通信流程

- **请求发起**：浏览器通过`HTTP协议`发起请求，请求地址格式为`http://IP地址:端口号`（如`http://127.0.0.1:8080`）。
  - HTTP 协议：浏览器与服务端的 “沟通规则”，规定请求 / 响应的数据格式。
- **连接建立**：浏览器与服务端通过`TCP Socket管道`建立通信连接（类似 CS 架构的 Socket 通信），主线程负责接收客户端连接，子线程（或线程池）处理具体的数据响应。
- **数据响应**：服务端向浏览器返回符合 HTTP 协议格式的数据，浏览器解析后展示为网页。

> HTTP 协议(**Hyper Text Transfer Protocol** ) “超文本传输协议”，规定客户端与服务器交互时的**数据格式**，确保双方能正确解析对方发送的信息
>
> 三大核心特点
>
> 1. **基于 TCP 协议**实现数据传输；
> 2. 严格遵循 “一次请求对应一次响应” 的规则：**没有请求，就没有响应**；
>    - 流程固定：客户端发起请求 → 服务器接收并处理 → 服务器返回响应 → 客户端接收响应（一次交互结束）。
> 3. **无状态协议**:即**多次请求之间相互独立，后一次请求不会记录前一次请求的信息**；
>
> 后续通过（如 Cookie、Session、JWT 令牌）来弥补无状态的缺陷，实现跨请求数据共享

2. 服务端响应的 HTTP 协议格式

![image-20251101135136149](C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251101135136149.png)

浏览器仅识别符合 HTTP 协议格式的数据，响应格式需严格遵循以下 3 点：

|     格式要求     |                             说明                             |                             示例                             |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  第一行：状态行  | 声明 HTTP 协议版本、响应状态码（200 表示 “正常响应”，404 表示 “资源未找到”） |                      `HTTP/1.1 200 OK`                       |
|  第二行：响应头  |        Content-Type，声明响应内容的类型、编码等元信息        | `Content-Type: text/html; charset=UTF-8`（表示内容为 HTML 文本，编码为 UTF-8，避免乱码） |
|     空行分隔     | 响应头与网页内容之间必须加**单独空行**（作为格式分隔符，缺一不可） |                              -                               |
| 后续内容：响应体 |  实际的网页内容（HTML 代码），可包含标签、样式、图片链接等   | `<html><body><h1 style="color:red">听我讲Java</h1></body></html>` |

22. Http 常见的状态码

- 200 OK      //客户端请求成功

- 301      Permanently Moved （永久移除)，请求的 URL 已移走。Response 中应该包含一个 Location URL, 说明资源现在所处的位置
- 302      Temporarily Moved  临时重定向
- 400      Bad Request //客户端请求有语法错误，不能被服务器所理解
- 401      Unauthorized //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
- 403      Forbidden //服务器收到请求，但是拒绝提供服务
- 404      Not Found //请求资源不存在，eg：输入了错误的 URL
- 500      Internal Server Error //服务器发生不可预期的错误
- 503      Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常





两种表单数据提交方式：`get` vs `post`

表单提交是 Web 端用户向服务器传递数据的核心方式，通过  `<form>` 标签定义表单结构，浏览器将表单数据按指定方式（GET/POST 为主）封装并发送到服务器，服务器解析数据后处理并返回响应；

| 对比维度     | `get` 方式                                                  | `post` 方式                                                  |
| ------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
| 数据传输位置 | 数据拼接在 **URL 末尾**（可见），格式：`URL?name=值&age=值` | 数据放在 **请求体（消息体）** 中（不可见，需通过浏览器开发者工具查看） |
| 安全性       | 低（数据暴露在 URL 中，易被截取，不适合隐私数据）           | 高（数据隐藏在请求体，适合密码、银行卡号等隐私数据）         |
| 数据量限制   | 有限制（URL 长度通常不超过 2KB，不同浏览器略有差异）        | 无限制（可提交大文件、大量文本等）                           |
| 适用场景     | 数据查询、搜索（如员工信息搜索，无隐私数据）                | 数据提交、保存（如注册、登录、文件上传）                     |

常用 AJAX/Fetch 异步提交表单（在**不重新加载整个页面**的前提下，与服务器进行数据交换并更新页面部分内容），提升用户体验

无论是 GET 还是 POST 请求，多值参数需以 **“同名参数重复传递”** 的形式提交，格式如下：

- 示例：传递 “爱好（hobby）” 的 3 个值（game、java、sing）
  - GET 请求 URL：`http://localhost:8080/xxx?hobby=game&hobby=java&hobby=sing`
  - POST 请求表单 / Body：参数名均为`hobby`，值分别为`game`、`java`、`sing`

`@DateTimeFormat`—— 用于指定前端传递的日期参数格式，核心属性`pattern`定义格式规则。

json格式数据是前后端交互的主流数据格式，后端需将 JSON 数据自动封装到实体类中。

- **请求方式**：必须使用`POST`——JSON 数据需放在**请求体（Request Body）** 中，而非 URL 参数。
- **关键注解**：`@RequestBody`—— 用于将请求体中的 JSON 数据自动映射到后端实体类对象。
- **映射规则**：JSON 的`key`必须与实体类的**属性名完全一致**（支持嵌套对象，如 JSON 中嵌套`address`对象，实体类也需有`Address`类型属性）。

路径参数：将请求参数直接嵌入 URL 路径中的传参方式，springboot通过`@RequestMapping("/pass/{id}")`注解来接收参数，并在方法形参前添加`@PathVariable`注解，实现路径参数与形参的绑定。





tomcat

Tomcat 是一个轻量级 Java Servlet 容器（也叫 Web 容器），内置了 Servlet 规范、JSP 引擎，无需额外配置复杂环境，只需将打包好的 WAR 包放入 Tomcat 的` webapps`目录，启动 Tomcat 即可运行 Web 应用。是处理客户端请求与 Java Web 应用的核心中间件。Spring Boot 内置 Tomcat 作为默认嵌入式容器。

处理流程：接收前端客户端 HTTP 请求

> 封装为`HttpServletRequest`,`HttpServletResponse`  来封装请求和响应数据

将动态请求（如.jsp/.do）交给 Servlet处理，返回动态响应；静态资源（如.html/.css）可直接处理或交由 Nginx 转发。



会话技术

会话技术是 Web 开发中维持客户端与服务器 “状态关联” 的核心手段，解决 HTTP 协议无状态的问题（每次请求独立，服务器无法识别同一客户端），以便**在同一次会话的多次请求间共享数据**。核心分为 Cookie（客户端存储）和 Session（服务器端存储）两类

Cookie 是**服务器发送给客户端浏览器的一小段文本数据**（键值对形式），首次请求时浏览器会将其保存，后续请求同一服务器时，会自动携带该 Cookie 到请求头中，让服务器识别用户。

- 核心特点：存储在客户端（浏览器），大小受限（通常 4KB 以内），可设置cookie过期时间，但不支持移动端，且安全性差，可通过浏览器设置禁用 / 修改 Cookie，不支持跨域请求。

Session 是服务器端为每个客户端生成唯一 SessionID（存入 Cookie），客户端携带 ID 请求时，服务器通过 ID 找到对应的 Session 对象，用于存储用户的会话信息（如登录状态、购物车数据）。

- Session 存储在服务器端，无大小限制，但会占用服务器资源，且不兼容集群环境（Session 存储在单个服务器端，负载均衡下请求分发到其他服务器时，无法找到对应 Session）。

**补充扩展方案**

**Token（令牌）**：替代 Session 的无状态方案，服务器生成加密令牌（如 JWT）返回客户端，客户端存储在 LocalStorage/Cookie，每次请求携带令牌，服务器验证令牌即可识别用户，无需存储会话（适配分布式 / 微服务场景）；



#### 过滤器

过滤器（Filter）是 Java Web 中拦截并处理 HTTP 请求 / 响应的核心组件，运行在请求到达目标资源（Servlet/Controller/JSP）之前，以及资源响应后的统一请求（如编码设置、登录校验、权限控制、日志记录）不处理业务逻辑，仅做请求的 “预处理 / 后处理”。通过在Filter 类上添加`@WebFilter`注解，指定拦截的路径

执行流程：Filter 是请求访问资源的 “必经之路”

- **请求拦截**：浏览器发送请求后，先被 Filter 拦截，不直接进入业务接口；
- **逻辑处理**：Filter 执行自定义逻辑（如登录校验）；
- **请求放行**：若逻辑校验通过，通过`FilterChain`将请求传递给目标资源（如 Controller 接口）；
- **资源处理**：目标资源执行业务逻辑并生成响应；
- **响应返回**：响应结果先回到 Filter，Filter 可进一步处理响应（如添加统一响应头），最终返回给浏览器。



#### 拦截器

拦截器（Interceptor）是 **Spring 框架提供的动态拦截机制**，仅拦截 DispatcherServlet 转发的动态请求（Controller），不拦截静态资源（如.html/.css），属于 Spring MVC 体系的核心组件，区别于 Filter是servlet规范。与 Spring 容器深度集成，可注入 Service、Mapper 等 Bean，便于调用业务逻辑；同样用于处理通用性请求

#### 步骤 1：自定义拦截器（实现 HandlerInterceptor 接口）

核心是重写`preHandle`（前置拦截，核心逻辑）、`postHandle`（后置处理）、`afterCompletion`（完成处理）三个方法，按需实现业务逻辑。类上添加 `@Component` 注解，将拦截器交给 Spring IOC 容器管理（后续配置时需注入）

#### 步骤 2：注册拦截器（配置 WebMvcConfigurer）

通过实现`WebMvcConfigurer`接口的`addInterceptors`方法，将自定义拦截器注册到 Spring MVC，并指定拦截 / 排除的 URL 规则（细粒度控制）。



1. HTML（超文本标记语言）—— 网页的 “骨架”

- **核心作用**：定义网页的**结构和内容**，告诉浏览器 “显示什么”，是网页的基础载体。

- 核心功能

	- 用标签（如 `<div>`/`<p>`/`<img>`/`<a>`/`<input>`）组织文本、图片、链接、表单等内容；
	- 通过语义化标签（如 `<header>`/`<nav>`/`<article>`/`<footer>`）明确内容含义，提升可读性和 SEO；
	- 构建基础交互结构（如表单、按钮），但仅提供静态结构，无动态行为。

2. CSS（层叠样式表）—— 网页的 “外观”

- **核心作用**：控制网页的**样式和布局**，告诉浏览器 “怎么显示”，让页面美观且适配不同设备。

- 核心功能

	- 样式美化：设置字体、颜色、背景、边框、阴影等视觉样式；
	- 布局控制：通过 Flex、Grid、浮动、定位等实现页面元素的排列（如居中、分栏、响应式布局）；
	- 适配优化：媒体查询实现移动端 / PC 端自适应，保证不同设备下的显示效果；
	- 样式复用：通过类选择器、CSS 变量、预处理器（Less/Sass）简化样式开发。

3. JavaScript —— 网页的 “行为”

- **核心作用**：实现网页的**动态交互和逻辑**，告诉浏览器 “做什么”，让页面从静态变为动态。

- 核心功能

	- 交互处理：监听并响应用户操作（点击、输入、滚动、拖拽等）；
	- DOM 操作：动态修改 HTML/CSS（如新增 / 删除元素、修改样式、隐藏 / 显示内容）；
	- 数据处理：发起网络请求（AJAX/Fetch）获取后端数据，处理数据格式（JSON）；
	- 逻辑控制：实现表单校验、倒计时、轮播图、弹窗等业务逻辑；
	- 高级能力：结合 Web API 实现本地存储（localStorage）、画布绘图（Canvas）、音视频控制等。





