1. #### **HashMap底层原理**

HashMap的底层结构在jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现，以数组+链表的结构为例。![img](https://i-blog.csdnimg.cn/blog_migrate/94f172bde567e38c9f36cf8ef41e31ee.png)![img](https://i-blog.csdnimg.cn/blog_migrate/f72f5a11d3e018e07e0e3d0bf13fd2d4.png)

### 一、核心存储结构（JDK8 核心）

HashMap 的底层是一个**哈希桶数组**（`Node[] table`），每个桶的元素分为两种形态：

1. **链表节点（Node）**：当多个键值对哈希到同一个桶时，先以单向链表串联；
2. **红黑树节点（TreeNode）**：当链表长度≥8 且数组容量≥64 时，链表转为红黑树（查询复杂度从 O (n) 降为 O (logn)）；若红黑树节点数≤6，转回链表（避免少量元素时红黑树旋转开销）。

### 二、哈希计算（定位桶下标）

HashMap 通过 “哈希值计算→扰动→取模” 三步定位键值对的数组下标，核心是减少哈希冲突：

1. **计算 key 的哈希值**：调用`key.hashCode()`获取对象的哈希值（int 类型，范围 - 2^31~2^31-1）；
2. **扰动函数优化**：对哈希值做二次哈希（`h ^ (h >>> 16)`），将高 16 位与低 16 位混合，减少因哈希值高位不同、低位相同导致的冲突；
3. **取模定位下标**：用优化后的哈希值对数组长度取模（`hash & (length-1)`），等价于`hash % length`（但位运算更快），要求数组长度必须是 2 的幂（保证取模结果均匀）。

### 三、哈希冲突处理

哈希冲突指不同 key 计算出相同的桶下标，HashMap 分两步处理：

1. 链表阶段：新节点以 “尾插法”（JDK8）加入链表（JDK7 是头插法，易导致并发死循环），先比较 key 的哈希值，再通过`==`或`equals()`判断 key 是否重复：
   - 若 key 重复：覆盖原 value；
   - 若 key 不重复：新增节点到链表尾部；
2. **红黑树阶段**：当链表长度≥8 且数组容量≥64 时，链表转为红黑树（平衡二叉树），按 key 的哈希值排序，进一步降低查询耗时。

### 四、扩容机制（resize）

当 HashMap 的元素数量（size）超过 “数组容量 × 负载因子”（默认负载因子 0.75）时，触发扩容，核心步骤：

1. **扩容规则**：数组容量翻倍（2^n → 2^(n+1)），保证容量始终是 2 的幂；
2. **重新哈希**：遍历原数组所有桶，将节点重新计算下标（因容量翻倍，`hash & (newLength-1)`结果仅需判断哈希值的第 n 位是 0 还是 1，无需重新计算哈希值，优化性能）；
3. 节点迁移
   - 链表节点：按新下标分为两组，直接迁移（无需重新排序）；
   - 红黑树节点：若迁移后节点数≤6，转回链表，否则保持红黑树；
4. **负载因子的意义**：默认 0.75 是时间 / 空间的平衡 —— 值太高（如 1）会减少扩容次数，但冲突概率升高；值太低（如 0.5）会降低冲突，但扩容频繁、空间浪费。

### 五、核心细节（避坑点）

1. **null 值处理**：允许 key 为 null（仅一个），null 的哈希值固定为 0，直接定位到数组 0 号桶；
2. **线程安全**：非线程安全，并发修改（如多线程 put）可能导致链表成环、数据丢失，需用 ConcurrentHashMap 替代；
3. **初始容量**：默认初始容量 16，若提前知道数据量，建议指定初始容量（如`new HashMap(100)`），避免频繁扩容；
4. JDK7 vs JDK8 差异
   - JDK7：数组 + 链表，头插法，无红黑树；
   - JDK8：数组 + 链表 + 红黑树，尾插法，扰动函数优化，扩容重新哈希更高效。



HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。

JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。

补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。

这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 treeifyBin方法。

当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。




2. #### **JVM内存分哪几个区，每个区的作用是什么** 

![img](https://i-blog.csdnimg.cn/blog_migrate/33df2502dd158c62f76f4aa5f26376ec.png)

### 一、线程私有区域（每个线程独立拥有，随线程创建 / 销毁）

#### 1. 程序计数器（Program Counter Register）

- 作用：记录当前线程执行的字节码指令地址（行号），是 JVM 中唯一不会抛出`OutOfMemoryError`的区域；
  - 线程切换时，通过程序计数器恢复当前线程的执行位置，保证线程切换后能继续执行；
  - 若线程执行的是 Native 方法（如 JNI 调用），计数器值为 undefined。
- **特点**：占用内存极小，生命周期与线程一致。

#### 2. 虚拟机栈（VM Stack）

- 作用：存储方法执行的 “栈帧”（每个方法调用对应一个栈帧），栈帧包含局部变量表、操作数栈、方法出口等；
  - 局部变量表：存储方法内的局部变量（基本类型、对象引用、returnAddress 类型），大小在编译期确定；
  - 方法调用时创建栈帧入栈，方法执行完出栈，栈帧的入栈 / 出栈对应方法的调用 / 结束。
- **异常**：栈深度超过虚拟机允许的范围（如递归无终止），抛出`StackOverflowError`；栈容量动态扩展时内存不足，抛出`OutOfMemoryError`。

#### 3. 本地方法栈（Native Method Stack）

- **作用**：与虚拟机栈功能类似，但专门服务于 Native 方法（如 Java 调用 C/C++ 编写的方法）；
- **特点**：HotSpot 虚拟机将虚拟机栈和本地方法栈合并实现；同样会抛出`StackOverflowError`和`OutOfMemoryError`。

### 二、线程共享区域（所有线程共用，随 JVM 启动 / 关闭）

#### 1. 堆（Heap）

- 作用：JVM 中最大的内存区域，唯一目的是存储对象实例（几乎所有对象都在堆上分配），是垃圾回收（GC）的核心区域；
  - 堆被划分为 “新生代” 和 “老年代”（更细分为 Eden 区、Survivor 区（From/To）、Old 区），GC 主要针对堆进行：
    - 新生代：存储新创建的对象，GC 频率高（Minor GC），采用复制算法，回收效率高；
    - 老年代：存储新生代中多次 GC 后仍存活的对象，GC 频率低（Major GC/Full GC），采用标记 - 清除 / 标记 - 整理算法。
- **异常**：堆内存不足（如创建大量大对象无法回收），抛出`OutOfMemoryError: Java heap space`。
- **特点**：可通过`-Xms`（初始堆大小）、`-Xmx`（最大堆大小）配置，是 JVM 调优的核心区域。

#### 2. 元空间（Metaspace，JDK8 替代永久代）

- 作用：存储类的元数据（类的结构信息：类名、方法、字段、常量池、静态变量、方法字节码等），以及方法区的其他内容（如运行时常量池）；
  - 运行时常量池：是类常量池的运行时版本，存储字面量（如字符串常量）和符号引用，`String.intern()`就是利用运行时常量池实现；
- **区别于永久代**：元空间不再占用 JVM 堆内存，而是使用本地内存（操作系统内存），默认无固定大小限制（可通过`-XX:MetaspaceSize`/`-XX:MaxMetaspaceSize`限制）；
- **异常**：元空间内存不足（如加载大量类未卸载），抛出`OutOfMemoryError: Metaspace`。



3. #### **Java中垃圾收集的方法有哪些**

#### 复制算法（Copying）

- **核心逻辑**：将内存划分为大小相等的两块（如新生代的 Eden 区 + Survivor 区），仅使用其中一块；当这块内存满时，将存活对象复制到另一块，然后清空当前块的所有数据。
- **适用场景**：新生代（对象存活率低，复制成本低），HotSpot 中新生代分为 Eden（8/10）、From Survivor（1/10）、To Survivor（1/10），每次 Minor GC 只复制 Eden+From 中的存活对象到 To 区。
- **优点**：回收后内存无碎片，效率高；
- **缺点**：浪费一半内存（优化后仅用 1/10 内存作为 Survivor，大幅降低浪费）。

#### 2. 标记 - 清除算法（Mark-Sweep）

- **核心逻辑**：分两步执行 ——① 标记：遍历所有对象，标记出可达（存活）的对象；② 清除：遍历内存，清除未被标记的对象（垃圾）。
- **适用场景**：老年代（对象存活率高，复制成本高）。
- **优点**：无需额外内存空间；
- **缺点**：① 回收后内存碎片化严重（大量不连续的空闲内存，大对象可能无法分配）；② 效率低（标记 + 清除两次全量遍历）。

#### 3. 标记 - 整理算法（Mark-Compact）

- **核心逻辑**：在标记 - 清除的基础上增加 “整理” 步骤 ——① 标记存活对象；② 将所有存活对象向内存一端移动，然后清空另一端的所有内存。
- **适用场景**：老年代（解决标记 - 清除的内存碎片问题）。
- **优点**：无内存碎片，适合存储大对象；
- **缺点**：整理阶段需要移动对象，耗时较长（效率略低于标记 - 



4. #### **如何判断一个对象是否存活(或者GC对象的判定方法)**

- 引用计数法
  所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
- 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

- 可达性算法(引用链法)
  该算法的基本思路就是通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。
  在java中可以作为GC Roots的对象有以下几种：虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈JNI引用的对象。

5. #### **什么情况下会产生StackOverflowError（栈溢出）和OutOfMemoryError（堆溢出）怎么排查**

### 一、StackOverflowError（栈溢出）

#### 1. 产生场景（核心：虚拟机栈深度超过阈值）

虚拟机栈用于存储方法栈帧，当方法调用深度超出 JVM 允许的栈深度上限时触发，常见场景：

- **无限递归调用**：最典型场景，如递归方法无终止条件（如计算阶乘时递归基例写错），每次递归创建新栈帧，栈深度持续增加；
- **方法调用链过深**：非递归但调用层级极深（如多层嵌套的业务方法、框架级别的深度调用）；
- **虚拟机栈容量过小**：通过`-Xss`（如`-Xss128k`）设置了过小的栈容量，正常调用链也超出阈值。

### 二、OutOfMemoryError（内存溢出）—— 重点说堆溢出（Java heap space）

#### 1. 堆溢出产生场景（核心：堆内存不足，无法分配新对象）

堆是存储对象实例的核心区域，当对象持续创建且无法被 GC 回收（内存泄漏），或堆容量不足以承载正常业务对象时触发：

- **内存泄漏**：对象被无用但可达的引用持有（如静态集合缓存大量对象不清理、连接池未关闭导致连接对象泄漏、ThreadLocal 未移除导致线程池线程持有对象），GC 无法回收，堆内存逐步耗尽；
- **内存溢出（无泄漏）**：业务需要创建大量大对象 / 数组（如一次性加载 100 万条数据库记录到内存），堆容量不足以支撑，即使 GC 回收了所有无用对象，仍无足够空间分配新对象；
- **堆配置过小**：`-Xms`（初始堆）/`-Xmx`（最大堆）设置过小（如`-Xmx256m`），无法满足正常业务需求。

1. 排查：可以通过jvisualvm进行内存快照分析



7. 为什么要使用线程池

线程池核心是解决线程频繁创建销毁的性能损耗问题，做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最 大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。

第一:降低资源消耗。通过重复利用己创建的线程降低线程创建和销毁造成的消耗。

第二:提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

第三:提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进 行统一的分配，调优和监控


8. #### **线程池底层工作原理**

![img](https://i-blog.csdnimg.cn/blog_migrate/35a8f50ff016795fa2e9b79f034d8d3e.png)

第一步：线程池刚创建的时候，里面没有任何线程，等到有任务过来的时候才会创建线程。当然也可以调用 prestartAllCoreThreads() 或者 prestartCoreThread() 方法预创建corePoolSize个线程
第二步：调用execute()提交一个任务时，如果当前的工作线程数<corePoolSize，直接创建新的线程执行这个任务
第三步：如果当时工作线程数量>=corePoolSize，会将任务放入任务队列中缓存
第四步：如果队列已满，并且线程池中工作线程的数量<maximumPoolSize，还是会创建线程执行这个任务
第五步：如果队列已满，并且线程池中的线程已达到maximumPoolSize，这个时候会执行拒绝策略，JAVA线程池默认的策略是AbortPolicy，即抛出RejectedExecutionException异常

9. #### ThreadPoolExecutor对象有哪些参数 怎么设定核心线程数和最大线程数 拒绝策略有哪些 

   **参数与作用：共7个参数**

- corePoolSize：核心线程数，
  在ThreadPoolExecutor中有一个与它相关的配置：allowCoreThreadTimeOut（默认为false），当allowCoreThreadTimeOut为false时，核心线程会一直存活，哪怕是一直空闲着。而当allowCoreThreadTimeOut为true时核心线程空闲时间超过keepAliveTime时会被回收。

- maximumPoolSize：最大线程数
  线程池能容纳的最大线程数，当线程池中的线程达到最大时，此时添加任务将会采用拒绝策略，默认的拒绝策略是抛出一个运行时错误（RejectedExecutionException）。值得一提的是，当初始化时用的工作队列为LinkedBlockingDeque时，这个值将无效。

- keepAliveTime：存活时间，
  当非核心空闲超过这个时间将被回收，同时空闲核心线程是否回收受allowCoreThreadTimeOut影响。

- unit：keepAliveTime的单位。
- workQueue：任务队列
  常用有三种队列，即SynchronousQueue,LinkedBlockingDeque（无界队列）,ArrayBlockingQueue（有界队列）。

- threadFactory：线程工厂，
  ThreadFactory是一个接口，用来创建worker。通过线程工厂可以对线程的一些属性进行定制。默认直接新建线程。

- RejectedExecutionHandler：拒绝策略
  也是一个接口，只有一个方法，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution法。默认是抛出一个运行时异常。

**线程池大小设置：**

需要分析线程池执行的任务的特性： CPU 密集型还是 IO 密集型

每个任务执行的平均时长大概是多少，这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系

如果是 CPU 密集型，主要是执行计算任务，响应时间很快，cpu 一直在运行，这种任务 cpu的利用率很高，那么线程数的配置应该根据 CPU 核心数来决定，CPU 核心数=最大同时执行线程数，加入 CPU 核心数为 4，那么服务器最多能同时执行 4 个线程。过多的线程会导致上下文切换反而使得效率降低。那线程池的最大线程数可以配置为 cpu 核心数+1 如果是 IO 密集型，主要是进行 IO 操作，执行 IO 操作的时间较长，这是 cpu 出于空闲状态，导致 cpu 的利用率不高，这种情况下可以增加线程池的大小。这种情况下可以结合线程的等待时长来做判断，等待时间越高，那么线程数也相对越多。一般可以配置 cpu 核心数的 2 倍。

一个公式：线程池设定最佳线程数目 = （（线程池设定的线程等待时间+线程 CPU 时间）/
线程 CPU 时间 ）* CPU 数目

这个公式的线程 cpu 时间是预估的程序单个线程在 cpu 上运行的时间（通常使用 loadrunner测试大量运行次数求出平均值）

**拒绝策略：**

AbortPolicy：直接抛出异常，默认策略；
CallerRunsPolicy：用调用者所在的线程来执行任务；
DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
DiscardPolicy：直接丢弃任务；当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务

10. 常见线程安全的并发容器有哪些

常见的线程安全并发容器可按核心用途分类，核心如下：

1. **ConcurrentHashMap**：线程安全的 HashMap 替代方案，JDK8 用 CAS + 分段锁（局部锁）替代 Hashtable 的全局锁，高并发下性能更优，支持高效的键值对存取；
2. **CopyOnWriteArrayList**：线程安全的 List 替代方案，读操作无锁，写操作复制底层数组后修改，适合读多写少场景（如配置列表）；
3. **CopyOnWriteArraySet**：基于 CopyOnWriteArrayList 实现，线程安全的 Set，同样适配读多写少；
4. **ConcurrentLinkedQueue/Deque**：无锁的并发队列 / 双端队列，基于 CAS 实现，适合高并发的队列操作（如生产者消费者模型）；
5. **BlockingQueue 系列**（如 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue）：阻塞队列，支持阻塞式的入队 / 出队，是线程池的核心底层容器；
6. **ConcurrentSkipListMap/Set**：线程安全的有序映射 / 集合，基于跳表实现，替代同步版的 TreeMap/TreeSet，支持高效的有序遍历和查找。

核心特点：这类容器通过 CAS、分段锁、写时复制等机制实现线程安全，相比 Hashtable、同步包装类（Collections.synchronizedXxx），并发性能更优，适配不同的并发场景（读多写少、高并发读写、阻塞操作等）。



11. synchronized底层实现是什么 lock底层是什么 有什么区别

12. ### 1. synchronized 底层实现

    - **方法级同步**：通过方法常量池`method_info`结构中的`ACC_SYNCHRONIZED`访问标志实现。调用方法时，JVM 检查该标志，若设置则先获取 monitor（管程），执行方法后释放 monitor。
    - **代码块同步**：依赖`monitorenter`和`monitorexit`字节码指令。执行`monitorenter`时，线程尝试获取 monitor 所有权（未加锁 / 已持有则计数器 + 1）；执行`monitorexit`时计数器 - 1，计数器为 0 则释放锁；获取失败则线程阻塞。



**Lock原理：**

Lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）
Lock获取锁的过程：本质上是通过CAS来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。
Lock释放锁的过程：修改状态值，调整等待链表。
Lock大量使用CAS+自旋。因此根据CAS特性，lock建议使用在低锁冲突的情况下。
**Lock与synchronized的区别：**

Lock的加锁和解锁都是由java代码配合native方法（调用操作系统的相关方法）实现的，而synchronize的加锁和解锁的过程是由JVM管理的
当一个线程使用synchronize获取锁时，若锁被其他线程占用着，那么当前只能被阻塞，直到成功获取锁。而Lock则提供超时锁和可中断等更加灵活的方式，在未能获取锁的     条件下提供一种退出的机制。
一个锁内部可以有多个Condition实例，即有多路条件队列，而synchronize只有一路条件队列；同样Condition也提供灵活的阻塞方式，在未获得通知之前可以通过中断线程以    及设置等待时限等方式退出条件队列。
synchronize对线程的同步仅提供独占模式，而Lock即可以提供独占模式，也可以提供共享模式

13. 了解ConcurrentHashMap吗 为什么性能比HashTable高，说下原理    难度系数：⭐⭐
    ConcurrentHashMap是线程安全的Map容器，JDK8之前，ConcurrentHashMap使用锁分段技术，将数据分成一段段存储，每个数据段配置一把锁，即segment类，这个类继承ReentrantLock来保证线程安全，JKD8的版本取消Segment这个分段锁数据结构，底层也是使用Node数组+链表+红黑树，从而实现对每一段数据就行加锁，也减少了并发冲突的概率。

hashtable类基本上所有的方法都是采用synchronized进行线程安全控制，高并发情况下效率就降低 ，ConcurrentHashMap是采用了分段锁的思想提高性能，锁粒度更细化

14. ConcurrentHashMap底层原理    难度系数：⭐⭐⭐
    Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。



15. 了解volatile关键字不    难度系数：⭐
    volatile是Java提供的最轻量级的同步机制，保证了共享变量的可见性，被volatile关键字修饰的变量，如果值发生了变化，其他线程立刻可见，避免出现脏读现象。
    volatile禁止了指令重排，可以保证程序执行的有序性，但是由于禁止了指令重排，所以JVM相关的优化没了，效率会偏弱

16. synchronized和volatile有什么区别    难度系数：⭐⭐
    volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
    volatile仅能用在变量级别，而synchronized可以使用在变量、方法、类级别。
    volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
    volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。
    volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化。

    

    

17. Java类加载过程    难度系数：⭐

加载 加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：
通过一个类的全限定名获取该类的二进制流。

将该二进制流中的静态存储结构转化为方法去运行时数据结构。 

在内存中生成该类的Class对象，作为该类的数据访问入口。

验证 验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:
文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.

元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。

字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。

符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

准备
准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

解析
该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

初始化
初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

18. 什么是类加载器，类加载器有哪些  难度系数：⭐
    类加载器就是把类文件加载到虚拟机中，也就是说通过一个类的全限定名来获取描述该类的二进制字节流。

主要有以下四种类加载器
启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用

扩展类加载器(extension class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类

系统类加载器（system class loader）也叫应用类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它

用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现

什么时候会使用到加载器？java中的加载器是按需加载，什么时候用到，什么时候加载
new对象的时候
访问某个类或者接口的静态变量，或者对该静态变量赋值时
调用类的静态方法时
反射
初始化一个类的子类时，其父类首先会被加载
JVM启动时标明的启动类，也就是文件名和类名相同的那个类



19. 简述java内存分配与回收策略以及Minor GC和Major GC（full GC）     难度系数：⭐⭐
    内存分配
    栈区：栈分为java虚拟机栈和本地方法栈

堆区：堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。

方法区：被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）

程序计数器：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。

回收策略以及Minor GC和Major GC
对象优先在堆的Eden区分配
大对象直接进入老年代
长期存活的对象将直接进入老年代
当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。

20、如何查看java死锁     难度系数：⭐
####演示死锁
package com.ssg.mst;
public class 死锁 {

    private static final String lock1 = "lock1";
    private static final String lock2 = "lock2";
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            while (true) {
                synchronized (lock1) {
                    try {
                        System.out.println(Thread.currentThread().getName() + lock1);
                        Thread.sleep(1000);
                        synchronized (lock2){
                            System.out.println(Thread.currentThread().getName() + lock2);
                        }
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });
     
        Thread thread2 = new Thread(() -> {
            while (true) {
                synchronized (lock2) {
                    try {
                        System.out.println(Thread.currentThread().getName() + lock2);
                        Thread.sleep(1000);
                        synchronized (lock1){
                            System.out.println(Thread.currentThread().getName() + lock1);
                        }
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });
     
        thread1.start();
        thread2.start();
    }
}
运行项目并下载源码

Java

死锁代码演示

程序运行，进程没有停止。


通过jps查看java进程，找到没有停止的进程

通过jstack 9060 查看进程具体执行信息





21. Java死锁如何避免     难度系数：⭐

    造成死锁的几个原因

1.一个资源每次只能被一个线程使用

2.一个线程在阻塞等待某个资源时，不释放已占有资源

3.一个线程已经获得的资源，在未使用完之前，不能被强行剥夺

4.若干线程形成头尾相接的循环等待资源关系

这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满足其中某一个条件即可。而其中前3个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。

在开发过程中

1.要注意加锁顺序，保证每个线程按同样的顺序进行加锁

2.要注意加锁时限，可以针对锁设置一个超时时间

3.要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决