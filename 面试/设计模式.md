Java 开发中常用的设计模式可按**创建型、结构型、行为型**三大类划分，以下是高频使用的模式，附核心思想、典型应用场景和极简代码示例：

## 一、创建型模式（聚焦 “对象创建”，解耦创建逻辑与使用逻辑）

### 1. 单例模式（Singleton）

- **核心思想**：保证一个类仅有一个实例，并提供全局访问点。
- **应用场景**：配置类、工具类、连接池（如`java.lang.Runtime`、Spring Bean 默认单例）。
- **常见实现**：懒汉式（双重检查锁）、饿汉式、枚举式（推荐，避免反射破坏）。

```java
// 枚举单例（线程安全+防反射）
enum Singleton {
    INSTANCE;
    public void doSomething() {
        System.out.println("单例执行操作");
    }
}
// 使用：Singleton.INSTANCE.doSomething();
```

### 2. 工厂模式（Factory）

#### （1）简单工厂（非 GOF 标准，但最常用）

- **核心**：一个工厂类根据参数创建不同实例，隐藏创建细节。
- **场景**：日志框架（创建不同日志实现）、数据库连接（MySQL/Oracle 切换）

```java
class SimpleFactory {
    public static Product createProduct(String type) {
        if ("A".equals(type)) return new ProductA();
        if ("B".equals(type)) return new ProductB();
        return null;
    }
}
interface Product {}
class ProductA implements Product {}
class ProductB implements Product {}
```

#### （2）工厂方法

- **核心**：将实例创建延迟到子类，每个产品对应一个工厂。
- **场景**：Spring 的`FactoryBean`、MyBatis 的`SqlSessionFactory`。

#### （3）抽象工厂

- **核心**：创建一系列相关产品，无需指定具体类。
- **场景**：跨平台组件（Windows/Mac 风格的按钮 + 面板）。

### 3. 建造者模式（Builder）

- **核心思想**：分步构建复杂对象，解耦 “对象属性设置” 与 “对象创建”。
- **应用场景**：复杂 POJO（如`StringBuilder`、MyBatis 的`SqlBuilder`、Lombok 的`@Builder`）。

```java
class User {
    private String name;
    private int age;
    // 私有构造
    private User(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
    }
    // 建造者内部类
    static class Builder {
        private String name;
        private int age;
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        public User build() {
            return new User(this);
        }
    }
}
// 使用：User user = new User.Builder().name("张三").age(20).build();
```



## 二、结构型模式（聚焦 “类 / 对象的组合结构”，提升代码灵活性）

### 1. 代理模式（Proxy）

- **核心思想**：为目标对象提供代理，控制对目标对象的访问（增强功能）。
- **应用场景**：Spring AOP、RPC 代理、缓存代理、权限控制。

#### （1）静态代理

```java
interface Target {
    void execute();
}
// 目标类
class TargetImpl implements Target {
    @Override
    public void execute() {
        System.out.println("执行核心逻辑");
    }
}
// 代理类
class Proxy implements Target {
    private Target target;
    public Proxy(Target target) {
        this.target = target;
    }
    @Override
    public void execute() {
        System.out.println("前置增强（如日志）");
        target.execute();
        System.out.println("后置增强（如统计）");
    }
}
```

#### （2）动态代理

JDK 动态代理（基于接口）、CGLIB 动态代理（基于子类），是 Spring AOP 的底层实现。

### 2. 装饰器模式（Decorator）

- **核心思想**：动态给对象添加功能，避免继承的臃肿。
- **应用场景**：`java.io`包（`InputStream`/`OutputStream`的包装，如`BufferedInputStream`）、Spring 的`BeanWrapper`。

```java
interface Component {
    void operation();
}
// 基础组件
class ConcreteComponent implements Component {
    @Override
    public void operation() {
        System.out.println("基础功能");
    }
}
// 装饰器基类
abstract class Decorator implements Component {
    protected Component component;
    public Decorator(Component component) {
        this.component = component;
    }
}
// 具体装饰器（添加功能）
class LogDecorator extends Decorator {
    public LogDecorator(Component component) {
        super(component);
    }
    @Override
    public void operation() {
        System.out.println("添加日志功能");
        component.operation();
    }
}
// 使用：Component c = new LogDecorator(new ConcreteComponent());
```

### 3. 适配器模式（Adapter）

- **核心思想**：将一个类的接口转换成客户端期望的另一个接口，解决接口不兼容问题。
- **应用场景**：JDBC 驱动适配、SpringMVC 的`HandlerAdapter`、`java.util.Arrays.asList()`。



```java
// 目标接口
interface TargetInterface {
    void targetMethod();
}
// 待适配的类
class Adaptee {
    public void adapteeMethod() {
        System.out.println("适配者原有方法");
    }
}
// 适配器
class Adapter extends Adaptee implements TargetInterface {
    @Override
    public void targetMethod() {
        adapteeMethod(); // 适配原有方法
    }
}
```

### 三、行为型模式（聚焦 “对象间的交互与职责分配”，提升代码协作性）

### 1. 观察者模式（Observer）

- **核心思想**：定义一对多依赖，当被观察者状态变化时，通知所有观察者。
- **应用场景**：Spring 的事件监听（`ApplicationEvent`/`ApplicationListener`）、GUI 事件、消息通知。

```java
// 被观察者
interface Observable {
    void addObserver(Observer o);
    void notifyObservers();
}
// 观察者
interface Observer {
    void update();
}
class ConcreteObservable implements Observable {
    private List<Observer> observers = new ArrayList<>();
    @Override
    public void addObserver(Observer o) {
        observers.add(o);
    }
    @Override
    public void notifyObservers() {
        observers.forEach(Observer::update);
    }
}
```

### 2. 策略模式（Strategy）

- **核心思想**：定义一系列算法，封装成独立策略类，可动态切换。
- **应用场景**：排序算法（`Comparator`）、支付方式（微信 / 支付宝）、Spring 的`Resource`加载策略。

```java
// 策略接口
interface Strategy {
    int calculate(int a, int b);
}
// 具体策略1
class AddStrategy implements Strategy {
    @Override
    public int calculate(int a, int b) {
        return a + b;
    }
}
// 上下文（使用策略）
class Context {
    private Strategy strategy;
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    public int execute(int a, int b) {
        return strategy.calculate(a, b);
    }
}
// 使用：new Context(new AddStrategy()).execute(1,2);
```

### 3. 模板方法模式（Template Method）

- **核心思想**：定义算法骨架，将可变步骤延迟到子类实现。
- **应用场景**：Spring 的`JdbcTemplate`、Servlet 的`doGet/doPost`、单元测试框架的`setUp/tearDown`。

```java
abstract class AbstractTemplate {
    // 模板方法（固定骨架）
    public final void templateMethod() {
        step1();
        step2(); // 可变步骤
        step3();
    }
    private void step1() { System.out.println("固定步骤1"); }
    protected abstract void step2(); // 子类实现
    private void step3() { System.out.println("固定步骤3"); }
}
// 具体实现
class ConcreteTemplate extends AbstractTemplate {
    @Override
    protected void step2() {
        System.out.println("子类实现步骤2");
    }
}
```

### 5. 责任链模式（Chain of Responsibility）

- **核心思想**：将请求的处理者连成链，请求沿链传递，直到被处理。
- **应用场景**：SpringMVC 的`HandlerInterceptor`、过滤器（`Filter`）、权限校验链、异常处理链。

```java
// 处理者接口
interface Handler {
    void handleRequest(String request, Handler next);
}
// 具体处理者
class AuthHandler implements Handler {
    @Override
    public void handleRequest(String request, Handler next) {
        if ("需要认证".equals(request)) {
            System.out.println("认证通过");
        }
        if (next != null) {
            next.handleRequest(request, null);
        }
    }
}
```

## 四、核心总结（高频模式 + 记忆要点）

| 分类   | 高频模式                   | 核心解决问题                   | 典型 JDK/Spring 应用                        |
| ------ | -------------------------- | ------------------------------ | ------------------------------------------- |
| 创建型 | 单例、工厂、建造者         | 对象创建的灵活性、可控性       | `Runtime`、`LoggerFactory`、`StringBuilder` |
| 结构型 | 代理、装饰器、适配器、门面 | 类 / 对象组合的灵活性、兼容性  | `InputStream`、`AOP代理`、`SqlSession`      |
| 行为型 | 观察者、策略、模板方法     | 对象交互的解耦、算法的可替换性 | `Observer`、`Comparator`、`JdbcTemplate`    |

### 设计模式核心原则

1. **开闭原则**：对扩展开放，对修改关闭（如策略模式、装饰器模式）；
2. **单一职责**：一个类只做一件事（所有模式的基础）；
3. **依赖倒置**：依赖抽象，不依赖具体（如工厂、策略模式）；
4. **里氏替换**：子类可替换父类且不改变程序逻辑；
5. **迪米特法则**：最少知道原则（如门面模式）。

实际开发中无需刻意套用模式，而是 “遇问题选模式”—— 比如需要动态加功能用装饰器，需要统一入口用门面，需要解耦创建逻辑用工厂。