使用 Git 版本控制的核心价值是**解决多人协作、代码追溯、版本管理、环境安全**等开发过程中的核心痛点，是现代软件开发（尤其是团队开发）的标配工具，具体原因可归纳为以下几点：

### 1. 彻底解决 “代码混乱” 问题，追溯全量历史

- **版本回溯**：可随时回滚到任意历史版本（比如修复线上 bug 时，快速切回上一个稳定版本），避免代码改错 / 删错后无法恢复；
- **变更追踪**：记录每一行代码的修改人、修改时间、修改原因（通过 commit 备注），清晰知道 “谁改了什么、为什么改”，定位问题时可快速溯源；
- **增量存储**：Git 只保存代码的变更差异（而非完整复制），占用空间小，且历史记录永不丢失（除非主动删除）。

### 2. 支撑高效的多人协作，避免代码冲突

- **分支隔离**：每个人在独立分支（如 feature/xxx、bugfix/xxx）开发，互不干扰；比如前端开发新功能、后端修复 bug 可并行进行，不会互相覆盖代码；
- **冲突可视化解决**：多人修改同一文件时，Git 会标记冲突位置，提供清晰的对比界面，方便手动合并，避免 “本地代码覆盖他人代码” 的低级错误；
- **远程同步**：通过远程仓库（GitHub/GitLab/Gitee）实现代码共享，团队成员可随时拉取最新代码、推送自己的修改，同步成本极低。

### 3. 管控开发流程，降低风险

- **版本管理标准化**：通过分支规范（如 master/main 存稳定代码、dev 存开发代码、release 存发布代码），管控 “开发→测试→发布” 流程，避免直接在生产分支修改代码；
- **暂存与撤销**：通过 `git stash` 暂存未完成的代码（比如临时切换分支修复 bug），通过 `git reset/git revert` 安全撤销修改，不影响已完成的代码；
- **标签标记发布版本**：用 `git tag` 标记发布版本（如 v1.0.0），后续可快速切回该版本排查问题、发布补丁。

### 4. 提升开发效率，适配现代开发模式

- **离线工作**：Git 是分布式版本控制，本地即可完成提交、分支创建、历史查看等操作，无需一直连网；仅需推送 / 拉取时同步远程仓库；
- **集成开发工具**：几乎所有 IDE（IDEA/Eclipse/Vscode）、CI/CD 工具（Jenkins/GitLab CI）都深度支持 Git，可一键提交、构建、部署；
- **开源协作友好**：通过 Fork + Pull Request 模式，支持外部开发者贡献代码，是开源项目协作的标准方式。



#### 工作中git开发使用流程（命令版描述）

## 一、基础准备（首次 / 新环境）



```bash
# 1. 克隆远程仓库到本地（首次拉取）
git clone <仓库地址>  # 例：git clone git@github.com:xxx/project.git
cd project  # 进入项目目录

# 2. 配置用户信息（区分提交者，仅首次）
git config --global user.name "你的姓名"
git config --global user.email "你的邮箱"
```

## 二、日常开发流程（核心）

### 步骤 1：拉取主干最新代码（避免冲突）

```bash
# 切换到主干分支（master/main，团队统一）
git checkout main

# 拉取远程主干最新代码（同步团队更新）
git pull origin main
```

### 步骤 2：创建功能分支（隔离开发，规范命名：feature/xxx、bugfix/xxx）

```bash
# 创建并切换到功能分支（例：开发用户模块）
git checkout -b feature/user-module

# 或修复bug分支（例：修复登录bug）
git checkout -b bugfix/login-error
```

### 步骤 3：开发过程中提交代码（高频操作）

```bash
# 1. 查看修改文件（确认变更）
git status

# 2. 将修改文件加入暂存区（.表示所有修改，也可指定文件）
git add .  # 或 git add src/user/xxx.java

# 3. 提交暂存区代码（备注清晰：动词+内容，例：新增用户列表接口）
git commit -m "feat: 新增用户列表查询接口"
# 规范备注前缀：feat(功能)、fix(修复)、docs(文档)、style(格式)、refactor(重构)、test(测试)

# （可选）若提交后想补充修改，合并到上一次提交（避免冗余提交）
git commit --amend
```

### 步骤 4：推送分支到远程（备份 / 提测 / 合并）

```bash
# 首次推送分支到远程（关联本地与远程分支）
git push -u origin feature/user-module

# 非首次推送（直接推送）
git push origin feature/user-module
```

### 步骤 5：解决分支冲突（若远程主干有更新，先同步再提合并）

```bash
# 1. 切换回主干并拉取最新代码
git checkout main
git pull origin main

# 2. 切回功能分支，合并主干代码（解决冲突）
git checkout feature/user-module
git merge main

# 3. 若出现冲突，手动修改冲突文件（编辑器中会标记<<<<<<< HEAD 等冲突区）
# 修改后重新提交冲突解决结果
git add .
git commit -m "merge: 解决主干合并的用户接口冲突"

# 4. 推送解决冲突后的分支到远程
git push origin feature/user-module
```

### 步骤 6：合并分支到主干（提 MR/PR 后，或本地合并）

#### 方式 1：团队规范（推荐）→ 提 Merge Request/Pull Request（GitLab/GitHub 界面操作）

#### 方式 2：本地合并（小型团队 / 紧急修改）

```bash
# 1. 切换到主干分支
git checkout main

# 2. 合并功能分支到主干
git merge feature/user-module

# 3. 推送合并后的主干到远程（同步到团队仓库）
git push origin main
```

### 步骤 7：清理分支（开发完成后，可选）

```bash
# 1. 删除本地功能分支
git branch -d feature/user-module

# 2. 删除远程功能分支（确认合并后）
git push origin --delete feature/user-module
```

（2）Reset 与Rebase,Pull 与 Fetch 的区别

| 操作         | 核心作用              | 关键特点                                                     |
| ------------ | --------------------- | ------------------------------------------------------------ |
| `git reset`  | 回滚提交 / 撤销暂存区 | 改写本地提交历史，分 3 种模式：1. `--soft`：仅回滚 HEAD，保留工作区 / 暂存区；2. `--mixed`（默认）：回滚 HEAD + 暂存区，保留工作区；3. `--hard`：彻底回滚，工作区 / 暂存区都清空（慎用）。 |
| `git rebase` | 变基（重组提交历史）  | 将当前分支的提交 “移植” 到目标分支最新提交之后，让提交历史线性整洁；⚠️ 已推送到远程的分支禁止 rebase（会导致团队历史冲突）。 |

| 操作        | 核心作用                   | 关键特点                                                     |
| ----------- | -------------------------- | ------------------------------------------------------------ |
| `git fetch` | 拉取远程分支更新（仅下载） | 只把远程最新代码下载到本地（更新本地远程追踪分支，如`origin/main`），不合并到本地工作分支，可先对比再决定是否合并。 |
| `git pull`  | 拉取 + 合并（fetch+merge） | 等价于 `git fetch + git merge`，直接将远程更新合并到当前本地分支；若本地有未提交修改，可能触发冲突，建议先`fetch`查看差异再`pull`。 |



（3）git merge和git rebase的区别

git merge把本地代码和已经取得的远程仓库代码合并。

git rebase是复位基底的意思，gitmerge会生成一个新的节点，之前的提交会分开显示，而rebase操作不会生成新的操作，将两个分支融合成一个线性的提交。



（4）git如何解决代码冲突

## 方式一：保留本地修改，合并远程最新代码（常用）

### 核心逻辑

先临时暂存本地未提交的修改 → 拉取远程最新代码 → 恢复本地修改并让 Git 自动合并，适合本地有未完成开发、需同步远程更新的场景。

#### 1. 命令行操作步骤

```bash
# 1. 暂存本地所有未提交的修改（命名便于识别，可选）
git stash save "暂存：未完成的用户模块开发"
# 若无需命名，直接执行：git stash

# 2. 拉取远程主干（main/master）最新代码（fetch + merge 合并）
git pull origin main

# 3. 恢复暂存的本地修改，Git 自动尝试合并
git stash pop
```

- 关键说明
	- `git stash pop` 会恢复最近一次暂存的修改，同时删除暂存记录；若想保留暂存记录，用 `git stash apply`。
	- 若合并时触发代码冲突，按「定位冲突文件→手动修改冲突标记→`git add 冲突文件`→`git commit`」解决即可。
	- 查看暂存列表：`git stash list`；删除指定暂存：`git stash drop stash@{0}`（0 为暂存索引）。

#### 2. IDEA 可视化操作步骤

```plaintext
① 打开 IDEA，确认本地有未提交修改（右下角会显示修改文件数）；
② 顶部菜单栏 → Git → Stash → Stash Changes（弹窗可输入暂存备注，点击 OK）；
③ 顶部菜单栏 → Git → Pull（弹窗选择远程分支 main，点击 Pull，拉取远程最新代码）；
④ 顶部菜单栏 → Git → Stash → Unstash Changes（选择最近一次暂存记录，点击 Unstash）；
⑤ 若有冲突，IDEA 会标红冲突文件，双击打开后：
  - 选择「Accept Yours」（保留本地）/「Accept Theirs」（保留远程）/「Merge」（手动合并）；
  - 解决后点击右上角「Commit」提交冲突即可。
```

## 方式二：放弃本地所有修改，完全覆盖为远程版本（慎用）

### 核心逻辑

通过 `reset --hard` 清空本地所有未提交的修改和提交记录 → 拉取远程最新代码，适合本地修改无效、需完全同步远程的场景（**会丢失本地未提交 / 未推送的所有修改**）。

#### 1. 命令行操作步骤

```bash
# 1. 强制回滚本地代码到与远程一致的状态（清空所有本地修改）
git reset --hard origin/main

# 2. 拉取远程最新代码（确保完全同步，可选，因 reset 已同步，但建议执行）
git pull origin main
```

- 关键说明
	- `git reset --hard` 是高危操作，会彻底删除本地未提交的修改、暂存区内容，且无法恢复；执行前务必确认本地修改无需保留。
	- 若仅想放弃某文件的本地修改，可执行 `git checkout -- 文件名`（如 `git checkout -- src/User.java`），避免全量回滚。



（5）项目开发中git分支

主干分支master：主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。

开发分支develop：主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。

bug修理分支hotfix：要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。

发布版本分支release：较大的版本上线前，会从开发分支中分出发布版本分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。

功能分支feature：为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支中独立出来。 开发完成后会合并到开发分支。

项目开发中 Git 分支管理核心遵循「分支隔离、职责明确」原则，主流采用**Git Flow 简化版**（适配中小项目）或**Git Flow 完整版**（适配大型 / 多迭代项目），以下是标准化的分支结构、职责及流转流程：

## 一、核心分支（长期存在，不可直接修改）

| 分支名称      | 核心职责                               | 操作规范                                                     |
| ------------- | -------------------------------------- | ------------------------------------------------------------ |
| `main/master` | 生产环境分支，存放可直接发布的稳定代码 | 仅通过`merge`合并`release`/`hotfix`分支，禁止直接提交 / 推送；每次合并打版本标签（如`v1.0.0`） |
| `develop`     | 开发主干分支，集成各功能开发成果       | 仅通过`merge`合并`feature`分支，禁止直接提交；作为所有功能分支的基准分支 |

## 二、临时分支（按需创建，完成后删除）

| 分支类型                 | 命名规范                                                     | 核心职责                                             | 合并目标                                | 生命周期                      |
| ------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- | --------------------------------------- | ----------------------------- |
| 功能分支（Feature）      | `feature/模块-功能`例：`feature/user-login`、`feature/order-pay` | 开发新需求、新功能，隔离单个功能开发                 | 合并到`develop`分支                     | 功能开发完成 + 测试通过后删除 |
| 发布分支（Release）      | `release/版本号`例：`release/v1.0.0`                         | 预发布版本测试，仅修复测试中发现的 Bug，不新增功能   | 测试通过后，同时合并到`develop`和`main` | 发布完成后删除                |
| 热修复分支（Hotfix）     | `hotfix/问题描述`例：`hotfix/login-500-error`、`hotfix/order-data-error` | 紧急修复生产环境（`main`）的 Bug，无需走完整开发流程 | 修复完成后，同时合并到`develop`和`main` | 修复发布后删除                |
| 测试分支（Test）（可选） | `test/版本号`例：`test/v1.0.0`                               |                                                      |                                         |                               |