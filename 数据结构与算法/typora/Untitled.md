# 最小生成树

最小生成树（MST）是**连接图中所有节点且总权值最小的无环子图**，常用的两种算法是 **Kruskal 算法** 和 **Prim 算法**，它们的核心思想不同，但最终都能得到最优解。

## 一、Kruskal 算法（基于 “边” 的贪心）

### 核心思路

**按边权从小到大选边，同时避免环**，直到选够 `n-1` 条边（覆盖所有 `n` 个节点）。

### 实现步骤

1. **排序所有边**：将图中所有边按权值**从小到大**排序。
2. **初始化并查集**：用并查集（Union-Find）维护节点的连通性（初始时每个节点是独立集合）。
3. **贪心选边**：依次遍历排序后的边，若边的两个节点**不在同一连通集**，则选择该边（加入生成树），并将两个节点合并到同一集合；直到选够 `n-1` 条边。

### 适用场景

- 图为**稀疏图**（边数较少）时效率更高（时间复杂度主要由排序决定：`O(m log m)`，`m` 是边数）。

### 举例子（对应之前的样例）

样例输入：4 个节点，4 条边：`(1-2,1)`、`(2-3,4)`、`(2-4,2)`、`(3-4,3)`。

- 排序边：`(1-2,1)` → `(2-4,2)` → `(3-4,3)` → `(2-3,4)`。
- 选边过程：
  1. 选`(1-2,1)`：连通 {1,2}，已选 1 条边；
  2. 选`(2-4,2)`：连通 {1,2,4}，已选 2 条边；
  3. 选`(3-4,3)`：连通 {1,2,4,3}，已选 3 条边（n-1=3），结束。

## 二、Prim 算法（基于 “节点” 的贪心）

### 核心思路

**从一个起始节点出发，不断将 “距离当前连通集最近的节点” 加入连通集**，直到覆盖所有节点。

### 实现步骤

1. **初始化距离数组**：`dist[i]` 表示节点 `i` 到当前连通集的最小权值（初始时，起始节点的 `dist` 为 0，其他节点为无穷大）。
2. **贪心选节点**：每次选择 `dist` 最小且未加入连通集的节点，将其加入连通集，并更新**与该节点相邻的未加入节点**的 `dist`（若新边的权值更小，则更新 `dist`）。
3. **重复步骤 2**：直到所有节点都加入连通集。

### 优化方式

- 朴素 Prim（邻接矩阵）：时间复杂度 `O(n²)`，适合**稠密图**（节点少、边多）。
- 堆优化 Prim（邻接表 + 优先队列）：时间复杂度 `O(m log n)`，适合**稀疏图**（但实际效率略低于 Kruskal）。

### 举例子（同一样例，起始节点为 1）

样例输入：4 个节点，边同前。

- 初始状态：连通集 ={1}，`dist[1]=0`，`dist[2]=1`，`dist[3]=∞`，`dist[4]=∞`。

- 选节点 2（

  ```
  dist=1
  ```

  ）：加入连通集，更新相邻节点的

  ```
  dist
  ```

  ：

  - `dist[3]`：原∞ → min (∞, 4)=4；
  - `dist[4]`：原∞ → min (∞, 2)=2；

- 选节点 4（

  ```
  dist=2
  ```

  ）：加入连通集，更新相邻节点的

  ```
  dist
  ```

  ：

  - `dist[3]`：原 4 → min (4, 3)=3；

- 选节点 3（`dist=3`）：加入连通集，所有节点覆盖，结束。

- 总权值：1（1-2） + 2（2-4） + 3（4-3）= 6。

## 三、Kruskal vs Prim 对比

| 维度       | Kruskal 算法             | Prim 算法                        |
| ---------- | ------------------------ | -------------------------------- |
| 核心思想   | 选边（从小到大，避环）   | 选节点（选最近的节点）           |
| 数据结构   | 并查集 + 边排序          | 邻接矩阵 / 邻接表 + 优先队列     |
| 时间复杂度 | `O(m log m)`（m 是边数） | 朴素`O(n²)` / 堆优化`O(m log n)` |
| 适用场景   | 稀疏图（边少）           | 稠密图（节点少）                 |