#写程序的注意点

在 `vector<string>& strs` 中，`&` 表示**引用（reference）** 类型。添加 `&` 的核心目的是 **避免函数对传入的 `vector` 进行拷贝，同时确保函数能直接操作原始数据（如需修改时）**，本质是平衡代码的**效率**和**数据安全性**。

### 一、先理解：没有 `&` 会发生什么？

如果去掉 `&`，函数参数会变成 `vector<string> strs`（值传递）。此时，当你调用函数时，编译器会：

1. 创建一个**新的 `vector` 对象**（函数内部的 `strs`）；
2. 将外部原始 `vector` 的所有元素**逐一拷贝**到这个新对象中；
3. 函数内部仅操作这个 “拷贝版”`vector`，对外部原始 `vector` 的修改完全无效；
4. 函数执行结束后，拷贝版 `vector` 会被销毁（释放内存）。

#### 问题所在：效率极低

`vector<string>` 是 “动态数组”，如果原始数组包含 **10^4 个字符串**（如 LeetCode 49 题的输入规模），拷贝操作会：

- 消耗大量内存（额外存储一份完整的数组）；
- 消耗大量时间（逐元素拷贝字符串，尤其是长字符串时）。

这在算法题中可能导致 **时间超限（TLE）**，在工程代码中会造成不必要的性能损耗。

### 二、加 `&`（引用）的作用：直接操作原始数据

引用（`&`）的本质是**原始变量的 “别名”** —— 函数参数 `strs` 不再是新对象，而是外部原始 `vector` 的 “另一个名字”。此时：

1. **无拷贝**：函数不会创建新的 `vector`，直接复用原始数据的内存空间，彻底避免拷贝开销；
2. **直接关联**：函数内部对 `strs` 的操作（如 `strs[i]` 访问元素、`strs.size()` 获取长度），本质是对外部原始 `vector` 的操作；
3. **高效传递**：无论 `vector` 多大，引用传递的开销都几乎为 0（仅传递原始数据的内存地址）。

### 三、进一步优化：`const vector<string>& strs`（const 引用）

如果函数**不需要修改**传入的 `vector`（如 LeetCode 49 题中，仅需遍历 `strs` 的元素，不增删 / 修改元素），建议在引用前加 `const`，即：

cpp







```cpp
void func(const vector<string>& strs) { ... }
```

#### `const` 的作用：保证数据安全

- 禁止函数内部修改 `strs`（如 `strs.push_back("a")`、`strs[0] = "b"` 等操作会直接编译报错）；
- 明确告诉代码阅读者：“这个函数不会修改传入的数组”，增强代码可读性和可维护性。





在 C++ 中传递数组时，**不需要显式加 `&`，但数组的传递行为与 “引用” 类似（本质是传递指针）**，这与 `vector` 等容器的传递逻辑有显著区别，核心原因是 C++ 对数组的 “特殊处理规则”。

要理解这个问题，需要先明确 **C++ 中数组的两大特性**：

1. 数组**没有 “值传递”** —— 任何时候将数组作为函数参数，编译器都会自动将其转换为**指向数组首元素的指针**（即 “数组名退化为指针”）；
2. 数组的大小信息会丢失 —— 传递后仅能通过指针访问元素，无法直接通过参数获取原始数组的长度（除非额外传一个 `size` 参数）。

### 一、先看结论：传递数组时，`&` 不是 “必须的”，但有两种常见写法

C++ 中传递数组有两种等效的基础写法（本质都是传递指针），均无需显式加 `&`：

| 写法 1（数组形式）     | 写法 2（指针形式）    | 本质                                                         |
| ---------------------- | --------------------- | ------------------------------------------------------------ |
| `void func(int arr[])` | `void func(int* arr)` | 完全等效，均表示 “接收一个指向 `int` 的指针”，指向数组首元素 |

#### 示例：两种写法的效果完全一致

cpp







```cpp
#include <iostream>
using namespace std;

// 写法1：数组形式参数
void printArray1(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " "; // 通过指针访问元素（arr[i] 等价于 *(arr+i)）
    }
    cout << endl;
}

// 写法2：指针形式参数
void printArray2(int* arr, int size) {
    for (int i = 0; i < size; i++) {
        cout << *(arr + i) << " "; // 直接用指针偏移访问
    }
    cout << endl;
}

int main() {
    int nums[] = {1, 2, 3, 4, 5};
    int size = sizeof(nums) / sizeof(nums[0]); // 计算原始数组长度（仅在定义数组的作用域有效）

    printArray1(nums, size); // 输出：1 2 3 4 5
    printArray2(nums, size); // 输出：1 2 3 4 5
    return 0;
}
```

可以看到：两种写法都能正确访问数组元素，且**修改参数会影响原始数组**（因为传递的是指针，指向原始数组的内存）。

### 二、为什么不需要加 `&`？—— 数组的 “退化” 特性

当你将数组 `nums` 传入函数时，编译器会自动执行 **“数组名退化”**：

- 数组名 `nums` 不再表示 “整个数组”，而是被转换为 `&nums[0]`（即指向数组首元素的指针）；
- 函数参数 `int arr[]` 或 `int* arr`，本质都是接收这个指针，因此无需额外加 `&`（加了反而会改变参数类型）。

#### 反例：如果给数组参数加 `&`，会变成 “数组的引用”

如果写成 `void func(int (&arr)[5])`（注意括号不能省），此时 `arr` 不再是指针，而是 **“长度为 5 的 int 数组的引用”** —— 这是一种特殊的引用类型，与普通的数组参数（指针）完全不同：

cpp







```cpp
#include <iostream>
using namespace std;

// 参数是“长度为 5 的 int 数组的引用”
void func(int (&arr)[5]) {
    arr[0] = 100; // 修改原始数组
    cout << "数组长度（编译期确定）：" << sizeof(arr)/sizeof(arr[0]) << endl; // 输出 5（不会丢失大小）
}

int main() {
    int nums1[5] = {1,2,3,4,5};
    func(nums1); // 正确：nums1 是长度为 5 的数组，匹配引用类型
    cout << nums1[0] << endl; // 输出 100（原始数组被修改）

    // int nums2[3] = {1,2,3};
    // func(nums2); // 编译报错：nums2 长度为 3，与引用要求的 5 不匹配
    return 0;
}
```

这种 “数组的引用” 的特点是：

- **不丢失数组大小**：`sizeof(arr)` 能正确计算整个数组的字节数（因为 `arr` 是数组的引用，不是指针）；
- **类型严格匹配**：必须传入长度和元素类型完全一致的数组（如上面的 `nums2[3]` 无法传入 `int (&arr)[5]`）。

但这种写法**灵活性极低**（只能接收固定长度的数组），因此日常开发中很少用，仅在需要 “严格约束数组长度” 的场景下使用。

### 三、关键总结：传递数组的核心逻辑

1. **普通传递数组（无需 `&`）**：
   - 写法：`void func(int arr[])` 或 `void func(int* arr)`；
   - 本质：传递指向数组首元素的指针，会丢失数组大小；
   - 效果：修改参数会影响原始数组（因为操作的是原始内存）；
   - 适用场景：绝大多数情况（如遍历、修改数组元素），需额外传递 `size` 参数。
2. **传递数组的引用（需 `&`，特殊场景）**：
   - 写法：`void func(int (&arr)[N])`（N 是固定长度，如 5）；
   - 本质：引用整个数组，不丢失大小，但类型严格匹配；
   - 适用场景：需明确约束数组长度，且不希望丢失大小信息（极少用）。
3. **与 `vector` 的区别**：
   - `vector<string> strs`：值传递（拷贝整个容器，效率低）；
   - `vector<string>& strs`：引用传递（无拷贝，效率高）；
   - 数组 `int arr[]`：本质是指针传递（无拷贝，无需显式加 `&`）。

### 最终建议

日常开发中传递数组时，**优先使用 `void func(int\* arr, int size)` 或 `void func(int arr[], int size)`**，无需加 `&`，同时通过 `size` 参数明确数组长度（避免越界访问）。如果需要更安全、灵活的动态数组，建议用 `vector` 替代原生数组。





在 C++ 中，`sort(intervals.begin(), intervals.end());` **可以直接对 `vector<vector<int>>` 类型的 `intervals` 进行排序**，但需要理解其排序规则 —— 这是由 C++ 标准库对 “容器的容器” 的默认排序逻辑决定的，具体规则和适用场景如下：

### 1. 为什么能直接排序？—— 默认排序逻辑

C++ 标准库的 `sort` 函数（定义在 `<algorithm>` 头文件中）对**嵌套容器**（如 `vector<vector<int>>`）的排序，遵循「**按第一个元素升序，若第一个元素相等则按第二个元素升序**」的规则，具体逻辑是：

- 比较两个子区间

   

  ```
  a
  ```

  （

  ```
  vector<int>
  ```

  ）和

   

  ```
  b
  ```

  （

  ```
  vector<int>
  ```

  ）时，先比较

   

  ```
  a[0]
  ```

   

  和

   

  ```
  b[0]
  ```

  （子区间的左端点）：

  - 若 `a[0] < b[0]`，则 `a` 排在 `b` 前面；
  - 若 `a[0] == b[0]`，则进一步比较 `a[1]` 和 `b[1]`（子区间的右端点），`a[1]` 小的排在前面；
  - 若 `a[0] > b[0]`，则 `a` 排在 `b` 后面。

这个默认规则**恰好完全匹配 “合并区间” 问题的需求**—— 因为合并区间的核心前提是 “让重叠的区间连续排列”，而按左端点升序排序后，所有可能重叠的区间一定会相邻（如示例 3 中 `[[4,7],[1,4]]` 会被排序为 `[[1,4],[4,7]]`，从而能正确合并）。

### 2. 直接排序的局限性（何时需要自定义排序？）

虽然默认排序对 “合并区间” 问题完全适用，但如果遇到**特殊需求**（如按区间右端点排序、按区间长度排序等），则需要自定义排序规则。例如：

- 需求：按区间右端点降序排序（大的右端点排在前面）；

- 此时不能直接用

   

  ```
  sort(intervals.begin(), intervals.end())
  ```

  ，必须显式传入自定义比较函数（用 lambda 表达式或函数对象实现）：

  cpp

  

  

  

  ```cpp
  // 自定义排序：按区间右端点降序
  sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {
      return a[1] > b[1]; // 右端点大的排在前面
  });
  ```

  

### 3. 实战验证：默认排序在 “合并区间” 中的正确性

以题目中的示例 3 为例：

- 输入：`intervals = [[4,7],[1,4]]`
- 直接调用 `sort` 后，排序结果为 `[[1,4],[4,7]]`（按左端点升序）；
- 后续遍历合并时，发现 `[1,4]` 的右端点（4）等于 `[4,7]` 的左端点（4），符合 “重叠” 条件，合并为 `[[1,7]]`，完全正确。

### 结论

对于 LeetCode 56 题 “合并区间”：

- **可以直接使用 `sort(intervals.begin(), intervals.end());`**，默认排序规则（按左端点升序，左端点相等时按右端点升序）完全满足需求，无需自定义排序；
- 该写法简洁高效，时间复杂度为 `O(n log n)`（排序的主导复杂度），与自定义排序的时间复杂度一致，且无额外性能开销。





### reverse函数

在 C++ 中，`reverse` 是**标准库算法**（定义于 `<algorithm>` 头文件），核心功能是**反转容器或数组中指定区间的元素顺序**，且支持所有提供双向迭代器（Bidirectional Iterator）的容器（如 `vector`、`string`、`list`、`deque` 等）。它是实现 “原地修改” 的常用工具，也是 “三次反转法” 解决轮转数组问题的核心依赖。

### 一、基本语法与核心参数

`reverse` 函数的语法非常简洁，本质是对**左闭右开区间 `[first, last)`** 内的元素进行反转（注意：`last` 指向的是 “区间尾元素的下一个位置”，不包含在反转范围内）。

#### 函数原型

cpp







```cpp
template <class BidirectionalIterator>
void reverse (BidirectionalIterator first, BidirectionalIterator last);
```

#### 参数说明

| 参数名  | 含义                                                         | 要求                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `first` | 双向迭代器，指向**反转区间的起始位置**（包含此位置的元素）   | 必须是容器支持的双向迭代器（如 `vector.begin()`、`string.begin()`） |
| `last`  | 双向迭代器，指向**反转区间的结束位置的下一个位置**（不包含此位置） | 需满足 `last > first`（否则区间为空，无任何操作）            |

### 二、核心特性

1. **原地反转，无返回值**

   `reverse` 直接修改传入的区间元素，不会创建新容器或副本，空间复杂度为 **O(1)**（仅用少量临时变量交换元素）。

2. **依赖双向迭代器**

   双向迭代器支持 “向前移动（`++`）” 和 “向后移动（`--`）”，这是 `reverse` 实现的基础（通过双指针从两端向中间交换元素）。

   ❌ 不支持仅提供单向迭代器的容器（如 `forward_list`、`unordered_map` 的迭代器）。

3. **适用容器广泛**

   只要容器支持双向迭代器，均可使用 `reverse`，常见场景包括：

   - 数组（需通过指针模拟迭代器）
   - 顺序容器：`vector`、`string`、`list`、`deque`
   - 关联容器：`set`/`multiset`、`map`/`multimap`（但反转会破坏其有序性，不推荐使用）

### 三、典型使用示例

#### 1. 反转 vector 容器

cpp







```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    
    // 反转整个 vector（区间 [begin(), end()) 覆盖所有元素）
    reverse(nums.begin(), nums.end());
    // 输出：5 4 3 2 1
    for (int num : nums) cout << num << " ";
    cout << endl;

    // 反转前 3 个元素（区间 [begin(), begin()+3)，即下标 0、1、2）
    reverse(nums.begin(), nums.begin() + 3);
    // 输出：3 4 5 2 1
    for (int num : nums) cout << num << " ";
    return 0;
}
```

#### 2. 反转 string（字符序列）

cpp







```cpp
#include <string>
#include <algorithm>
#include <iostream>

using namespace std;

int main() {
    string s = "hello";
    // 反转整个字符串
    reverse(s.begin(), s.end());
    cout << s; // 输出：olleh
    return 0;
}
```

#### 3. 反转普通数组（用指针模拟迭代器）

普通数组没有 `begin()`/`end()` 成员函数，但可通过 “数组名 + 下标” 模拟迭代器（数组名本质是指向首元素的指针）：

cpp







```cpp
#include <algorithm>
#include <iostream>

using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40};
    int n = sizeof(arr) / sizeof(arr[0]); // 数组长度

    // 反转整个数组：arr 是首元素指针（begin），arr + n 是尾后指针（last）
    reverse(arr, arr + n);
    // 输出：40 30 20 10
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
    return 0;
}
```

### 四、实现原理（手动模拟）

`reverse` 的底层逻辑非常直观，本质是**双指针交换法**：

1. 用两个指针（`left` 指向 `first`，`right` 指向 `last - 1`）；
2. 交换 `left` 和 `right` 指向的元素；
3. `left` 向前移动（`++left`），`right` 向后移动（`--right`），直到 `left >= right`。

以下是模拟 `reverse` 逻辑的自定义函数，与标准库实现逻辑一致：

cpp







```cpp
// 自定义反转函数：支持所有双向迭代器
template <class BidirectionalIterator>
void myReverse(BidirectionalIterator first, BidirectionalIterator last) {
    // 从两端向中间交换，直到指针相遇
    while (first != last && first != --last) {
        swap(*first, *last); // 交换两个指针指向的元素
        ++first;             // 左指针右移
    }
}
```

可直接替换标准库 `reverse` 使用，例如：

cpp







```cpp
vector<int> nums = {1,2,3,4,5};
myReverse(nums.begin(), nums.end()); // 效果与 reverse 完全一致
```

### 五、注意事项

1. **处理 “空区间” 或 “单元素区间”**

   若 `first == last`（空区间）或 `first + 1 == last`（仅 1 个元素），`reverse` 无任何操作，直接返回（无需额外判断）。

2. **避免 “越界访问”**

   `last` 必须是 “合法的尾后位置”（如 `vector.end()`、`arr + n`），不可随意指定超出容器范围的指针 / 迭代器（否则会触发未定义行为，程序可能崩溃）。

3. **关联容器的使用禁忌**

   `set`/`map` 等关联容器的元素是 “按特定规则排序” 的，反转会破坏其内部有序结构，导致后续插入 / 查找等操作异常，**严禁对关联容器使用 `reverse`**。

4. **与 `reverse_copy` 的区别**

   标准库还提供 `reverse_copy` 函数，功能是 “反转元素并复制到新容器”，会额外开辟空间（空间复杂度 O (n)），而 `reverse` 是原地修改，二者适用场景不同。

### 总结

`reverse` 是 C++ 中高效、简洁的区间反转工具，核心优势是**原地修改、低空间开销**，尤其适合 “三次反转法”“字符串反转” 等场景。使用时需注意 “左闭右开区间” 的规则和容器迭代器的兼容性，避免越界或破坏容器结构。



# 成员访问

在 C/C++ 中，`.`（点运算符）和 `->`（箭头运算符）的使用场景**完全取决于变量 / 指针的类型**—— 核心区别是：**是否直接持有对象，还是持有对象的地址（指针）**。下面结合「相交链表」题目中的链表节点（`ListNode`）场景，详细拆解两者的使用规则、本质差异和典型案例。

### 一、核心规则：看 “操作目标” 是「对象本身」还是「对象指针」

先明确两个基础概念：

- **对象本身**：直接存储了结构体 / 类的所有成员（如 `ListNode node(5)`，`node` 就是一个 `ListNode` 类型的对象，内存中直接包含 `val` 和 `next` 成员）。
- **对象指针**：存储的是对象的内存地址（如 `ListNode* p = &node`，`p` 本身是指针，指向 `node` 的地址，不直接存储 `val` 和 `next`）。

基于这两个概念，`.` 和 `->` 的使用规则可以总结为：

| 运算符 | 适用场景                       | 作用                              | 语法格式     |
| ------ | ------------------------------ | --------------------------------- | ------------ |
| `.`    | 操作**对象本身**（非指针）     | 直接访问对象的成员变量 / 成员函数 | `对象.成员`  |
| `->`   | 操作**对象指针**（含 nullptr） | 先通过指针找到对象，再访问其成员  | `指针->成员` |

### 二、本质差异：`->` 是 “解引用 + 点运算” 的简写

`->` 本质上是「指针解引用（`*`）」和「点运算（`.`）」的组合，两者完全等价：

cpp







```cpp
ListNode node(5);    // 定义一个 ListNode 对象 node
ListNode* p = &node; // 定义指针 p，指向 node 的地址

// 以下两种写法完全等价：访问 p 指向的对象的 val 成员
cout << p->val;      // 用 -> 直接访问（推荐，简洁）
cout << (*p).val;    // 先解引用 p 得到对象，再用 . 访问（注意括号，*优先级低于.）
```

⚠️ 注意：**不能直接用 `\*p.val`**—— 因为 `.` 的运算符优先级高于 `*`，编译器会先解析 `p.val`（但 `p` 是指针，没有 `val` 成员），直接报错。

### 三、结合 “相交链表” 题目，看实际使用案例

以题目中的 `ListNode` 结构体为例（定义如下），结合常见操作场景说明：

cpp







```cpp
// 链表节点结构体定义
struct ListNode {
    int val;        // 节点值（成员变量）
    ListNode *next; // 指向next节点的指针（成员变量，类型是 ListNode*）
    ListNode(int x) : val(x), next(NULL) {} // 构造函数
};
```

#### 场景 1：操作「对象本身」→ 用 `.`

当变量是 `ListNode` 类型（非指针）时，用 `.` 访问成员：

cpp







```cpp
// 1. 创建一个 ListNode 对象（非指针）
ListNode nodeA(4);  // 调用构造函数，val=4，next=NULL
ListNode nodeB(5);

// 2. 访问对象的成员：用 . 
cout << nodeA.val;  // 正确：输出 4（访问 val 成员）
nodeA.next = &nodeB;// 正确：将 nodeA 的 next 指向 nodeB 的地址（next 是指针，需赋值地址）
```

#### 场景 2：操作「对象指针」→ 用 `->`

当变量是 `ListNode*` 类型（指针）时，用 `->` 访问成员（题目中绝大多数场景是指针，因为链表用指针串联）：

cpp







```cpp
// 1. 定义指针（常见场景：头指针、遍历指针）
ListNode* headA = new ListNode(4); // 动态创建节点，headA 是指针（指向新节点地址）
ListNode* pa = headA;              // 遍历指针 pa，初始指向 headA

// 2. 访问指针指向的对象的成员：用 ->
cout << pa->val;       // 正确：输出 4（访问 pa 指向节点的 val）
pa = pa->next;         // 正确：让 pa 指向 next 节点（next 是指针，直接赋值）

// 3. 题目解法中的典型用法（双指针法）
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if (!headA || !headB) return nullptr;
    ListNode* pa = headA; // pa 是指针
    ListNode* pb = headB; // pb 是指针
    while (pa != pb) {
        // pa 是指针：用 -> 访问 next；pa 为空时赋值 headB（指针赋值）
        pa = (pa == nullptr) ? headB : pa->next; 
        // pb 是指针：同理用 -> 访问 next
        pb = (pb == nullptr) ? headA : pb->next;
    }
    return pa; // 返回指针（相交节点的地址，或 nullptr）
}
```

#### 场景 3：嵌套场景（成员是指针）→ 需结合使用

若对象的成员本身是指针（如 `ListNode` 的 `next` 成员是 `ListNode*`），访问嵌套成员时需根据类型切换：

cpp







```cpp
ListNode node1(1);
ListNode node2(8);
ListNode* head = &node1;
head->next = &node2; // head 是指针，用 -> 访问 next；next 需赋值地址

// 访问 head->next 指向的节点的 val：
// head->next 是 ListNode* 类型（指针），所以用 -> 访问 val
cout << head->next->val; // 正确：输出 8
```

### 四、常见错误与避坑

1. **指针用了 `.`**：

   cpp

   

   

   

   ```cpp
   ListNode* p = new ListNode(5);
   cout << p.val; // 错误！p 是指针，不能用 . 访问成员（编译器报错：“ListNode*”没有成员“val”）
   ```

   

2. **对象本身用了 `->`**：

   cpp

   

   

   

   ```cpp
   ListNode node(5);
   cout << node->val; // 错误！node 是对象，不是指针（编译器报错：“ListNode”不是指针）
   ```

   

3. **解引用时忘记括号**：

   cpp

   

   

   

   ```cpp
   ListNode* p = new ListNode(5);
   cout << *p.val; // 错误！优先级问题，等价于 *(p.val)（p 是指针，无 val 成员）
   cout << (*p).val; // 正确！先解引用得到对象，再用 . 访问
   ```

   

### 五、总结：一句话判断

**看变量的类型结尾有没有 `\*`**：

- 有 `*`（指针）→ 用 `->`（如 `ListNode* p` → `p->val`）；
- 没有 `*`（对象）→ 用 `.`（如 `ListNode node` → `node.val`）。

记住这个规则，就能在所有结构体 / 类的成员访问场景中（不仅是链表，还有树、自定义类等）准确选择运算符。





在 LeetCode 102. 二叉树的层序遍历问题中，`result.push_back(vector<int> ();)` 是一句用于**初始化 “当前层节点值的空列表” 并加入结果集**的核心代码，其作用需要结合层序遍历的逻辑和数据结构来理解，以下是详细拆解：

### 1. 先明确变量的定义和用途

在层序遍历的代码中，`result` 通常是最终要返回的结果，其数据类型是 **`vector<vector<int>>`**（C++ 中的二维向量），对应题目要求的 “按层返回节点值”（比如示例 1 的输出 `[[3],[9,20],[15,7]]`，就是一个包含 3 个一维向量的二维向量）。

- 外层 `vector`：代表 “层的集合”，每个元素对应二叉树的一层；
- 内层 `vector<int>`：代表 “某一层的所有节点值”，元素是该层节点的数值。

### 2. 逐部分解析代码

`result.push_back(vector<int> ();)` 可拆分为两部分：`vector<int> ()` 和 `result.push_back(...)`，二者结合实现 “为当前层准备空容器” 的功能。

#### （1）`vector<int> ()`：创建一个空的一维向量

这是 C++ 中 **vector 容器的默认构造函数调用**，作用是生成一个**空的、存储 int 类型数据的一维向量**（可以理解为一个空的 “节点值列表”）。

比如：

- `vector<int> empty_vec;` 和 `vector<int> empty_vec()` 是等价的，都表示 “创建一个没有任何元素的 int 类型向量”；
- 此时这个空向量还没有存储任何节点值，后续会通过循环将当前层的节点值逐一加入其中。

#### （2）`result.push_back(...)`：将空向量加入结果集的末尾

`push_back()` 是 vector 的核心成员函数，作用是**在向量的末尾添加一个新元素**（此处的 “新元素” 就是上面创建的空一维向量）。

结合层序遍历的逻辑，这一步的目的是：

- 遍历二叉树的某一层前，先在 `result` 中添加一个 “空的内层向量”，专门用于存储当前层的所有节点值；
- 后续通过循环遍历当前层的节点时，直接将节点值 `push_back` 到这个 “空向量” 中，避免后续插入时破坏层的顺序。

### 3. 结合层序遍历逻辑理解：为什么需要这行代码？

层序遍历的核心是 “按层处理节点”，通常用**队列**实现，整体流程如下（对应代码逻辑）：

1. 若根节点非空，将根节点入队；

2. 循环处理队列中的节点（直到队列为空）：

   - 第一步：获取当前队列的大小 `size`（这个 `size` 就是 “当前层的节点总数”，因为队列中此时存储的全是当前层的节点）；

   - 第二步：执行 `result.push_back(vector<int> ();)` —— 为当前层创建一个空的 “节点值列表”，并加入结果集；

   - 第三步：循环

      

     ```
     size
     ```

      

     次（遍历当前层的所有节点）：

     - 出队一个节点，将其值加入 `result` 的 “最后一个内层向量”（即刚创建的空向量）；
     - 若该节点有左子节点，将左子节点入队（属于下一层）；
     - 若该节点有右子节点，将右子节点入队（属于下一层）；

3. 循环结束，`result` 就是按层排列的节点值。

### 4. 代码示例：更直观的理解

以示例 1 `root = [3,9,20,null,null,15,7]` 为例，这行代码的作用过程如下：

- 初始队列：`[3]`，`result` 为空；
- 第一次循环（处理第 1 层）：
  - `size = 1`（当前层有 1 个节点）；
  - 执行 `result.push_back(vector<int> ();)` → `result` 变为 `[[]]`（外层向量有 1 个空内层向量）；
  - 循环 1 次：出队 `3`，将 `3` 加入 `result[0]` → `result[0]` 变为 `[3]`，`result` 最终是 `[[3]]`；
  - 入队 `3` 的左子节点 `9` 和右子节点 `20` → 队列变为 `[9,20]`；
- 第二次循环（处理第 2 层）：
  - `size = 2`（当前层有 2 个节点）；
  - 执行 `result.push_back(vector<int> ();)` → `result` 变为 `[[3], []]`（外层向量有 2 个内层向量，第二个为空）；
  - 循环 2 次：依次出队 `9`（加入 `result[1]`）、`20`（加入 `result[1]`）→ `result[1]` 变为 `[9,20]`，`result` 最终是 `[[3],[9,20]]`；
  - 入队 `20` 的左子节点 `15` 和右子节点 `7` → 队列变为 `[15,7]`；
- 第三次循环（处理第 3 层）：
  - 同理，先执行 `result.push_back(vector<int> ();)` 创建空向量，再填充 `15` 和 `7` → 最终 `result` 为 `[[3],[9,20],[15,7]]`。

### 5. 常见注意点：语法细节

- 代码中 `vector<int> ();` 的括号可以省略，写成 `vector<int>()`（空格不影响）；
- 若忘记写这行代码，直接往 `result` 中添加节点值，会导致 “当前层的节点值混入上一层”，最终结果的层结构混乱（比如示例 1 可能变成 `[[3,9,20,15,7]]`，不符合题目要求）。

总结：`result.push_back(vector<int> ();)` 的核心作用是**为二叉树的 “当前层” 提前在结果集中创建一个空的存储容器**，确保后续节点值能按层有序存储，是实现 “分层返回” 的关键步骤。



# 递归实现深搜

在递归实现深度优先搜索（DFS）时，**是否需要额外写一个函数调用**，核心取决于「当前递归函数能否直接承载所有必要的状态信息」—— 即是否需要在递归过程中维护「题目要求的核心变量」（如深度、路径、计数等），且这些变量无法通过函数返回值或参数直接传递 / 更新。

### 本质区别：「自底向上」vs「自顶向下」的递归逻辑

递归实现 DFS 的核心逻辑分为两类，这直接决定了函数设计方式：

| 递归类型              | 核心逻辑                                                     | 函数设计特点                                                 |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 自底向上（Bottom-Up） | 从叶子节点向根节点「回溯计算」，**结果通过函数返回值传递**（无需额外状态） | 通常只需 1 个函数：递归函数的返回值就是当前子问题的解（如子树深度、子树是否平衡）。 |
| 自顶向下（Top-Down）  | 从根节点向叶子节点「传递状态」，**需要实时维护中间状态**（如当前深度、路径） | 可能需要额外函数：若中间状态（如当前深度、临时路径）无法通过返回值高效维护，需用辅助函数承载状态。 |

### 1. 只用一个函数的场景（自底向上为主）

当递归的核心是「通过子问题的返回值推导当前问题的解」，且无需额外维护中间状态时，直接用一个函数即可。

**核心特征**：递归函数的返回值就是「当前节点对应的子问题答案」，无需依赖外部变量或额外参数传递状态。

#### 典型案例：二叉树的最大深度（题目本身）

求最大深度的逻辑是「当前节点深度 = max (左子树深度，右子树深度) + 1」，每个递归调用的返回值就是子树深度，无需额外状态：

python







```python
# 仅1个函数：返回值直接传递子树深度
def maxDepth(root: Optional[TreeNode]) -> int:
    if not root:  #  base case：空节点深度为0
        return 0
    # 递归计算左右子树深度（子问题解），推导当前节点深度
    left_depth = maxDepth(root.left)
    right_depth = maxDepth(root.right)
    return max(left_depth, right_depth) + 1  # 当前问题解
```

#### 其他类似场景：

- 验证二叉搜索树（判断左子树是否为 BST + 右子树是否为 BST + 当前节点值合法，返回布尔值）；
- 二叉树的直径（返回当前节点的最大深度，同时通过全局变量记录直径，但核心递归逻辑仍为自底向上）；
- 平衡二叉树（判断左子树是否平衡 + 右子树是否平衡 + 左右子树深度差≤1，返回布尔值或深度）。

### 2. 需要额外函数的场景（自顶向下为主）

当递归需要「实时维护中间状态」（如当前深度、临时路径、计数等），且这些状态无法通过函数返回值高效传递时，需要设计**主函数 + 辅助函数**的结构：

- 主函数：负责初始化（如初始化结果变量、调用辅助函数）；
- 辅助函数：承载递归逻辑，参数中包含需要传递的「中间状态」（如当前节点、当前深度、临时路径）。

#### 典型案例 1：二叉树的所有路径（需要维护临时路径）

要求输出从根到叶子的所有路径，需在递归中维护「当前路径」（中间状态），直接用一个函数会导致路径传递冗余，因此用辅助函数：

python







```python
def binaryTreePaths(root: Optional[TreeNode]) -> List[str]:
    result = []  # 存储最终结果（主函数初始化）
    
    # 辅助函数：承载递归逻辑，参数包含当前节点和当前路径（中间状态）
    def dfs(node, current_path):
        if not node:
            return
        # 更新当前路径（添加当前节点值）
        current_path += str(node.val)
        # 叶子节点：将当前路径加入结果
        if not node.left and not node.right:
            result.append(current_path)
            return
        # 非叶子节点：递归左右子树，传递更新后的路径
        dfs(node.left, current_path + "->")
        dfs(node.right, current_path + "->")
    
    dfs(root, "")  # 主函数调用辅助函数，初始化路径为空
    return result
```

#### 典型案例 2：二叉树的最小深度（自顶向下维护当前深度）

虽然最小深度也可自底向上实现，但自顶向下逻辑更直观（遇到叶子节点就记录当前深度，取最小值），此时需辅助函数传递「当前深度」：

python







```python
def minDepth(root: Optional[TreeNode]) -> int:
    if not root:
        return 0
    min_depth = float('inf')  # 存储最小深度（主函数初始化）
    
    # 辅助函数：参数包含当前节点和当前深度（中间状态）
    def dfs(node, current_depth):
        nonlocal min_depth  # 引用主函数的min_depth
        if not node:
            return
        # 叶子节点：更新最小深度
        if not node.left and not node.right:
            min_depth = min(min_depth, current_depth)
            return
        # 非叶子节点：递归左右子树，当前深度+1
        dfs(node.left, current_depth + 1)
        dfs(node.right, current_depth + 1)
    
    dfs(root, 1)  # 主函数调用，根节点深度为1
    return min_depth
```

#### 其他类似场景：

- 二叉树的路径总和 II（寻找所有和为目标值的路径，需维护临时路径和当前和）；
- 统计二叉树中符合条件的节点数（如值大于某个数的节点，需维护计数变量）；
- N 皇后问题（回溯过程中需维护当前棋盘状态、列 / 对角线占用情况）。

### 关键判断依据：3 个问题帮你决定

遇到递归 DFS 问题时，可通过以下 3 个问题快速判断是否需要额外函数：

1. **递归的核心是「返回值推导」还是「状态维护」**？
   - 若核心是「用子问题返回值算当前解」（如深度、是否平衡）→ 1 个函数；
   - 若核心是「传递并更新中间状态」（如路径、当前深度）→ 需额外函数。
2. **是否需要修改外部变量**？
   - 若需要在递归中修改全局 / 外层变量（如结果列表、计数），且该变量无法通过返回值传递 → 需额外函数（用`nonlocal`/`global`引用，或作为参数传递可变对象如列表）。
3. **参数传递是否冗余**？
   - 若用 1 个函数需反复传递相同的中间状态（如路径字符串），导致代码冗余 → 用辅助函数封装状态参数，主函数只需初始化一次。

### 总结

- **1 个函数够用**：自底向上逻辑，依赖返回值传递子问题解，无额外状态维护（如求深度、判断 BST）；
- **需额外函数**：自顶向下逻辑，需维护中间状态（路径、当前深度等），或需修改外部变量（如结果列表）。

本质上，这是「函数返回值能力」与「问题状态需求」的匹配问题 —— 当返回值不足以承载所有必要信息时，就需要辅助函数来补充。





### 二、掌握递归的 “铁律”：2 个必须满足的条件

所有能正确运行的递归，都必须同时满足以下 2 个条件，这是理解和写递归的 “底线”，先记死：

#### 1. 必须有 “Base Case”（终止条件）

- **作用**：防止递归无限循环（否则会栈溢出），是递归的 “出口”。

- 例子

  ：

  

  计算

   

  ```
  n!
  ```

  （n 的阶乘，n! = n × (n-1) × ... × 1）：

  - 当 `n=1` 时，1! = 1（这就是 Base Case，不需要再递归）；
  - 若没有 Base Case，`n` 会一直减到 0、-1、-2... 永远不停止。

#### 2. 必须有 “Recursive Case”（递归拆解）

- **作用**：将 “大问题” 拆解成 “和大问题结构相同，但规模更小的问题”，让问题逐步逼近 Base Case。

- 例子

  ：

  

  计算

   

  ```
  n!
  ```

   

  的递归拆解：

  ```
  n! = n × (n-1)!
  ```

  - 大问题是 “求 n!”，小问题是 “求 (n-1)!”，两者逻辑完全一致（都是求阶乘），但规模从`n`缩小到`n-1`，最终会到`n=1`（Base Case）。

### 三、用 “三步法” 拆解递归代码：从 “看懂” 到 “会写”

很多人觉得递归难，是因为一上来就逐行跟踪调用栈（比如 “调用 f (5)→f (4)→f (3)...”），越跟踪越乱。正确的做法是 “先定义问题，再找边界，最后写代码”，三步就能搞定：

#### 步骤 1：明确 “递归函数的功能”（先不用管怎么实现）

先给函数一个 “清晰的职责”—— 比如 “函数 f (n) 的功能是计算 n 的阶乘”“函数 fib (n) 的功能是返回第 n 个斐波那契数”。

**关键**：不要一开始就想 “函数里怎么调用自己”，先确定 “它最终要返回什么”。

#### 步骤 2：找到 “Base Case”（终止条件）

思考：当问题规模小到什么程度时，不需要递归，能直接返回结果？

- 比如阶乘：n=1 时，f (1)=1（直接返回）；
- 比如斐波那契：n=1 时 fib (1)=1，n=2 时 fib (2)=1（直接返回）；
- 比如链表反转：如果链表为空或只有一个节点，直接返回该节点（不需要反转）。

#### 步骤 3：推导 “Recursive Case”（大问题→小问题）

思考：如何用 “小问题的结果” 构建 “大问题的结果”？

- 阶乘：f (n) = n × f (n-1)（大问题 f (n) = n 乘以小问题 f (n-1) 的结果）；
- 斐波那契：fib (n) = fib (n-1) + fib (n-2)（大问题 fib (n) = 小问题 fib (n-1) + 小问题 fib (n-2) 的结果）；
- 链表反转：假设链表是 “head → 剩余链表”，先反转 “剩余链表” 得到 “反转后的剩余链表”，再把 head 接到反转后链表的末尾，最终返回新头（大问题 = 反转剩余链表 + 接 head）。

### 四、实战案例：用 “三步法” 写一个递归（以阶乘为例）

跟着步骤走，你会发现递归代码其实很简单：

#### 步骤 1：定义函数功能

函数名：`factorial(n)`

功能：接收一个非负整数 n，返回 n 的阶乘（n!）。

#### 步骤 2：找 Base Case

当 n=0 或 n=1 时（0! 和 1! 都等于 1），直接返回 1：

```
if n <= 1: return 1
```

#### 步骤 3：推导 Recursive Case

n! = n × (n-1)! → 所以`factorial(n) = n * factorial(n-1)`

#### 最终代码（Python）

python







```python
def factorial(n):
    # Base Case：终止条件
    if n <= 1:
        return 1
    # Recursive Case：大问题→小问题
    return n * factorial(n - 1)

# 测试：factorial(5) = 5*4*3*2*1 = 120
print(factorial(5))  # 输出120
```

### 五、进阶：用 “调用栈可视化” 理解递归的执行过程

如果想深入理解 “递归时计算机在做什么”，可以画 “调用栈”（但不用每次都画，初期帮助理解即可）。以`factorial(5)`为例，调用栈的执行流程是 “先压栈（递推），后弹栈（回溯）”：

1. **递推阶段（压栈）**：要算`fact(5)`，需要先算`fact(4)`；要算`fact(4)`，需要先算`fact(3)`... 直到`fact(1)`（Base Case）。

   此时栈里的调用顺序是：`fact(5) → fact(4) → fact(3) → fact(2) → fact(1)`

2. **回溯阶段（弹栈）**：`fact(1)`返回 1 → `fact(2) = 2*1=2` → `fact(3)=3*2=6` → `fact(4)=4*6=24` → `fact(5)=5*24=120`

   栈里的调用依次弹出，最终返回结果。

### 六、常见误区：避开这 3 个坑，递归就不难了

1. **误区 1：过度跟踪调用栈**

   新手容易逐行跟踪 “f (5)→f (4)→f (3)...”，但递归的核心是 “问题拆解”，不是 “调用顺序”。就像你用手机导航，不需要知道卫星怎么工作，只要知道 “跟着箭头走”—— 递归只要知道 “Base Case” 和 “拆解逻辑”，不用管中间调用过程。

2. **误区 2：忘记 Base Case**

   没有 Base Case 会导致递归无限循环，最终触发 “栈溢出”（Stack Overflow）。写递归时，先写 Base Case，再写拆解逻辑。

3. **误区 3：拆解后的问题和原问题 “结构不同”**

   比如写 “求数组和” 的递归时，若原问题是 “求 arr [0..n-1] 的和”，拆解后应该是 “arr [0] + 求 arr [1..n-1] 的和”（结构相同，都是 “求子数组的和”），而不是 “arr [0] + arr [1] + 求 arr [2..n-1] 的和”（多此一举，且破坏了递归结构）。

### 七、练习建议：从简单到复杂，逐步强化

1. **入门级（理解 Base Case 和拆解）**：
   - 计算 n 的阶乘（已讲）
   - 计算 1+2+...+n 的和（Base Case：n=1 时返回 1；拆解：n + sum (n-1)）
   - 求斐波那契数列第 n 项（Base Case：n=1/2 返回 1；拆解：fib (n-1)+fib (n-2)）
2. **进阶级（处理数据结构）**：
   - 递归反转链表（Base Case：空链表或单节点；拆解：反转剩余链表 + 接当前节点）
   - 递归遍历二叉树（前序 / 中序 / 后序，Base Case：节点为空返回；拆解：遍历左子树 + 处理当前节点 + 遍历右子树）
   - 递归求二叉树的深度（Base Case：空节点深度 0；拆解：1 + max (左子树深度，右子树深度)）
3. **挑战级（复杂问题拆解）**：
   - 汉诺塔问题（3 根柱子，n 个盘子，如何移动？Base Case：n=1 直接移；拆解：n-1 个盘子移到中间→第 n 个移到目标→n-1 个盘子移到目标）
   - 组合问题（从 n 个元素中选 k 个，有多少种选法？Base Case：k=0 或 k=n 返回 1；拆解：选第 n 个元素（则从 n-1 选 k-1）+ 不选第 n 个元素（则从 n-1 选 k））



在 `for (auto& dir : dirs)` 中，`&` 表示**引用（reference）**，作用是让循环变量 `dir` 直接 “绑定” 到数组 `dirs` 的元素上，而不是创建元素的副本。要理解它的意义，需要先明确 `auto` 和 “引用” 在循环中的作用，再对比 “带引用” 和 “不带引用” 的区别。

### 1. 先回顾 `auto` 在范围 for 循环中的默认行为

在 C++ 的**范围 for 循环**（`for (auto var : 容器/数组)`）中，`auto` 会根据容器 / 数组的元素类型，**自动推导 `var` 的类型**，并且默认是**值传递**—— 即会创建一个与元素值相同的 “副本” 给 `var`。

以本题的 `dirs` 为例：

`dirs` 是 `int dirs[4][2]`，本质是一个 “存储了 4 个 `int[2]` 数组的数组”，每个元素是一个包含 2 个整数的小型数组（比如 `dirs[0]` 是 `{-1, 0}`，代表 “上” 方向的偏移量）。

如果写成 `for (auto dir : dirs)`：

- `auto` 会推导出 `dir` 的类型是 `int[2]`（即与 `dirs` 的元素类型一致）；
- 循环时，会为 `dirs` 的每个元素（每个 `int[2]`）创建一个**副本**赋值给 `dir`；
- 后续对 `dir` 的修改（比如 `dir[0] = 5`），只会修改副本，不会影响原数组 `dirs` 的元素。

### 2. 加上 `&` 后：从 “副本” 变成 “引用”

当加上 `&` 写成 `for (auto& dir : dirs)` 时：

- `auto&` 推导出 `dir` 的类型是 `int(&)[2]`（即 “指向 `int[2]` 数组的引用”）；
- `dir` 不再是元素的副本，而是直接 “绑定” 到 `dirs` 的原始元素上（比如第一次循环，`dir` 绑定 `dirs[0]`；第二次绑定 `dirs[1]`，以此类推）；
- 对 `dir` 的操作，本质就是对 `dirs` 原始元素的操作（不过本题中只是读取 `dir` 的值，没有修改，所以 “修改原始元素” 的特性没用到，但 `&` 仍有其他意义）。

### 3. 为什么本题要加 `&`？核心作用：避免不必要的拷贝，提升效率

虽然本题中，`dirs` 的元素是 `int[2]`（仅 2 个整数，拷贝成本极低），加不加 `&` 对程序运行结果和效率影响微乎其微，但这是一种**良好的编程习惯**，尤其在元素体积较大时（比如元素是复杂的类对象、大数组），作用会非常明显：

- 不带 `&`：每次循环都要拷贝元素，若元素体积大，会浪费内存和 CPU 时间；
- 带 `&`：直接引用原始元素，无需拷贝，零额外开销。

举个直观的例子：如果 `dirs` 的元素是一个包含 1000 个整数的数组 `int[1000]`，那么 `auto dir` 每次循环都会拷贝 1000 个整数，而 `auto& dir` 完全不需要拷贝 —— 效率差异会非常显著。

### 4. 补充：`const auto&` 与 `auto&` 的区别

如果循环中**只需要读取元素，不需要修改**（比如本题中，我们只需要读取 `dir[0]` 和 `dir[1]` 的偏移量，不会修改 `dir`），更严谨的写法是 `for (const auto& dir : dirs)`：

- `const` 表示 “只读引用”，即通过 `dir` 只能读取原始元素的值，不能修改（若尝试 `dir[0] = 5`，编译器会报错）；
- 这能避免不小心修改原始数组的 bug，同时保留 “无拷贝” 的效率优势。

本题中，`auto& dir` 和 `const auto& dir` 都能正常运行，但 `const auto&` 更安全（明确表达 “只读” 意图），是更推荐的写法。

### 总结

`for (auto& dir : dirs)` 中的 `&`：

- 核心作用：让 `dir` 成为 `dirs` 元素的**引用**，避免创建元素副本，提升效率；
- 本题中虽无性能瓶颈，但属于规范的编程习惯，尤其在处理大体积元素时必不可少；
- 若只需读取元素，建议用 `const auto&`，进一步保证代码安全性。