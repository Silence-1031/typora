# 哈希

`unordered_set`和`unordered_map`是STL中基于哈希表实现的容器，本质上是**“哈希表的封装”**

1. `unordered_set`:无重复的“哈希集合”

- `unordered_set`是哈希表的简化版，仅存储不重复的key（value）
- 核心作用是“快速判断元素是否存在”

核心特性：

- 元素唯一性：插入重复元素时自动忽略
- 无序性：元素插入顺序与存储顺序无关
- 操作效率：插入、查找、删除均为平均O(1)，最坏O(n)（同哈希表）

常用方法

| 接口                | 功能                                                         |
| ------------------- | ------------------------------------------------------------ |
| insert(key)         | 插入key，若已存在则不操作，返回pair<iterator,bool>(bool表示是否插入成功) |
| find(key)           | 查找key，存在则返回指向该元素的迭代器，不存在则返回end()     |
| count(key)          | 统计key的个数（仅0和1,可用于判断元素是否存在）               |
| erase(key/iterator) | 删除指定key或迭代器指向的元素，返回删除元素的个数（0或1）    |
| empty()             | 判断是否为空                                                 |
| size()              | 返回元素个数                                                 |

2. unordered_map:键值对的哈希映射

unordered_map是“标准哈希表的实现”，存储唯一的key和对应的value（key不重复，value可重复），核心作用是“通过key快速查找value”

核心特性：

- key唯一：若插入相同key，会覆盖原来的value
- 键值对储存：数据以pair<const key,Value>形式存储（key可修改，value不可修改）
- 无序性：键值对的插入顺序与存储顺序无关
- 操作效率：插入、查找、删除均为平均O(1)，最坏O(n)（同哈希表

常用方法

| 接口                    | 功能                                                         |
| ----------------------- | ------------------------------------------------------------ |
| insert(pair<key,value>) | 插入键值对，若 Key 已存在则不操作；也可直接用`map[key] = value`（存在则覆盖）。 |
| find(key)               | 查找key，存在则返回指向pair<key,value>的迭代器，不存在则返回end() |
| count(key)              | 统计key的个数（仅 0 或 1，用于判断 Key 是否存在）            |
| operator[key]           | 访问key对应的value（若key不存在会自动创建并初始化value），慎用！ |
| erase(key/iterator)     | 删除指定 key 或迭代器指向的键值对，返回删除的个数（0 或 1）。 |
| empty()                 | 判断是否为空                                                 |
| size()                  | 返回键值对个数。                                             |

### 3. unordered_set vs unordered_map：关键区别

| 对比     | unordered_set                  | unordered_map                             |
| -------- | ------------------------------ | ----------------------------------------- |
| 存储内容 | 仅 Key（无 Value）             | Key-Value 键值对                          |
| 核心用途 | 判断元素是否存在（去重、查询） | 通过 Key 快速获取 Value（映射、关联存储） |
| 插入方式 | 直接插入 Key（`insert(key)`）  | 插入`pair<Key, Value>`或用`[]`赋值        |
| 元素访问 | 仅通过迭代器或`find()`获取 Key | 可通过`[]`或`find()`获取 Value            |

## 三、哈希表（含 unordered_set/unordered_map）的算法应用场景

哈希表的核心优势是“O(1)查找”，因此在算法在主要解决需要快速判断元素是否存在，或需要快速关联键值的问题，常见场景如下：

### 1. 两数之和（LeetCode #1）：经典映射问题

**问题**：给定数组和目标值，找到两个数的索引，使它们的和为目标值。

**常规思路**：双重循环（O (n²)），效率低。

**哈希表思路**：以元素数值为key，元素索引为value，用`unordered_map`存储 “数组元素值 → 索引”，遍历数组时，判断 “complement=target-nums[i]” 是否在 map 中：

- 若存在：直接返回两个索引`i`和`hashmap.find(nums[i])`；
- 若不存在：将当前元素和索引存入 hashmap。

时间复杂度：O (n)（仅遍历一次数组，每次查找 O (1)）。

### 2. 数组去重 / 统计频率：快速去重与计数

**问题 1（去重）**：删除数组中的重复元素，返回新数组长度。

**哈希表思路**：用`unordered_set`遍历数组，插入所有元素（自动去重），最后返回 set 的大小。

```c++
unordered_set<int> numSet(nums.begin(),nums.end());
```

**时间复杂度**：O (n)（比排序去重的 O (nlogn) 更高效）。



**问题 2（统计频率）**：统计数组中每个元素出现的次数。

**哈希表思路**：用`unordered_map`，Key 为元素值，Value 为出现次数，遍历数组时累加 Value。

```c++
unordered_map<int,int> hashmap;
hashmap[key]++;
```

**时间复杂度**：O(n)。

### 3. 最长无重复子串（LeetCode #3）：快速判断重复字符

**问题**：找到字符串中不含重复字符的最长子串长度。

**哈希表思路**：用`unordered_map`存储 “字符 → 最近出现的索引”，通过滑动窗口维护无重复子串，当遇到重复字符时，更新窗口左边界为 “重复字符的下一个索引”，避免重新遍历。

**时间复杂度**：O (n)（仅遍历一次字符串，每次查找和更新 O (1)）。

### 4. 查找两个数组的交集（LeetCode #349）：快速判断元素归属

**问题**：找到两个数组的交集（元素唯一）。

**哈希表思路**：用`unordered_set`存储第一个数组的所有元素（去重），再遍历第二个数组，判断元素是否在 set 中，若存在则加入结果集（并从 set 中删除，避免重复）。

**时间复杂度**：O (m+n)（m、n 为两个数组长度）。

### 5. LRU 缓存（LeetCode #146）：哈希表 + 链表的组合应用

**问题**：设计缓存结构，支持`get`（获取键对应值）和`put`（插入键值对），当缓存满时，删除 “最近最少使用” 的元素。

**哈希表思路**：用`unordered_map`存储 “Key → 链表节点指针”（O (1) 查找节点），用双向链表维护元素的 “使用顺序”（O (1) 删除 / 移动节点）。两者结合实现 LRU 缓存的 O (1) 操作。

## 四、哈希表的局限性与替代方案

尽管哈希表高效，但并非万能，需注意其局限性：

1. **无序性**：若需要 “有序存储”（如按 Key 排序），需用**红黑树实现的容器**（如 C++ 的`set`/`map`），但操作复杂度会上升到 O (logn)；
2. **哈希函数依赖**：若哈希函数设计不合理（如分布不均），会导致冲突激增，性能退化到 O (n)；
3. **内存消耗**：为降低冲突，哈希表需预留一定的空闲空间（负载因子 < 1），内存利用率低于数组或链表；
4. **不可直接遍历有序元素**：若需按 Key 或 Value 排序，需先将哈希表的元素存入数组，再排序（额外 O (nlogn) 时间）。



# 双指针

在数据结构与算法中，双指针是一种通过维护两个“指针”（可以是数组/链表的索引、游标或者简单的位置标记），协同遍历数据结构来高效解决问题的技巧，它的核心优势是将原本需要嵌套循环的**O (n²) 时间复杂度**优化为 **O (n) 或 O (n log n)**，大幅提升效率

### 一、双指针的本质与核心思想

这里的“指针”是指广义上的位置标记 （如数组的索引 `i`/`j`、链表的节点引用 `slow`/`fast`）。其核心思想是：通过**合理定义两个指针的移动规则**（如 “同向移动”“反向移动”），让两个指针在一次遍历中完成原本需要多次遍历的任务，减少冗余操作。

### 二、双指针的常见类型与适用场景

根据指针的移动方向和用途，双指针主要分为以下 4 类，不同类型对应不同的典型场景：

1. 同向双指针（快慢指针）

- **特点**：两个指针从同一端（通常是起始位置）出发，沿相同方向移动，但移动速度不同（“快指针” 移动更快，“慢指针” 移动较慢或按需移动）。
- 核心用途：在线性数据结构（数组，链表）中定位“特定元素”或“筛选元素”，避免使用额外空间

|       典型场景       |                           问题描述                           |                         指针移动规则                         |
| :------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   移除数组重复元素   |   给定有序数组，移除重复元素，返回新长度（如 LeetCode 26）   | 慢指针 `slow` 指向 “有效元素的末尾”，快指针 `fast` 遍历数组：若 `nums[fast] != nums[slow]`，则 `slow` 后移并赋值 `nums[slow] = nums[fast]`。 |
|      链表环检测      |  判断单链表是否有环，或找到环的入口（如 LeetCode 141、142）  | 慢指针 `slow` 每次走 1 步，快指针 `fast` 每次走 2 步：若相遇则有环；相遇后让 `slow` 回起点，两指针再同步走 1 步，相遇点即为环入口。 |
|   找到链表中间节点   |           找到单链表的中间节点（如 LeetCode 876）            | 慢指针走 1 步，快指针走 2 步：当快指针到达末尾时，慢指针恰好指向中间节点。 |
| 数组 “原地” 筛选元素 | 移除数组中等于特定值的元素（如 LeetCode 27），或筛选出满足条件的元素 | 慢指针 `slow` 记录 “筛选后元素的位置”，快指针 `fast` 遍历数组：若 `nums[fast]` 满足条件，则赋值给 `nums[slow]` 并 `slow` 后移。 |

#### 2. 反向双指针（左右指针）

- **特点**：两个指针分别从数据结构的**两端（左端点 `left`、右端点 `right`）** 出发，沿相反方向向中间移动，直到相遇或满足特定条件。
- **核心用途**：解决 **“有序数组 / 区间”** 的匹配、求和、优化问题，利用有序性减少无效遍历。

| 典型场景             | 问题描述                                                     | 指针移动规则                                                 |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 两数之和（有序数组） | 给定有序数组和目标值，找到两个数使其和为目标值（如 LeetCode 167） | 计算 `sum = nums[left] + nums[right]`：若 `sum < target`，`left` 右移（增大和）；若 `sum > target`，`right` 左移（减小和）；若相等则返回索引。 |
| 盛最多水的容器       | 给定数组（表示柱子高度），找到两根柱子使容器装水最多（如 LeetCode 11） | 容器容量 = 两指针距离 × 较短柱子高度。为最大化容量，优先移动较短柱子的指针（若移动长柱子，距离减小且高度不增，容量必降）。 |
| 反转数组 / 字符串    | 将数组或字符串原地反转（如 LeetCode 344）                    | 交换 `nums[left]` 和 `nums[right]`，然后 `left` 右移、`right` 左移，直到 `left >= right`。 |
| 二分查找变种         | 查找有序数组中目标值的第一个 / 最后一个位置（如 LeetCode 34） | 左指针 `left=0`，右指针 `right=n-1`，通过调整指针边界缩小范围，精准定位目标区间。 |

#### 3. 滑动窗口双指针

- **特点**：本质是 “同向双指针” 的延伸，两个指针（`left` 左边界、`right` 右边界）定义一个 “窗口”（连续子数组 / 子串），通过移动右指针扩大窗口、移动左指针缩小窗口，动态维护窗口内的信息（如和、长度、元素频次）。
- **核心用途**：解决 “连续子数组 / 子串” 的优化问题（如最短、最长、满足条件的子串），避免暴力枚举所有子串。

| 典型场景             | 问题描述                                                     | 指针移动规则                                                 |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 无重复字符的最长子串 | 找到字符串中无重复字符的最长子串长度（如 LeetCode 3）        | 右指针 `right` 遍历字符串，用哈希表记录字符最后出现位置；若字符已在窗口内，则将 `left` 移到 “字符上次位置 + 1”（确保窗口无重复），同时更新最长长度。 |
| 最小覆盖子串         | 找到字符串 `s` 中包含 `t` 所有字符的最短子串（如 LeetCode 76） | 右指针扩大窗口，直到包含 `t` 所有字符；再移动左指针缩小窗口，直到不包含 `t` 所有字符，记录过程中最短窗口。 |
| 长度最小的子数组     | 找到数组中 “和 ≥ 目标值” 的最短子数组（如 LeetCode 209）     | 右指针扩大窗口并累加和；当和 ≥ 目标值时，移动左指针减小窗口，同时更新最短长度。 |

#### 4. 交叉双指针（多数组遍历）

- **特点**：两个指针分别指向**两个不同的数组**，按规则同步或异步移动，用于处理两个数组的 “合并”“比较” 或 “匹配” 问题。
- **核心用途**：合并有序数组、寻找两个数组的交集 / 并集等。

| 典型场景         | 问题描述                                                     | 指针移动规则                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 合并两个有序数组 | 将有序数组 `nums2` 合并到有序数组 `nums1` 中，保持整体有序（如 LeetCode 88） | 用两个指针 `i`（`nums1` 有效元素末尾）、`j`（`nums2` 末尾），从后向前比较，将较大元素放入 `nums1` 末尾，同时指针前移。 |
| 两个数组的交集   | 找到两个有序数组的交集（元素可重复，如 LeetCode 350）        | 指针 `i` 指向 `nums1`，`j` 指向 `nums2`：若 `nums1[i] == nums2[j]`，加入结果并两指针同移；若 `nums1[i] < nums2[j]`，`i` 右移；否则 `j` 右移。 |



### 三、双指针的优势与局限性

#### 优势：

1. 效率高：将嵌套循环的复杂度降至，适合大规模数据
2. 省空间：大多为“原地操作”，无需开辟数组或哈希表等空间
3. 逻辑直观：通过指针移动规则可直接映射问题逻辑，易于理解实现

#### 局限性：

1. **依赖数据结构的特性**：部分场景需数据有序（如两数之和、合并数组），无序时需先排序（增加 O (n log n) 复杂度）。
2. **不适用非线性结构**：主要针对数组、链表、字符串等线性结构，树、图等非线性结构需结合其他算法（如 BFS/DFS）。



### 四、经典例题实战（以 “移除有序数组重复元素” 为例）

#### 题目：

给你一个**非严格递增排列**的数组 `nums`，请你**原地**删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。

#### 双指针解法：

```python
def removeDuplicates(nums):
    if not nums:  # 边界条件：空数组直接返回0
        return 0
    slow = 0  # 慢指针：指向最后一个不重复元素的位置
    for fast in range(1, len(nums)):  # 快指针：遍历整个数组
        if nums[fast] != nums[slow]:  # 找到新的不重复元素
            slow += 1  # 慢指针后移，指向新的不重复位置
            nums[slow] = nums[fast]  # 将新元素赋值到慢指针位置
    return slow + 1  # 新长度 = 慢指针索引 + 1
```

- **复杂度**：时间 O (n)（仅遍历一次数组），空间 O (1)（原地操作）。
- **逻辑**：慢指针维护 “有效区间”，快指针探索新元素，仅当找到不重复元素时更新有效区间，避免冗余赋值。





# queue队列

在 C++ STL（标准模板库）中，`queue`（队列）是一种**先进先出（FIFO, First-In-First-Out）** 的容器适配器（Container Adapter）—— 它不直接存储数据，而是基于底层容器（默认是`deque`）实现队列的核心功能，仅暴露符合 “队列逻辑” 的接口，屏蔽底层容器的其他操作（如随机访问）。

## 一、queue 的核心特性

1. **FIFO 顺序**：第一个插入的元素（队尾），会第一个被取出（队头），类似现实中的 “排队”。
2. **容器适配器**：依赖底层容器实现，默认用`deque`（双端队列），也可指定`list`（链表）作为底层容器（但不能用`vector`，因为`vector`不支持高效的 “队头删除” 操作）。
3. **受限接口**：仅提供队列必需的操作（如入队、出队、访问队头 / 队尾），不支持迭代器遍历（无法直接访问中间元素），确保严格遵循 FIFO 逻辑。

## 二、queue 的定义与头文件

使用`queue`前必须包含头文件：

cpp







```cpp
#include <queue>  // 注意：不是<queue.h>，STL无.h后缀
```

### 定义语法

cpp







```cpp
// 1. 默认底层容器（deque），存储类型为T
std::queue<T> q;

// 2. 指定底层容器（如list），需包含对应头文件（<list>）
std::queue<T, std::list<T>> q;
```

**示例**：

cpp







```cpp
#include <queue>
#include <list>

// 存储int的默认队列（底层deque）
std::queue<int> q1;

// 存储string的队列（底层list）
std::queue<std::string, std::list<std::string>> q2;
```

## 三、queue 的常用成员函数

`queue`的接口设计简洁，仅保留与 “队列操作” 相关的函数，核心分为**入队、出队、访问、状态查询**四类：

| 成员函数                  | 功能描述                                                     |
| ------------------------- | ------------------------------------------------------------ |
| **入队操作**              |                                                              |
| `push(const T& val)`      | 将元素`val`插入到**队尾**（调用底层容器的`push_back()`），无返回值。 |
| `emplace(Args&&... args)` | 直接在队尾**构造元素**（避免拷贝 / 移动，效率更高），C++11 及以上支持。 |
| **出队操作**              |                                                              |
| `pop()`                   | 删除**队头**元素（调用底层容器的`pop_front()`），无返回值，且不返回被删元素。 |
| **访问操作**              |                                                              |
| `front()`                 | 返回**队头**元素的引用（可修改，如`q.front() = 10`），若队空则行为未定义。 |
| `back()`                  | 返回**队尾**元素的引用（可修改），若队空则行为未定义。       |
| **状态查询**              |                                                              |
| `empty()`                 | 判断队列是否为空，返回`bool`（空为`true`，非空为`false`）。  |
| `size()`                  | 返回队列中元素的个数，类型为`size_t`（无符号整数）。         |

### 函数使用示例

cpp







```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;

    // 1. 入队（push/emplace）
    q.push(10);    // 队尾插入10 → 队列：[10]
    q.emplace(20); // 队尾构造20 → 队列：[10, 20]
    q.push(30);    // 队尾插入30 → 队列：[10, 20, 30]

    // 2. 状态查询
    cout << "队列是否为空：" << (q.empty() ? "是" : "否") << endl; // 否
    cout << "队列元素个数：" << q.size() << endl;                  // 3

    // 3. 访问队头/队尾
    cout << "队头元素：" << q.front() << endl; // 10（第一个插入的元素）
    cout << "队尾元素：" << q.back() << endl;  // 30（最后插入的元素）

    // 4. 出队（pop需配合front使用，才能获取被删元素）
    q.pop(); // 删除队头10 → 队列：[20, 30]
    cout << "出队后队头：" << q.front() << endl; // 20

    q.pop(); // 删除队头20 → 队列：[30]
    q.pop(); // 删除队头30 → 队列：空
    cout << "全部出队后是否为空：" << (q.empty() ? "是" : "否") << endl; // 是

    return 0;
}
```

**输出结果**：

plaintext







```plaintext
队列是否为空：否
队列元素个数：3
队头元素：10
队尾元素：30
出队后队头：20
全部出队后是否为空：是
```

## 四、queue 的底层容器选择

`queue`的底层容器必须支持以下操作（STL 中`deque`和`list`满足，`vector`不满足）：

- `push_back()`：队尾插入（入队）。
- `pop_front()`：队头删除（出队）。
- `front()`：访问队头。
- `back()`：访问队尾。
- `empty()`/`size()`：状态查询。

### 两种常用底层容器对比

| 底层容器 | 优势                                                         | 劣势                                                     | 适用场景                                       |
| -------- | ------------------------------------------------------------ | -------------------------------------------------------- | ---------------------------------------------- |
| `deque`  | ① 随机访问效率高于`list`；② 内存连续（分段），缓存友好       | 队头 / 队尾操作效率略低于`list`（但仍 O (1)）            | 需兼顾 “队列操作” 和底层容器潜在的随机访问需求 |
| `list`   | ① 队头 / 队尾插入 / 删除是纯 O (1)（无内存移动）；② 节点动态分配，内存灵活 | ① 不支持随机访问；② 节点存储指针，内存开销大，缓存不友好 | 频繁进行大量入队 / 出队操作，且无需随机访问    |

**默认选择`deque`的原因**：`deque`在 “队列操作效率” 和 “内存利用率” 之间平衡更好，大多数场景下无需手动指定`list`。

## 五、queue 的注意事项

1. **禁止访问空队列的 front ()/back ()**：若队列空时调用`front()`或`back()`，行为是**未定义的**（可能崩溃或返回垃圾值），需先通过`empty()`判断队列非空。

   错误示例：

   cpp

   

   

   

   ```cpp
   queue<int> q;
   cout << q.front(); // 错误：队列空，行为未定义
   ```

   

   正确示例：

   cpp

   

   

   

   ```cpp
   if (!q.empty()) {
       cout << q.front();
   }
   ```

   

2. **pop () 不返回被删元素**：`queue::pop()`仅删除队头元素，不返回它。若需获取被删元素，需先通过`front()`读取，再调用`pop()`。

   错误示例：

   cpp

   

   

   

   ```cpp
   int val = q.pop(); // 错误：pop()无返回值
   ```

   

   正确示例：

   cpp

   

   

   

   ```cpp
   int val = q.front(); // 先读
   q.pop();             // 再删
   ```

   

3. **不支持迭代器和随机访问**：`queue`没有`begin()`、`end()`迭代器，无法用`for`循环遍历所有元素（若需遍历，需先出队并暂存元素，遍历后再重新入队，但会破坏原队列结构）。

   遍历示例（破坏原队列）：

   ```cpp
   queue<int> q;
   q.push(10), q.push(20), q.push(30);
   
   // 遍历：出队并打印
   while (!q.empty()) {
       cout << q.front() << " "; // 10 20 30
       q.pop();
   }
   // 遍历后队列空
   ```

   

## 六、queue 的应用场景

`queue`的 FIFO 特性使其适合处理 “按顺序排队” 的问题，典型场景包括：

1. **任务调度**：如线程池的任务队列（先提交的任务先执行）。
2. **广度优先搜索（BFS）**：如二叉树的层序遍历、图的最短路径（FIFO 顺序确保每一层节点按顺序处理）。
3. **缓冲队列**：如 IO 缓冲区（先接收的数据先处理）。
4. **模拟排队场景**：如银行叫号系统、打印机任务队列。





# deque

在 C++ STL（标准模板库）中，**deque**（双端队列，Double-Ended Queue）是一种支持在**两端快速插入和删除**的序列容器，同时也支持随机访问（但效率低于`vector`）。其核心特点是 “双端操作高效”，弥补了`vector`只能高效尾插、`queue`只能单端操作的不足。

### 一、deque 的核心特性

1. **双端高效操作**：头部（front）和尾部（back）的插入（`push_front`/`push_back`）、删除（`pop_front`/`pop_back`）均为 **O (1) 时间复杂度**。
2. **随机访问支持**：通过下标（`[]`）或`at()`访问元素，时间复杂度 **O(1)**，但底层实现比`vector`复杂（非连续内存），实际访问效率略低。
3. **动态扩容**：容量不足时自动扩容，无需手动管理（类似`vector`），但扩容策略更灵活（避免`vector`扩容时的大规模数据拷贝）。
4. **非连续内存**：底层由多个 “分段连续的缓冲区” 组成，通过内部指针数组（map）管理，既兼顾了双端操作效率，又减少了连续内存的分配压力。

### 二、deque 的常用操作（API）

使用`deque`前需包含头文件：`#include <deque>`，并使用`std`命名空间（或显式声明`std::deque`）。

以下是最常用的成员函数，按 “构造 / 赋值”“元素访问”“插入删除”“容量 / 状态” 分类说明：

#### 1. 构造与赋值

| 函数原型                      | 功能说明                                                     |
| ----------------------------- | ------------------------------------------------------------ |
| `deque<T> d`                  | 默认构造：创建空的 deque（T 为元素类型，如 int、string）     |
| `deque<T> d(n, val)`          | 构造：创建含 n 个值为 val 的元素的 deque                     |
| `deque<T> d(beg, end)`        | 范围构造：用 [beg, end) 区间的元素初始化（beg/end 为迭代器，如数组指针、其他容器的迭代器） |
| `deque<T> d(const deque& d2)` | 拷贝构造：用另一个 deque d2 初始化                           |
| `d = d2`                      | 赋值运算符：将 d2 的元素赋值给 d                             |
| `d.assign(beg, end)`          | 赋值：用 [beg, end) 区间的元素替换 d 的所有元素              |
| `d.assign(n, val)`            | 赋值：用 n 个 val 替换 d 的所有元素                          |

**示例**：

cpp







```cpp
#include <deque>
#include <iostream>
using namespace std;

int main() {
    // 1. 默认构造
    deque<int> d1;
    
    // 2. 初始化3个10
    deque<int> d2(3, 10);  // d2: [10, 10, 10]
    
    // 3. 用数组初始化
    int arr[] = {1,2,3,4};
    deque<int> d3(arr, arr+4);  // d3: [1,2,3,4]
    
    // 4. 拷贝构造
    deque<int> d4(d3);  // d4: [1,2,3,4]
    
    // 5. assign赋值
    d1.assign(2, 5);    // d1: [5,5]
    d1.assign(d3.begin(), d3.end());  // d1: [1,2,3,4]
    
    return 0;
}
```

#### 2. 元素访问

| 函数原型    | 功能说明                                                     |
| ----------- | ------------------------------------------------------------ |
| `d.at(idx)` | 返回下标 idx 处的元素，**越界时抛异常**（比`[]`更安全）      |
| `d[idx]`    | 返回下标 idx 处的元素，**越界时行为未定义**（效率略高）      |
| `d.front()` | 返回 deque 的**第一个元素**（不检查空否，空 deque 调用会崩溃） |
| `d.back()`  | 返回 deque 的**最后一个元素**（同上，需确保非空）            |

**示例**：

cpp







```cpp
deque<int> d = {10,20,30,40};
cout << d[1] << endl;    // 输出20（下标从0开始）
cout << d.at(2) << endl; // 输出30
cout << d.front() << endl; // 输出10
cout << d.back() << endl;  // 输出40

// d.at(10); // 越界，抛out_of_range异常
// d[10];    // 越界，行为未定义（可能崩溃或乱码）
```

#### 3. 插入与删除

deque 的核心优势体现在双端插入 / 删除，同时也支持中间插入（但效率较低，O (n)）。

| 函数原型                  | 功能说明                                                     |
| ------------------------- | ------------------------------------------------------------ |
| **尾部操作（O (1)）**     |                                                              |
| `d.push_back(val)`        | 在 deque**尾部插入**一个元素 val                             |
| `d.pop_back()`            | 删除 deque**尾部的元素**（无返回值，需确保非空）             |
| **头部操作（O (1)）**     |                                                              |
| `d.push_front(val)`       | 在 deque**头部插入**一个元素 val                             |
| `d.pop_front()`           | 删除 deque**头部的元素**（无返回值，需确保非空）             |
| **中间操作（O (n)）**     |                                                              |
| `d.insert(pos, val)`      | 在迭代器 pos 指向的位置**插入一个 val**，返回指向新元素的迭代器 |
| `d.insert(pos, n, val)`   | 在 pos 位置插入 n 个 val                                     |
| `d.insert(pos, beg, end)` | 在 pos 位置插入 [beg, end) 区间的元素                        |
| `d.erase(pos)`            | 删除 pos 指向的元素，返回指向删除后下一个元素的迭代器        |
| `d.erase(beg, end)`       | 删除 [beg, end) 区间的元素，返回指向删除后下一个元素的迭代器 |
| **清空**                  |                                                              |
| `d.clear()`               | 删除 deque 中所有元素，size 变为 0（容量可能不变）           |

**示例**：

cpp







```cpp
deque<int> d = {2,3};

// 1. 尾部插入/删除
d.push_back(4);  // d: [2,3,4]
d.pop_back();    // d: [2,3]

// 2. 头部插入/删除
d.push_front(1); // d: [1,2,3]
d.pop_front();   // d: [2,3]

// 3. 中间插入（在第2个元素前插入5）
auto it = d.begin() + 1; // 指向3（迭代器支持随机移动）
d.insert(it, 5);         // d: [2,5,3]

// 4. 中间删除（删除5）
it = d.begin() + 1;
d.erase(it);             // d: [2,3]

// 5. 清空
d.clear();               // d为空，size=0
```

#### 4. 容量与状态

| 函数原型           | 功能说明                                                     |
| ------------------ | ------------------------------------------------------------ |
| `d.empty()`        | 判断 deque 是否为空（空返回 true，非空返回 false），O (1)    |
| `d.size()`         | 返回 deque 中元素的个数，O (1)                               |
| `d.max_size()`     | 返回 deque 理论上能容纳的最大元素个数（受系统内存限制），O (1) |
| `d.resize(n)`      | 调整 deque 大小为 n：- 若 n < 当前 size：删除多余元素；- 若 n > 当前 size：补默认值（如 int 补 0） |
| `d.resize(n, val)` | 调整大小为 n，若 n > 当前 size：补 val 而非默认值            |
| `d.capacity()`     | 返回当前 deque 的容量（注意：部分编译器可能不支持，因 deque 底层非连续内存，容量定义不统一） |

**示例**：

cpp







```cpp
deque<int> d = {1,2,3};
cout << d.empty() << endl;  // 输出0（非空）
cout << d.size() << endl;   // 输出3

d.resize(5, 0);             // d: [1,2,3,0,0]，size=5
d.resize(2);                // d: [1,2]，size=2

cout << d.max_size() << endl; // 输出理论最大值（如68719476735，视系统而定）
```

### 三、deque 的迭代器

deque 支持完整的迭代器操作，可用于遍历、插入、删除等场景。常用迭代器类型：

- `d.begin()`：指向第一个元素的**正向迭代器**
- `d.end()`：指向最后一个元素**下一位**的正向迭代器（尾后迭代器，不可解引用）
- `d.rbegin()`：指向最后一个元素的**反向迭代器**（++ 操作指向前一个元素）
- `d.rend()`：指向第一个元素**前一位**的反向迭代器
- `d.cbegin()`/`d.cend()`：const 正向迭代器（不可修改元素）

**遍历示例**：

cpp







```cpp
deque<int> d = {10,20,30,40};

// 1. 正向遍历（迭代器）
for (auto it = d.begin(); it != d.end(); ++it) {
    cout << *it << " ";  // 输出：10 20 30 40
}

// 2. 反向遍历（反向迭代器）
for (auto rit = d.rbegin(); rit != d.rend(); ++rit) {
    cout << *rit << " ";  // 输出：40 30 20 10
}

// 3. 范围for（C++11及以上，本质是迭代器封装）
for (int val : d) {
    cout << val << " ";  // 输出：10 20 30 40
}
```

### 四、deque 与 vector、queue 的对比

| 容器     | 核心优势                              | 核心劣势                                | 适用场景                           |
| -------- | ------------------------------------- | --------------------------------------- | ---------------------------------- |
| `deque`  | 双端插入 / 删除 O (1)，随机访问 O (1) | 中间插入 / 删除 O (n)，随机访问效率略低 | 需双端操作（如滑动窗口）、队列实现 |
| `vector` | 随机访问 O (1)，尾插 O (1)            | 头部 / 中间插入 / 删除 O (n)            | 需频繁随机访问、尾插，少删除       |
| `queue`  | 单端（FIFO）操作 O (1)                | 不支持随机访问、双端操作                | 纯队列场景（如 BFS）               |

**注意**：STL 中的`queue`默认以`deque`为底层容器实现（`template <class T, class Container = deque<T>> class queue`），因为`deque`的双端操作能力能高效满足`queue`的`push_back`（入队）和`pop_front`（出队）需求。

### 五、常见问题与注意事项

1. **避免在中间插入 / 删除**：deque 中间操作需移动大量元素，效率为 O (n)，若需频繁中间操作，建议用`list`（双向链表）。

2. 迭代器失效问题

   ：

   - 头部 / 尾部插入 / 删除时，除`end()`迭代器外，其他迭代器通常不失效；
   - 中间插入 / 删除或扩容时，所有迭代器、指针、引用可能失效，需重新获取。

3. **空容器操作**：调用`front()`/`back()`/`pop_front()`/`pop_back()`前，务必用`empty()`判断容器非空，否则会导致未定义行为（崩溃）。

通过以上内容，可掌握 deque 的核心用法。实际开发中，若需 “双端快速操作 + 随机访问”，deque 是首选容器。





# Priority_queue

在 C++ STL（标准模板库）中，**priority_queue（优先队列）** 是一种基于「堆（heap）」数据结构实现的容器适配器，其核心特性是：**每次访问或弹出的元素，始终是队列中「优先级最高」的元素**（默认是最大元素，可自定义优先级规则）。它不支持随机访问，仅支持访问和删除队首（优先级最高）元素，以及在队尾插入元素。

### 一、priority_queue 的核心特性

1. **底层实现**：默认基于 `vector` 作为底层存储容器，并用「堆算法」维护优先级（也可指定 `deque` 作为底层容器，但 `vector` 更常用）。

2. 优先级规则

   ：

   - 默认是「大顶堆」：优先级最高的元素是最大值，每次弹出队首（最大元素）。
   - 可通过自定义比较函数（或仿函数）改为「小顶堆」，或按自定义规则排序（如结构体成员优先级）。

3. **不支持的操作**：不支持遍历（无迭代器）、不支持删除非队首元素、不支持随机访问（如 `[]` 或 `at()`）。

4. 时间复杂度

   ：

   - 插入元素（`push`）：O (log n)（堆的上浮调整）。
   - 弹出队首（`pop`）：O (log n)（堆的下沉调整）。
   - 访问队首（`top`）：O (1)（直接访问堆顶）。

### 二、priority_queue 的基本用法

#### 1. 头文件与定义

使用 `priority_queue` 需包含头文件 `<queue>`，其模板定义如下：

cpp







```cpp
template <
    class T,                     // 存储的元素类型（如 int、string、结构体）
    class Container = vector<T>,  // 底层存储容器（默认 vector，可选 deque）
    class Compare = less<T>       // 比较函数（默认 less<T> 即大顶堆，可选 greater<T> 小顶堆）
> class priority_queue;
```

#### 2. 常见成员函数

priority_queue 的接口简洁，核心成员函数如下：

| 成员函数             | 功能描述                                                     |
| -------------------- | ------------------------------------------------------------ |
| `push(const T& val)` | 向队尾插入元素，插入后自动调整堆结构，维持优先级规则（O (log n)）。 |
| `pop()`              | 删除队首（优先级最高）的元素，删除后自动调整堆结构（O (log n)，**无返回值**）。 |
| `top()`              | 返回队首（优先级最高）元素的引用（O (1)，仅访问不删除，需先判断非空）。 |
| `empty()`            | 判断队列是否为空，为空返回 `true`，否则返回 `false`（O(1)）。 |
| `size()`             | 返回队列中元素的个数（O (1)）。                              |

### 三、实战示例

根据元素类型（基础类型、结构体）和优先级规则（大顶堆、小顶堆），分场景演示用法。

#### 场景 1：基础类型（int）的默认大顶堆

默认情况下，`priority_queue<int>` 是大顶堆，每次 `top()` 取最大值，`pop()` 删除最大值。

cpp







```cpp
#include <iostream>
#include <queue>  // 包含 priority_queue

using namespace std;

int main() {
    // 1. 定义 int 类型的 priority_queue（默认大顶堆）
    priority_queue<int> pq;

    // 2. 插入元素（push）
    pq.push(30);
    pq.push(10);
    pq.push(50);
    pq.push(20);

    // 3. 访问与删除（需先判断非空）
    while (!pq.empty()) {
        // 访问队首（最大值）
        cout << "当前队首（最大值）：" << pq.top() << endl;
        // 删除队首
        pq.pop();
    }

    return 0;
}
```

**输出结果**（每次取最大值）：

plaintext







```plaintext
当前队首（最大值）：50
当前队首（最大值）：30
当前队首（最大值）：20
当前队首（最大值）：10
```

#### 场景 2：基础类型（int）的小顶堆

若需「小顶堆」（每次取最小值），需显式指定比较函数为 `greater<T>`，且底层容器需显式写出（不能省略）。

cpp







```cpp
#include <iostream>
#include <queue>
#include <vector>  // 需包含底层容器的头文件

using namespace std;

int main() {
    // 定义 int 类型的小顶堆：指定 Container 为 vector<int>，Compare 为 greater<int>
    priority_queue<int, vector<int>, greater<int>> pq;

    // 插入元素
    pq.push(30);
    pq.push(10);
    pq.push(50);
    pq.push(20);

    // 访问与删除（每次取最小值）
    while (!pq.empty()) {
        cout << "当前队首（最小值）：" << pq.top() << endl;
        pq.pop();
    }

    return 0;
}
```

**输出结果**（每次取最小值）：

plaintext







```plaintext
当前队首（最小值）：10
当前队首（最小值）：20
当前队首（最小值）：30
当前队首（最大值）：50
```

#### 场景 3：自定义类型（结构体）的优先级

若存储的是结构体（如「学生信息」，需按「分数」或「学号」排序），需自定义比较规则（通过**仿函数**或**lambda 表达式**实现）。

##### 示例：按学生分数降序（分数高的优先级高）

cpp







```cpp
#include <iostream>
#include <queue>
#include <string>
#include <vector>

using namespace std;

// 定义结构体：学生信息
struct Student {
    string name;  // 姓名
    int score;    // 分数
    int id;       // 学号

    // 构造函数：方便初始化
    Student(string n, int s, int i) : name(n), score(s), id(i) {}
};

// 自定义比较仿函数（用于大顶堆：分数高的优先级高）
struct CompareScoreDesc {
    // 重载 () 运算符，定义比较规则：a 的优先级低于 b 时返回 true
    bool operator()(const Student& a, const Student& b) {
        // 分数低的排在后面（即分数高的先出队）
        return a.score < b.score;
    }
};

int main() {
    // 定义结构体类型的 priority_queue，使用自定义仿函数
    priority_queue<Student, vector<Student>, CompareScoreDesc> pq;

    // 插入学生信息
    pq.push(Student("Alice", 95, 101));
    pq.push(Student("Bob", 88, 102));
    pq.push(Student("Charlie", 98, 103));
    pq.push(Student("David", 92, 104));

    // 输出优先级最高的学生（分数从高到低）
    while (!pq.empty()) {
        Student top_stu = pq.top();
        cout << "姓名：" << top_stu.name 
             << "，分数：" << top_stu.score 
             << "，学号：" << top_stu.id << endl;
        pq.pop();
    }

    return 0;
}
```

**输出结果**（按分数降序）：

plaintext







```plaintext
姓名：Charlie，分数：98，学号：103
姓名：Alice，分数：95，学号：101
姓名：David，分数：92，学号：104
姓名：Bob，分数：88，学号：102
```

##### 扩展：按多个字段排序（如分数相同按学号升序）

只需修改仿函数的比较逻辑：

cpp







```cpp
struct CompareScoreDesc {
    bool operator()(const Student& a, const Student& b) {
        if (a.score != b.score) {
            // 分数不同：分数低的优先级低
            return a.score < b.score;
        } else {
            // 分数相同：学号大的优先级低（学号小的先出队）
            return a.id > b.id;
        }
    }
};
```

#### 场景 4：用 lambda 表达式自定义优先级（C++11 及以上）

对于简单的比较逻辑，可直接用 lambda 表达式替代仿函数，但需注意：lambda 表达式不能直接作为 `priority_queue` 的模板参数，需通过 `function` 包装。

示例：小顶堆（按学生分数升序）

cpp







```cpp
#include <iostream>
#include <queue>
#include <string>
#include <vector>
#include <functional>  // 包含 function 头文件

using namespace std;

struct Student {
    string name;
    int score;
    Student(string n, int s) : name(n), score(s) {}
};

int main() {
    // 用 lambda 表达式定义比较规则（小顶堆：分数低的先出队）
    auto cmp = [](const Student& a, const Student& b) {
        return a.score > b.score;  // 分数高的优先级低（排在后面）
    };

    // 定义 priority_queue：用 function 包装 lambda
    priority_queue<Student, vector<Student>, function<bool(const Student&, const Student&)>> pq(cmp);

    // 插入元素
    pq.push(Student("Alice", 95));
    pq.push(Student("Bob", 88));
    pq.push(Student("Charlie", 98));

    // 输出（按分数升序）
    while (!pq.empty()) {
        cout << pq.top().name << "：" << pq.top().score << endl;
        pq.pop();
    }

    return 0;
}
```

**输出结果**：

plaintext







```plaintext
Bob：88
Alice：95
Charlie：98
```

### 四、注意事项

1. **`pop()` 无返回值**：若需获取弹出的元素，需先调用 `top()` 访问，再调用 `pop()` 删除（顺序不可颠倒）。
2. **避免访问空队列**：调用 `top()` 或 `pop()` 前，必须用 `empty()` 判断队列是否非空，否则会触发未定义行为。
3. **底层容器的选择**：默认 `vector` 足够高效，若需频繁插入 / 删除且内存分配敏感，可尝试 `deque`，但两者时间复杂度一致。
4. **自定义类型需显式比较规则**：若存储的是自定义结构体 / 类，必须提供比较函数（仿函数或 `function` 包装的 lambda），否则编译器无法判断优先级。
5. **不支持遍历**：`priority_queue` 没有迭代器，无法用 `for` 循环遍历所有元素，只能通过 `top()` + `pop()` 逐个处理。

### 五、适用场景

priority_queue 适合需要「动态获取优先级最高元素」的场景，例如：

- 任务调度（高优先级任务先执行）。
- 最短路径算法（如 Dijkstra 算法，每次选距离起点最近的节点）。
- 海量数据中取 Top K 元素（如取前 10 个最大数，用小顶堆优化）。

通过灵活自定义优先级规则，priority_queue 可以满足各种复杂的排序需求，是 STL 中非常实用的容器适配器。





C++ 标准模板库（STL）中的 `std::string` 是用于处理字符串的核心类，封装了字符串的存储、操作和管理逻辑，相比传统的 C 风格字符数组（`char[]`）更安全、便捷，支持丰富的成员函数和算法。以下从**基础使用**、**核心操作**、**高级功能**和**注意事项**四个维度，全面介绍 `std::string` 的用法。

### 一、基础准备：包含头文件与命名空间

使用 `std::string` 前，必须包含对应的头文件，并指定 `std` 命名空间（或显式使用 `std::` 前缀）：

cpp







```cpp
#include <string>  // 必须包含的头文件
using namespace std;  // 可选，避免重复写 std::
```

### 二、核心用法：从初始化到基本操作

#### 1. 字符串初始化（多种方式）

`std::string` 支持多种初始化方式，覆盖不同场景需求：

| 初始化方式         | 示例代码                                  | 说明                                  |
| ------------------ | ----------------------------------------- | ------------------------------------- |
| 默认初始化         | `string s;`                               | 空字符串，长度为 0，内存自动管理      |
| 字符串字面量初始化 | `string s = "Hello World";`               | 用 C 风格字符串初始化，自动处理长度   |
| 拷贝初始化         | `string s1 = s2;`                         | 复制另一个 string 对象的内容          |
| 部分字符初始化     | `string s("Hello", 3);`                   | 取前 3 个字符，结果为 "Hel"           |
| 重复字符初始化     | `string s(5, 'a');`                       | 5 个 'a' 组成的字符串，结果为 "aaaaa" |
| 迭代器范围初始化   | `string s(s2.begin() + 2, s2.end() - 1);` | 从 s2 的第 3 个字符到倒数第 2 个字符  |

#### 2. 基本属性获取

通过成员函数获取字符串的**长度**、**容量**等核心属性：

cpp







```cpp
string s = "Hello";
cout << s.size();      // 输出 5（当前字符串长度，同 length()）
cout << s.length();    // 输出 5（与 size() 功能完全一致，历史兼容）
cout << s.capacity();  // 输出当前内存可容纳的字符数（≥ size()，避免频繁扩容）
cout << s.empty();     // 输出 false（判断是否为空，空则返回 true）
cout << s.max_size();  // 输出当前系统支持的最大字符串长度（一般非常大）
```

#### 3. 字符访问（3 种方式）

`std::string` 支持类似数组的下标访问，也支持安全的边界检查：

- **下标运算符 `[]`**：无边界检查，越界访问会导致未定义行为（效率高）；
- **成员函数 `at()`**：有边界检查，越界会抛出 `out_of_range` 异常（安全）；
- **迭代器**：适合遍历或修改字符（STL 算法通用）。

示例：

cpp







```cpp
string s = "Hello";
cout << s[1];          // 输出 'e'（无检查）
cout << s.at(2);       // 输出 'l'（有检查）

// 迭代器遍历
for (string::iterator it = s.begin(); it != s.end(); ++it) {
    *it = toupper(*it);  // 修改字符为大写
}
cout << s;              // 输出 "HELLO"
```

### 三、核心操作：修改与拼接

#### 1. 字符串拼接（4 种常用方式）

`std::string` 支持灵活的拼接，无需手动管理内存：

cpp







```cpp
string s1 = "Hello", s2 = "World";

// 1. 使用 += 运算符（效率高，优先推荐）
s1 += " ";       // s1 变为 "Hello "
s1 += s2;        // s1 变为 "Hello World"

// 2. 使用 append() 成员函数（支持多种参数）
s1.append(3, '!');  // 追加 3 个 '!'，s1 变为 "Hello World!!!"
s1.append(s2, 2, 3); // 追加 s2 从索引 2 开始的 3 个字符（"rld"），s1 变为 "Hello World!!!rld"

// 3. 使用 + 运算符（会产生临时对象，效率略低，适合短字符串）
string s3 = s1 + " " + s2;  // s3 为 "Hello World!!!rld World"

// 4. 使用 insert() 插入到指定位置
s1.insert(5, ",");  // 在索引 5 处插入 ","，s1 变为 "Hello,, World!!!rld"
```

#### 2. 字符串修改（清空、替换、截取）

- **清空字符串**：`clear()` 直接清空内容（长度变为 0，容量可能保留）；
- **替换字符**：`replace()` 替换指定范围的字符；
- **截取子串**：`substr()` 获取指定范围的子串（注意：参数是「起始索引」和「长度」，而非结束索引）。

示例：

cpp







```cpp
string s = "Hello World";

s.clear();  // 清空，s 变为空字符串
s = "Hello World";  // 重新赋值

// 替换：从索引 6 开始的 5 个字符（"World"）替换为 "C++"
s.replace(6, 5, "C++");  // s 变为 "Hello C++"

// 截取子串：从索引 6 开始，截取 3 个字符（"C++"）
string sub = s.substr(6, 3);  // sub = "C++"

// 截取到末尾：只传起始索引（从索引 5 开始到末尾）
string sub2 = s.substr(5);  // sub2 = " C++"
```

### 四、高级功能：查找、比较与转换

#### 1. 字符串查找（`find()` 系列函数）

`std::string` 提供一套查找函数，返回匹配子串的**起始索引**（未找到则返回 `string::npos`，一个静态常量，表示 “无效索引”）：

| 函数名               | 功能描述                          | 示例                                    |
| -------------------- | --------------------------------- | --------------------------------------- |
| `find(str)`          | 从开头查找子串 str 的第一个位置   | `s.find("lo")` → 返回 3（s="Hello"）    |
| `rfind(str)`         | 从末尾查找子串 str 的最后一个位置 | `s.rfind("l")` → 返回 3（s="Hello"）    |
| `find_first_of(str)` | 查找 str 中任意字符的第一个位置   | `s.find_first_of("ow")` → 返回 4（'o'） |
| `find_last_of(str)`  | 查找 str 中任意字符的最后一个位置 | `s.find_last_of("le")` → 返回 3（'l'）  |

示例：

cpp







```cpp
string s = "Hello World";
size_t pos = s.find("World");  // pos = 6（找到）
if (pos != string::npos) {
    cout << "找到子串，起始索引：" << pos << endl;
}

pos = s.find("C++");  // pos = string::npos（未找到）
if (pos == string::npos) {
    cout << "未找到子串" << endl;
}
```

#### 2. 字符串比较（`compare()` 或运算符）

`std::string` 支持直接用关系运算符（`==`、`!=`、`<`、`>` 等）比较，也可通过 `compare()` 函数获取更精细的比较结果（按**字典序**比较）：

- 运算符比较：返回 `bool`（`s1 == s2` 判断是否相等，`s1 < s2` 判断是否字典序更小）；
- `compare()` 函数：返回 `int`（0 表示相等，正数表示 s1 更大，负数表示 s1 更小）。

示例：

cpp







```cpp
string s1 = "Apple", s2 = "Banana";

cout << (s1 == s2);  // 输出 0（不相等）
cout << (s1 < s2);   // 输出 1（'A' 字典序小于 'B'）

int res = s1.compare(s2);  // res = -1（s1 < s2）
res = s1.compare(1, 3, "ppl");  // 比较 s1 从索引1开始的3个字符（"ppl"）与 "ppl" → 返回 0
```

#### 3. 与 C 风格字符串的转换

`std::string` 与 C 风格字符数组（`char*`）的转换是高频需求，需注意安全：

- *

  string → char

  ```
  **：通过 
  ```

  c_str()

  ```
  或
  ```

  data()

  ```
  成员函数（C++17 后
  ```

  data ()` 可返回非 const 指针）；

  - 注意：返回的指针指向 `string` 内部缓冲区，**不能手动释放**，且 `string` 修改后指针可能失效。

- **char\* → string**：直接用 `string` 构造函数或赋值运算符（自动处理长度，无需担心 `\0`）。

示例：

cpp







```cpp
// string → char*
string s = "Hello";
const char* c_str1 = s.c_str();  // 必须用 const 接收（C++17 前）
char* c_str2 = s.data();        // C++17 后可返回非 const 指针（修改 c_str2 会影响 s）

// char* → string
char c_arr[] = "World";
string s2 = c_arr;  // 直接转换，s2 = "World"
```

### 五、注意事项（避坑指南）

1. **`string::npos` 的类型**：`npos` 是 `size_t` 类型（无符号整数），与 `int` 比较可能出错（如 `int pos = s.find("a"); if (pos == string::npos)` 会因类型不匹配导致逻辑错误，应使用 `size_t pos`）。

2. **空字符串的处理**：`string s;` 是合法空字符串，`s.size()` 为 0，可直接拼接或赋值，无需初始化 `\0`。

3. **内存管理**：`string` 自动管理内存，无需手动 `malloc`/`free`，但频繁修改（如大量 `+=`）可能触发扩容（性能损耗），可提前用 `reserve(n)` 预分配容量（避免频繁扩容）：

   cpp

   

   

   

   ```cpp
   string s;
   s.reserve(1000);  // 预分配可容纳 1000 个字符的内存，后续拼接更高效
   ```

   

4. **迭代器失效**：当 `string` 的容量发生变化（如 `push_back`、`insert` 导致扩容）时，之前的迭代器（`begin()`、`end()` 等）会失效，访问失效迭代器会导致未定义行为。

### 六、常用场景示例

#### 场景 1：读取整行字符串（含空格）

`cin` 默认以空格 / 换行分割，读取整行需用 `getline()`：

```cpp
string line;
getline(cin, line);  // 读取整行（包括空格），直到换行符（换行符不存入字符串）
cout << line << endl;
```

#### 场景 2：分割字符串（按指定字符）

利用 `find()` 和 `substr()` 实现简单分割（如按逗号分割）：

```cpp
string s = "apple,banana,orange";
vector<string> parts;
size_t start = 0;
size_t pos = s.find(',');

while (pos != string::npos) {
    parts.push_back(s.substr(start, pos - start));  // 截取 [start, pos)
    start = pos + 1;  // 更新起始位置
    pos = s.find(',', start);  // 从新起始位置继续查找
}
parts.push_back(s.substr(start));  // 添加最后一部分

// 输出分割结果：apple banana orange
for (auto& part : parts) {
    cout << part << " ";
}
```

综上，`std::string` 是 C++ 处理字符串的首选工具，其成员函数覆盖了绝大多数字符串操作场景，结合 STL 算法（如 `sort`、`reverse`）可进一步扩展功能，建议优先使用而非手动管理 `char[]`。





要理解**前缀和**，我们可以从「定义本质→核心作用→实现方式→典型应用→注意事项」五个维度展开，结合具体案例让抽象概念落地，同时关联你之前遇到的「最大子数组和」问题，帮你建立完整认知。

## 一、前缀和的本质：什么是前缀和？

前缀和（Prefix Sum）是一种**预处理数组的技术**，核心思想是「提前计算数组中从起始位置到每个索引的累加和」，从而将后续的区间和查询从「O (n) 时间」优化为「O (1) 时间」。

### 1. 数学定义

对于一个长度为 `n` 的数组 `nums`（索引从 `0` 开始），其**前缀和数组** `prefix`（通常长度为 `n+1`，索引从 `0` 开始）的定义为：

- `prefix[0] = 0`（边界值，代表 “前 0 个元素的和”，方便计算）
- `prefix[1] = nums[0]`（前 1 个元素的和，即 `nums[0]`）
- `prefix[2] = nums[0] + nums[1]`（前 2 个元素的和）
- ...
- `prefix[k] = nums[0] + nums[1] + ... + nums[k-1]`（前 `k` 个元素的和，对应原数组 `nums[0..k-1]` 的累加）

### 2. 直观案例

以数组 `nums = [1, 2, 3, 4]` 为例，其前缀和数组 `prefix` 的计算过程如下：

| 原数组索引 | nums[0]   | nums[1]   | nums[2]   | nums[3]    |               |
| ---------- | --------- | --------- | --------- | ---------- | ------------- |
| 原数组值   | 1         | 2         | 3         | 4          |               |
| 前缀和索引 | prefix[0] | prefix[1] | prefix[2] | prefix[3]  | prefix[4]     |
| 前缀和值   | 0         | 1（1）    | 3（1+2）  | 6（1+2+3） | 10（1+2+3+4） |

## 二、前缀和的核心作用：为什么要用前缀和？

前缀和的核心价值是**降维优化**—— 将 “多次区间和查询” 的时间复杂度从 O (n) 降到 O (1)，避免重复计算。

### 1. 快速计算任意区间和

这是前缀和最基础的应用。对于原数组 `nums` 中**从索引 `i` 到 `j` 的区间和**（即 `nums[i] + nums[i+1] + ... + nums[j]`，闭区间），利用前缀和数组可直接推导：

plaintext











```plaintext
区间和 = prefix[j+1] - prefix[i]
```

#### 案例验证

以上面的 `nums = [1,2,3,4]` 为例，计算 `nums[1] 到 nums[3]` 的和（即 `2+3+4=9`）：

- 按公式：`prefix[3+1] - prefix[1] = prefix[4] - prefix[1] = 10 - 1 = 9`，与直接计算结果一致。

#### 对比：直接计算 vs 前缀和计算

| 计算方式     | 单次区间和时间            | 多次查询（如 100 次）时间 | 适用场景             |
| ------------ | ------------------------- | ------------------------- | -------------------- |
| 直接遍历区间 | O(j-i+1)                  | O(100*(j-i+1))            | 单次查询、小规模数组 |
| 前缀和预处理 | 预处理 O (n) + 查询 O (1) | O(n + 100*1)              | 多次查询、大规模数组 |

## 三、前缀和的实现方式

前缀和的实现非常简洁，分为「构建前缀和数组」和「使用前缀和查询区间和」两步，以下用 C++ 代码示例说明。

### 1. 基础实现（数组版）

cpp



运行









```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4};
    int n = nums.size();
    
    // 1. 构建前缀和数组（长度 n+1，prefix[0] = 0）
    vector<int> prefix(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        prefix[i] = prefix[i - 1] + nums[i - 1];  // 核心递推公式
    }
    
    // 2. 查询任意区间和：nums[i..j]（i、j为原数组索引，0<=i<=j<n）
    int i = 1, j = 3;  // 对应 nums[1]到nums[3]：2+3+4
    int range_sum = prefix[j + 1] - prefix[i];
    cout << "区间和：" << range_sum << endl;  // 输出 9
    
    return 0;
}
```

### 2. 优化实现（变量版，空间 O (1)）

如果不需要保存完整的前缀和数组，仅需 “实时计算前缀和”（如你之前的最大子数组和问题），可以用单个变量替代数组，将空间复杂度从 O (n) 优化为 O (1)：

cpp



运行









```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> nums = {1, 2, 3, 4};
    int current_prefix = 0;  // 实时记录当前前缀和（替代数组）
    
    for (int num : nums) {
        current_prefix += num;  // 每遍历一个元素，更新前缀和
        cout << "当前前缀和（前" << &num - &nums[0] + 1 << "个元素）：" << current_prefix << endl;
    }
    // 输出：1（前1个）、3（前2个）、6（前3个）、10（前4个）
    return 0;
}
```

## 四、前缀和的典型应用场景

前缀和不仅能计算区间和，还能结合其他逻辑解决更复杂的问题，以下是 3 个高频场景：

### 1. 场景 1：最大子数组和（你之前的问题）

核心思路：**子数组和 = 当前前缀和 - 之前的最小前缀和**。通过维护 “最小前缀和”，实时计算每个位置的最大子数组和。

- 案例：

  ```
  nums = [-2, 1, -3, 4]
  ```

  - 前缀和序列：`0, -2, -1, -4, 0`
  - 最小前缀和变化：`0 → 0（min(0,-2)）→ 0（min(0,-1)）→ -4（min(0,-4)）→ -4（min(-4,0)）`
  - 最大子数组和：`max(-2-0, -1-0, -4-0, 0-(-4)) = max(-2,-1,-4,4) = 4`（对应子数组 `[4]`）

### 2. 场景 2：统计 “和为 k 的子数组个数”

问题描述：给定数组 `nums` 和整数 `k`，求有多少个连续子数组的和等于 `k`。

- 核心逻辑：若 `prefix[j+1] - prefix[i] = k`，则子数组 `nums[i..j]` 的和为 `k`。因此，只需统计每个 `prefix[j+1]` 对应的 `prefix[i] = prefix[j+1] - k` 出现的次数。

- 案例：

  ```
  nums = [1,1,1]，k=2
  ```

  - 前缀和序列：`0,1,2,3`

  - 遍历前缀和时，统计

     

    ```
    prefix[j+1]-k
    ```

     

    出现的次数：

    - `j=0`：`prefix[1]-2 = -1`（次数 0）
    - `j=1`：`prefix[2]-2 = 0`（次数 1，对应子数组 `[0..1]`）
    - `j=2`：`prefix[3]-2 = 1`（次数 1，对应子数组 `[1..2]`）

  - 总个数：2。

### 3. 场景 3：二维前缀和（矩阵区间和）

将前缀和扩展到二维数组（矩阵），可快速计算任意子矩阵的和。

- 定义：对于矩阵 `matrix`，二维前缀和 `prefix[i][j]` 表示 “以 `matrix[0][0]` 为左上角、`matrix[i-1][j-1]` 为右下角的子矩阵和”。
- 公式：
  1. 构建二维前缀和：`prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]`（避免重复加重叠区域）
  2. 查询子矩阵和（左上角 `(x1,y1)`，右下角 `(x2,y2)`）：`prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]`

## 五、使用前缀和的注意事项

1. **前缀和数组的长度选择**：

   必须定义为 `n+1`（而非 `n`），且 `prefix[0] = 0`—— 这是为了避免处理 `i=0` 时的边界问题（如计算 `nums[0..j]` 的和时，直接用 `prefix[j+1] - prefix[0]`，无需额外判断）。

2. **负数和溢出问题**：

   - 若原数组包含负数，前缀和可能会出现递减（如 `nums = [-2,1]`，前缀和为 `0,-2,-1`），此时需注意 “最小前缀和” 的维护（如最大子数组和问题）。
   - 若数组元素较大或长度较长，前缀和可能超出 `int` 范围（如 `nums` 有 `1e5` 个 `1e5`，总和为 `1e10`），需用 `long long` 类型存储前缀和（C++）或 `long` 类型（Java）。

3. **适用场景的局限性**：

   前缀和仅适用于「静态数组」（即数组元素不修改）。若数组元素频繁修改（如插入、删除、更新），前缀和的预处理会失效，此时需用「线段树」或「树状数组」等数据结构。

## 总结

前缀和是一种 “以空间换时间” 的经典预处理技术，核心价值是**将区间和查询从 O (n) 优化到 O (1)**。它的实现简单，但能解决大量数组区间相关的问题（如最大子数组和、和为 k 的子数组、矩阵区间和等），是算法入门阶段必须掌握的基础工具。

理解前缀和的关键是记住两个公式：

1. 前缀和递推公式：`prefix[i] = prefix[i-1] + nums[i-1]`
2. 区间和计算公式：`nums[i..j] 的和 = prefix[j+1] - prefix[i]`



# 矩阵

在数据结构与线性代数中，矩阵的 “交换” 本质是通过调整元素位置满足特定算法需求（如高斯消元、快速排序、稀疏矩阵优化等），核心围绕**行交换**、**列交换**及特殊结构（上 / 下三角、对称矩阵）的交换逻辑展开。以下结合数据结构中的常用场景，系统介绍矩阵的交换方法、原理及应用。

### 一、基础交换：行交换与列交换

行交换和列交换是矩阵最核心的交换操作，本质是调整矩阵的 “行序” 或 “列序”，操作时需保证矩阵维度（行数 / 列数）不变，且交换后元素的 “行内关系” 或 “列内关系” 保留（仅位置变动）。

#### 1. 行交换（Row Swap）

**定义**：交换矩阵中任意两行的所有元素，记为 `swap(row_i, row_j)`（`i ≠ j`）。

**操作逻辑**：遍历两行的每一列，交换对应列的元素（时间复杂度 `O(n)`，`n` 为矩阵列数）。

**数据结构实现**（以二维数组存储矩阵为例）：

python







```python
def swap_rows(matrix, i, j):
    # 交换第i行和第j行（索引从0开始）
    matrix[i], matrix[j] = matrix[i].copy(), matrix[j].copy()  # 避免浅拷贝问题
```

**常用场景**：

- **高斯消元法**：找到当前列（主元列）中 “非零主元” 所在行，与当前行交换，避免除数为 0（如将 `[[0,2],[1,3]]` 交换第 1、2 行得到 `[[1,3],[0,2]]`，便于后续消元）。
- **快速排序（矩阵行排序）**：以某一列元素为 “基准值”，交换行位置实现按列排序（如按第一列升序排列矩阵，交换行使基准值左侧行的第一列元素更小）。
- **稀疏矩阵优化**：交换全零行到矩阵末尾，减少无效计算（如压缩存储时忽略全零行）。

#### 2. 列交换（Column Swap）

**定义**：交换矩阵中任意两列的所有元素，记为 `swap(col_i, col_j)`（`i ≠ j`）。

**操作逻辑**：遍历矩阵的每一行，交换对应行中第 `i` 列和第 `j` 列的元素（时间复杂度 `O(m)`，`m` 为矩阵行数）。

**数据结构实现**：

python







```python
def swap_cols(matrix, i, j):
    # 交换第i列和第j列（索引从0开始）
    for row in matrix:
        row[i], row[j] = row[j], row[i]
```

**常用场景**：

- **矩阵转置预处理**：部分特殊矩阵（如稀疏矩阵的列优先存储）可通过列交换调整为行优先存储，简化转置操作。
- **特征工程（数据矩阵）**：交换特征列的顺序（如机器学习中调整输入特征的优先级，不改变特征本身的含义）。
- **对称矩阵修复**：若对称矩阵因误差导致 `A[i][j] ≠ A[j][i]`，可通过列交换与行交换同步，恢复对称结构。

### 二、特殊结构交换：上三角 / 下三角矩阵的交换

上三角矩阵（对角线以下元素全为 0）和下三角矩阵（对角线以上元素全为 0）的交换需**保留三角结构**，因此交换规则更严格，核心是 “仅交换对角线上 / 下的对应元素”，避免破坏全零区域。

#### 1. 上三角矩阵的交换

上三角矩阵的非零元素仅存在于 `i ≤ j`（行号 ≤ 列号）的位置，交换需满足：

- 交换**行**时：仅能交换 “非零区域无重叠” 的行（或交换后仍保持上三角结构）。例如，交换上三角矩阵的第 1 行和第 2 行，需确保交换后第 2 行的 `i > j` 位置仍为 0（实际中更常用 “对角线上元素的交换”）。
- 交换**元素**时：仅交换对角线上或对角线以上的对称位置元素（如 `A[i][j]` 和 `A[j][i]`，但因上三角矩阵中 `i > j` 时 `A[i][j] = 0`，故仅需交换 `i ≤ j` 的元素）。

**示例**：上三角矩阵交换 `(1,2)` 和 `(2,1)` 元素（但 `(2,1)` 为 0，实际无意义）；合理交换是 `(1,3)` 和 `(1,2)`（同属第 1 行的上三角区域）。

**应用场景**：上三角矩阵的 LU 分解（LU decomposition）中，交换主元列对应的上三角元素，确保分解过程中主元非零。

#### 2. 下三角矩阵的交换

下三角矩阵的非零元素仅存在于 `i ≥ j`（行号 ≥ 列号）的位置，交换规则与上三角矩阵对称：

- 交换**列**时：仅能交换 “非零区域无重叠” 的列，避免破坏下三角结构。
- 交换**元素**时：仅交换对角线上或对角线以下的对称位置元素（如 `A[i][j]` 和 `A[j][i]`，但 `i < j` 时 `A[i][j] = 0`，故仅需交换 `i ≥ j` 的元素）。

**示例**：下三角矩阵 `[[1,0,0],[2,3,0],[4,5,6]]` 中，可交换 `(2,1)`（元素 2）和 `(3,1)`（元素 4）（同属第 1 列的下三角区域），交换后仍为下三角矩阵。

**应用场景**：下三角矩阵的 Cholesky 分解（对称正定矩阵的分解）中，交换对角线下元素以优化计算效率。

### 三、扩展交换：块矩阵交换与稀疏矩阵交换

在数据结构中，矩阵常以 “块” 或 “稀疏” 形式存储（减少空间占用），其交换方法需结合存储结构优化。

#### 1. 块矩阵交换（Block Matrix Swap）

块矩阵将原矩阵划分为多个小矩阵（块），交换时直接交换 “块” 而非单个元素，时间复杂度大幅降低（从 `O(mn)` 降至 `O(1)`，仅需调整块的指针）。

**示例**：将 `4×4` 矩阵划分为 4 个 `2×2` 块 `B11, B12, B21, B22`，交换 `B11` 和 `B22` 块，等价于交换原矩阵的 `(1-2行,1-2列)` 与 `(3-4行,3-4列)` 区域。

**应用场景**：大型矩阵的并行计算（如分布式矩阵运算），通过块交换减少数据传输量。

#### 2. 稀疏矩阵交换（Sparse Matrix Swap）

稀疏矩阵（大部分元素为 0）通常用**三元组表**（`(行号, 列号, 元素值)`）或**邻接表**存储，交换时无需处理全零元素，仅需调整非零元素的 “行号” 或 “列号”：

- **行交换**：遍历三元组表，将所有行号为 `i` 的元素改为 `j`，行号为 `j` 的元素改为 `i`。
- **列交换**：同理，修改非零元素的列号。

**示例**：稀疏矩阵三元组 `[(0,1,2), (2,3,4)]` 交换第 0 行和第 2 行后，变为 `[(2,1,2), (0,3,4)]`。

**应用场景**：稀疏矩阵的高斯消元（如有限元分析中的大型线性方程组），避免无效的全零元素交换。

### 四、交换的核心性质与注意事项

1. **可逆性**：交换操作是可逆的 —— 交换两次相同的行 / 列，矩阵恢复原状（`swap(row_i, row_j)` 执行两次后，矩阵不变）。
2. **行列式影响**：行 / 列交换会改变矩阵行列式的符号（交换一次，行列式变号；交换奇数次，符号相反；交换偶数次，符号相同），这是线性代数中判断矩阵可逆性的重要依据。
3. **结构保留**：对特殊矩阵（上三角、下三角、对称、稀疏），交换需优先保证 “结构不被破坏”，否则会导致后续算法（如分解、排序）失效。

### 总结：不同场景下的交换方法选择

| 交换类型        | 核心逻辑                  | 时间复杂度              | 适用场景                     |
| --------------- | ------------------------- | ----------------------- | ---------------------------- |
| 基础行交换      | 交换整行元素              | O(n)                    | 高斯消元、行排序             |
| 基础列交换      | 交换整列元素              | O(m)                    | 特征工程、列优先存储调整     |
| 上 / 下三角交换 | 仅交换非零区域元素        | O (k)（k 为非零元素数） | 三角矩阵分解（LU、Cholesky） |
| 块矩阵交换      | 交换整块小矩阵            | O(1)                    | 大型矩阵并行计算             |
| 稀疏矩阵交换    | 仅修改非零元素的行 / 列号 | O (t)（t 为非零元素数） | 稀疏矩阵消元、压缩存储       |

通过选择合适的交换方法，可在保证算法正确性的前提下，大幅优化矩阵操作的时间与空间效率，这也是数据结构中矩阵处理的核心优化思路。





# 二叉树的遍历

二叉树的遍历是按特定规则访问所有节点（每个节点仅访问一次）的过程，核心分为**深度优先遍历（DFS）** 和**广度优先遍历（BFS）** 两大类。其中 DFS 根据根节点（Root）、左子树（Left）、右子树（Right）的访问顺序，细分为前序、中序、后序 3 种；BFS 最典型的实现是**层序遍历**。

以下将结合 C++ 代码（包含递归与非递归实现），详细讲解每种遍历方法的逻辑、步骤及应用场景。首先定义统一的二叉树节点结构：

cpp







```cpp
// 二叉树节点结构定义
struct TreeNode {
    int val;                // 节点值
    TreeNode* left;         // 左子节点指针
    TreeNode* right;        // 右子节点指针
    // 构造函数（简化节点初始化）
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

为便于理解，后续所有示例基于如下二叉树结构展开：

plaintext







```plaintext
        1（根）
       /   \
      2     3
     / \   / \
    4   5 6   7
```

## 一、深度优先遍历（DFS）

DFS 的核心是 “先深后广”：优先沿一条路径访问到树的最深处（叶子节点），再回溯访问其他分支。实现方式分为**递归**（利用系统栈，代码简洁）和**非递归**（手动用栈模拟，避免递归栈溢出风险）。

### 1. 前序遍历（Pre-order：根 → 左 → 右）

**定义**：先访问当前根节点，再递归 / 迭代遍历左子树，最后遍历右子树。

**核心特征**：根节点的访问时机最早，是唯一能 “先拿到根” 的遍历方式。

#### 1.1 递归实现（最简洁）

cpp







```cpp
#include <iostream>
using namespace std;

// 前序遍历（递归版）
void preOrderRecursive(TreeNode* root) {
    // 终止条件：当前节点为空（子树遍历结束）
    if (root == nullptr) {
        return;
    }
    // 1. 访问当前根节点（输出值）
    cout << root->val << " ";
    // 2. 递归遍历左子树
    preOrderRecursive(root->left);
    // 3. 递归遍历右子树
    preOrderRecursive(root->right);
}
```

- **遍历结果**：`1 2 4 5 3 6 7`
- **逻辑拆解**：从根节点 1 开始，先输出 1；再深入左子树 2，输出 2 后继续深入左子树 4（输出 4，无后代）；回溯到 2 的右子树 5（输出 5）；左子树遍历完，回溯到根 1 的右子树 3，重复上述逻辑。

#### 1.2 非递归实现（栈模拟）

递归的本质是 “系统栈” 保存节点状态，非递归需手动用`stack<TreeNode*>`模拟，核心是 **“根节点先入栈，弹出时访问，再压右子树、后压左子树”**（栈是 “先进后出”，保证左子树先被处理）。

cpp







```cpp
#include <stack>
#include <iostream>
using namespace std;

// 前序遍历（非递归版）
void preOrderIterative(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    stack<TreeNode*> st;  // 手动创建栈，存储节点指针
    st.push(root);        // 根节点先入栈

    while (!st.empty()) {
        // 1. 弹出栈顶节点，访问（对应“根”的步骤）
        TreeNode* curr = st.top();
        st.pop();
        cout << curr->val << " ";

        // 2. 右子树先入栈（栈先进后出，保证左子树先处理）
        if (curr->right != nullptr) {
            st.push(curr->right);
        }
        // 3. 左子树后入栈
        if (curr->left != nullptr) {
            st.push(curr->left);
        }
    }
}
```

- **关键细节**：必须先压右子树、后压左子树，否则弹出时会先处理右子树，违背 “左→右” 的顺序。

#### 1.3 应用场景

- 复制二叉树（先复制根，再复制左右子树）；
- 生成树的前缀表达式（如波兰式，运算符在操作数前）；
- 快速获取树的 “根 - 左 - 右” 结构信息。

### 2. 中序遍历（In-order：左 → 根 → 右）

**定义**：先遍历左子树，再访问当前根节点，最后遍历右子树。

**核心特征**：对**二叉搜索树（BST）** 而言，中序遍历结果是**严格递增的有序序列**（BST 的核心性质，常用于验证 BST 合法性）。

#### 2.1 递归实现

cpp







```cpp
#include <iostream>
using namespace std;

// 中序遍历（递归版）
void inOrderRecursive(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 1. 先递归遍历左子树（深入到最左叶子）
    inOrderRecursive(root->left);
    // 2. 访问当前根节点（左子树遍历完后）
    cout << root->val << " ";
    // 3. 递归遍历右子树
    inOrderRecursive(root->right);
}
```

- **遍历结果**：`4 2 5 1 6 3 7`
- **逻辑拆解**：从根 1 开始，先深入左子树 2，再深入 2 的左子树 4（无左后代，输出 4）；回溯到 2（输出 2），遍历 2 的右子树 5（输出 5）；左子树遍历完，输出根 1；再遍历右子树 3，重复左→根→右逻辑。

#### 2.2 非递归实现（栈模拟）

核心逻辑：**先将左子树所有节点依次入栈（直到最左叶子），弹出时访问根节点，再处理右子树**。

cpp







```cpp
#include <stack>
#include <iostream>
using namespace std;

// 中序遍历（非递归版）
void inOrderIterative(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    stack<TreeNode*> st;
    TreeNode* curr = root;  // 当前节点指针，用于遍历左子树

    while (curr != nullptr || !st.empty()) {
        // 1. 遍历到左子树最深处，所有节点依次入栈
        while (curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }
        // 2. 弹出栈顶节点（左子树已处理完），访问根节点
        curr = st.top();
        st.pop();
        cout << curr->val << " ";
        // 3. 处理右子树（右子树重复“左→根→右”逻辑）
        curr = curr->right;
    }
}
```

- **关键细节**：用`curr`指针跟踪左子树遍历进度，避免重复入栈；弹出节点后，`curr`转向右子树，继续循环。

#### 2.3 应用场景

- 验证二叉搜索树（检查中序结果是否严格递增）；
- 从 BST 中获取有序数据（如升序排列的节点值）；
- 中序遍历与前序 / 后序遍历结合，可唯一重建二叉树。

### 3. 后序遍历（Post-order：左 → 右 → 根）

**定义**：先遍历左子树，再遍历右子树，最后访问当前根节点。

**核心特征**：根节点的访问时机最晚，需确保左右子树完全处理后才访问根（适合 “先处理子节点，再处理父节点” 的场景）。

#### 3.1 递归实现

cpp







```cpp
#include <iostream>
using namespace std;

// 后序遍历（递归版）
void postOrderRecursive(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 1. 递归遍历左子树
    postOrderRecursive(root->left);
    // 2. 递归遍历右子树
    postOrderRecursive(root->right);
    // 3. 最后访问当前根节点
    cout << root->val << " ";
}
```

- **遍历结果**：`4 5 2 6 7 3 1`
- **逻辑拆解**：从根 1 开始，先深入左子树 2，再深入 2 的左子树 4（无后代，输出 4）；回溯到 2 的右子树 5（输出 5）；左子树 2 的左右都处理完，输出 2；再处理根 1 的右子树 3，重复左→右→根逻辑，最后输出 1。

#### 3.2 非递归实现（栈模拟，两种思路）

后序遍历的非递归实现最复杂（需判断右子树是否已处理），常见两种思路：**双栈法**（简洁）和**标记法**（直观）。

##### 思路 1：双栈法（推荐，代码简洁）

核心逻辑：

1. 栈 1 用于按 “根→右→左” 顺序入栈（类似前序遍历的逆序）；
2. 栈 2 存储栈 1 弹出的节点，最终栈 2 的弹出顺序即为 “左→右→根”（后序）。

cpp







```cpp
#include <stack>
#include <iostream>
using namespace std;

// 后序遍历（非递归，双栈法）
void postOrderIterative1(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    stack<TreeNode*> st1, st2;
    st1.push(root);

    // 栈1按“根→右→左”弹出，存入栈2
    while (!st1.empty()) {
        TreeNode* curr = st1.top();
        st1.pop();
        st2.push(curr);  // 栈2保存弹出的节点

        // 栈1先压左子树，后压右子树（保证弹出时先右后左）
        if (curr->left != nullptr) {
            st1.push(curr->left);
        }
        if (curr->right != nullptr) {
            st1.push(curr->right);
        }
    }

    // 栈2弹出顺序即为后序遍历
    while (!st2.empty()) {
        cout << st2.top()->val << " ";
        st2.pop();
    }
}
```

##### 思路 2：标记法（直观，单栈）

核心逻辑：用`pair<TreeNode*, bool>`标记节点状态（`false`= 未处理，`true`= 已处理右子树）。首次入栈时标记`false`，弹出后若未处理，则标记`true`重新入栈，再将右子树和左子树入栈（保证左→右先处理）；若已处理，则直接访问节点。

cpp







```cpp
#include <stack>
#include <iostream>
#include <utility>  // 用于pair
using namespace std;

// 后序遍历（非递归，标记法）
void postOrderIterative2(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 栈存储：<节点指针，是否已处理右子树>
    stack<pair<TreeNode*, bool>> st;
    st.push({root, false});

    while (!st.empty()) {
        auto [curr, isProcessed] = st.top();  // C++17结构化绑定（简化代码）
        st.pop();

        if (!isProcessed) {
            // 1. 未处理：标记为已处理，重新入栈
            st.push({curr, true});
            // 2. 压入右子树（未处理）
            if (curr->right != nullptr) {
                st.push({curr->right, false});
            }
            // 3. 压入左子树（未处理）
            if (curr->left != nullptr) {
                st.push({curr->left, false});
            }
        } else {
            // 已处理右子树：访问当前节点
            cout << curr->val << " ";
        }
    }
}
```

- 兼容性说明

  ：若编译器不支持 C++17 结构化绑定，可替换为：

  cpp

  

  

  

  ```cpp
  TreeNode* curr = st.top().first;
  bool isProcessed = st.top().second;
  st.pop();
  ```

  

#### 3.3 应用场景

- 删除二叉树（需先删除左右子节点，再删除根节点，避免内存泄漏）；
- 计算树的高度（需先获取左右子树高度，再取最大值 + 1）；
- 生成树的后缀表达式（如逆波兰式，运算符在操作数后）。

## 二、广度优先遍历（BFS）—— 层序遍历

BFS 的核心是 “先广后深”：按树的**层级顺序**（从根到叶，同一层从左到右）访问节点，类似 “逐层扫描”。实现依赖**队列（queue）** 的 “先进先出” 特性（保证上层节点先处理）。

### 层序遍历（Level-order）

**定义**：从根节点（第 1 层）开始，依次访问第 1 层、第 2 层…… 第 k 层的所有节点，同一层内按左到右顺序访问。

#### 实现代码（队列模拟）

cpp







```cpp
#include <queue>
#include <iostream>
using namespace std;

// 层序遍历（基础版：仅输出节点值）
void levelOrderBasic(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;  // 队列存储节点指针
    q.push(root);        // 根节点先入队

    while (!q.empty()) {
        // 1. 取出队首节点，访问
        TreeNode* curr = q.front();
        q.pop();
        cout << curr->val << " ";

        // 2. 左子节点入队（先左后右，保证同一层顺序）
        if (curr->left != nullptr) {
            q.push(curr->left);
        }
        // 3. 右子节点入队
        if (curr->right != nullptr) {
            q.push(curr->right);
        }
    }
}

// 进阶版：按层输出（区分每一层，更直观）
void levelOrderWithLevel(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();  // 当前层的节点数（关键：固定当前层规模）
        cout << "第" << (q.size() ? (q.size() == 1 ? 1 : (levelSize)) : 0) << "层：";
        // 遍历当前层的所有节点
        for (int i = 0; i < levelSize; ++i) {
            TreeNode* curr = q.front();
            q.pop();
            cout << curr->val << " ";

            // 下一层节点入队
            if (curr->left != nullptr) {
                q.push(curr->left);
            }
            if (curr->right != nullptr) {
                q.push(curr->right);
            }
        }
        cout << endl;  // 每一层结束换行
    }
}
```

- **基础版遍历结果**：`1 2 3 4 5 6 7`

- 进阶版输出

  ：

  plaintext

  

  

  

  ```plaintext
  第1层：1 
  第2层：2 3 
  第3层：4 5 6 7 
  ```

  

- **关键细节**：`levelSize = q.size()` 用于固定当前层的节点数，避免下一层节点入队后干扰当前层遍历。

#### 应用场景

- 求树的最小深度（首次遇到叶子节点的层级即为最小深度）；
- 层序打印二叉树（如按 “第 1 层、第 2 层” 格式输出）；
- 二叉树的广度优先搜索（如寻找某一值的节点，优先访问上层节点）。

## 三、遍历方法对比与总结

| 遍历类型 | 访问顺序        | 实现方式       | 核心数据结构      | 关键应用场景                     | 示例结果      |
| -------- | --------------- | -------------- | ----------------- | -------------------------------- | ------------- |
| 前序遍历 | 根→左→右        | 递归 / 非递归  | 栈                | 复制二叉树、前缀表达式           | 1 2 4 5 3 6 7 |
| 中序遍历 | 左→根→右        | 递归 / 非递归  | 栈                | 验证 BST、获取有序数据           | 4 2 5 1 6 3 7 |
| 后序遍历 | 左→右→根        | 递归 / 非递归  | 栈（双栈 / 标记） | 删除二叉树、计算树高、后缀表达式 | 4 5 2 6 7 3 1 |
| 层序遍历 | 按层级（左→右） | 非递归（推荐） | 队列              | 求最小深度、层序打印             | 1 2 3 4 5 6 7 |



# 递归

要理解**递归（Recursion）**，首先可以用一句通俗的话概括：**“函数自己调用自己，同时逐步缩小问题规模，直到遇到‘停止信号’（基线条件）后回溯求解”**。它是计算机科学中解决复杂问题的核心思想之一，本质是将 “大问题” 拆解为结构相同的 “小问题”，最终通过小问题的解组合出大问题的解。

### 一、递归的核心要素：两个必须满足的条件

递归并非 “无限套娃”，必须同时满足以下两个条件，否则会导致**无限递归（栈溢出错误）**：

#### 1. 基线条件（Base Case）：递归的 “停止信号”

这是递归的终止条件，当问题规模缩小到某个阈值时，不再调用自身，直接返回明确的结果。

例如：计算 `n!`（n 的阶乘）时，基线条件是 `n=0` 或 `n=1`，此时 `0! = 1`、`1! = 1`（无需再拆解）。

#### 2. 递归条件（Recursive Case）：问题的 “拆解逻辑”

将当前问题拆解为**规模更小、结构相同**的子问题，通过调用自身求解子问题，再用子问题的结果构建当前问题的解。

例如：计算 `n!` 时，递归条件是 `n! = n * (n-1)!`（将 “求 n 的阶乘” 拆解为 “求 n-1 的阶乘”，再乘以 n）。

### 二、递归的工作原理：“调用栈” 与 “回溯”

计算机通过**调用栈（Call Stack）** 管理递归函数的执行过程，分为两个阶段：

#### 1. 递推阶段（Recursive Phase）：“层层拆解，压栈记录”

函数每次调用自身时，会将当前的 “上下文信息”（如参数、局部变量、返回地址）压入调用栈，然后进入子问题的求解。

以 `n=3` 计算 `3!` 为例，递推阶段的调用栈变化：

- 调用 `fact(3)`，压栈记录（参数 3、返回地址：需计算 `3 * fact(2)`）；
- 调用 `fact(2)`，压栈记录（参数 2、返回地址：需计算 `2 * fact(1)`）；
- 调用 `fact(1)`，触发基线条件（`1! = 1`），停止递推，开始回溯。

#### 2. 回溯阶段（Backtracking Phase）：“层层返回，出栈计算”

当遇到基线条件后，函数开始从调用栈的顶层（最后压入的子问题）逐步返回结果，同时弹出栈中记录，直到回到最初的调用。

延续 `3!` 的例子，回溯阶段的计算过程：

- `fact(1)` 返回 1，弹出栈；
- `fact(2)` 执行 `2 * 1 = 2`，返回 2，弹出栈；
- `fact(3)` 执行 `3 * 2 = 6`，返回 6，弹出栈；
- 最终得到 `3! = 6`。

### 三、经典案例：用递归解决实际问题

通过具体案例理解递归的应用，感受 “拆解问题” 的思路：

#### 案例 1：计算阶乘（Factorial）

阶乘的数学定义：`n! = n × (n-1) × (n-2) × ... × 1`，且 `0! = 1`。

**代码实现（Python）**：

python







```python
def factorial(n):
    # 基线条件：n=0或1时，直接返回1
    if n == 0 or n == 1:
        return 1
    # 递归条件：n! = n * (n-1)!
    else:
        return n * factorial(n - 1)

# 测试：计算3!
print(factorial(3))  # 输出：6
```

#### 案例 2：斐波那契数列（Fibonacci Sequence）

斐波那契数列的定义：第 1 项为 1，第 2 项为 1，从第 3 项起，每一项等于前两项之和（`F(n) = F(n-1) + F(n-2)`）。

**代码实现（Python）**：

python







```python
def fibonacci(n):
    # 基线条件：第1项和第2项均为1
    if n == 1 or n == 2:
        return 1
    # 递归条件：F(n) = F(n-1) + F(n-2)
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# 测试：计算第5项斐波那契数（1,1,2,3,5）
print(fibonacci(5))  # 输出：5
```

#### 案例 3：二叉树的前序遍历（Pre-order Traversal）

二叉树的每个节点都包含 “左子树” 和 “右子树”，前序遍历的规则是：**根节点 → 左子树 → 右子树**。由于左 / 右子树也是二叉树（结构相同），适合用递归实现。

**代码实现（Python）**：

python







```python
# 定义二叉树节点
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 递归实现前序遍历
def preorder_traversal(root):
    result = []
    # 基线条件：当前节点为空（无数据可遍历），返回空列表
    if not root:
        return result
    # 递归条件：根节点 → 左子树 → 右子树
    result.append(root.val)  # 访问根节点
    result += preorder_traversal(root.left)  # 遍历左子树
    result += preorder_traversal(root.right)  # 遍历右子树
    return result

# 测试：构建一棵简单二叉树（根1，左2，右3）
root = TreeNode(1, left=TreeNode(2), right=TreeNode(3))
print(preorder_traversal(root))  # 输出：[1, 2, 3]
```

### 四、递归的优缺点：何时该用，何时不该用？

#### 优点：

1. **代码简洁直观**：无需手动管理循环和状态，直接映射问题的数学定义（如阶乘、斐波那契）。
2. **适合处理 “嵌套结构”**：如树形结构（遍历、搜索）、嵌套列表（扁平化）、括号匹配等，问题天然具有 “自相似” 特性。
3. **降低思维复杂度**：只需关注 “当前问题如何拆解为子问题” 和 “基线条件”，无需陷入循环的细节。

#### 缺点：

1. **栈溢出风险**：递归依赖调用栈，若问题规模过大（如计算 `n=10000` 的阶乘），会导致调用栈深度超过系统限制，触发 `StackOverflowError`。
2. **重复计算问题**：部分递归（如朴素斐波那契）会反复计算相同的子问题（如 `fib(5)` 需计算 `fib(4)` 和 `fib(3)`，`fib(4)` 又需计算 `fib(3)`），时间复杂度高达 `O(2^n)`。
3. **空间开销较大**：调用栈会保存每次递归的上下文信息，空间复杂度为 `O(n)`（n 为递归深度），比迭代（`O(1)` 空间）更耗内存。

### 五、递归的优化技巧

针对上述缺点，可通过以下方式优化：

#### 1. 尾递归（Tail Recursion）：减少栈空间占用

尾递归是指**递归调用是函数的最后一步操作**，此时编译器 / 解释器可优化为 “复用当前栈帧”，避免栈深度增长（空间复杂度降至 `O(1)`）。

例如，用尾递归优化阶乘计算：

python







```python
def factorial_tail(n, accumulator=1):
    # 基线条件：返回累加器（已计算好的结果）
    if n == 0 or n == 1:
        return accumulator
    # 递归条件：最后一步仅调用自身，累加器记录中间结果
    return factorial_tail(n - 1, n * accumulator)

print(factorial_tail(3))  # 输出：6（栈帧仅1个）
```

⚠️ 注意：Python 解释器默认不支持尾递归优化，需借助第三方库或手动转换为迭代；Java、C++ 等语言的编译器可能支持。

#### 2. 记忆化（Memoization）：避免重复计算

将递归过程中已计算的子问题结果缓存起来，下次遇到相同子问题时直接返回缓存值，减少重复计算。

例如，用记忆化优化斐波那契数列（时间复杂度降至 `O(n)`）：

python







```python
# 方法1：用字典手动缓存
memo = {1: 1, 2: 1}  # 缓存已计算的子问题结果
def fibonacci_memo(n):
    if n in memo:
        return memo[n]
    # 计算后存入缓存
    memo[n] = fibonacci_memo(n - 1) + fibonacci_memo(n - 2)
    return memo[n]

# 方法2：用Python装饰器自动缓存
from functools import lru_cache
@lru_cache(maxsize=None)  # 自动缓存函数调用结果
def fibonacci_lru(n):
    if n == 1 or n == 2:
        return 1
    return fibonacci_lru(n - 1) + fibonacci_lru(n - 2)

print(fibonacci_memo(5))  # 输出：5
print(fibonacci_lru(5))   # 输出：5
```

#### 3. 递归转迭代：彻底避免栈溢出

对于不支持尾递归优化的语言（如 Python），可手动将递归逻辑改写为迭代（用循环 + 栈 / 队列模拟调用栈），完全控制内存占用。

例如，用迭代优化斐波那契数列：

python







```python
def fibonacci_iter(n):
    if n == 1 or n == 2:
        return 1
    a, b = 1, 1  # 初始化前两项
    for _ in range(3, n + 1):
        c = a + b  # 计算当前项
        a = b      # 更新前两项
        b = c
    return b

print(fibonacci_iter(5))  # 输出：5
```

### 六、递归与迭代的对比

递归和迭代是解决重复问题的两种核心方式，选择时需结合场景：

| 维度           | 递归（Recursion）                      | 迭代（Iteration）            |
| -------------- | -------------------------------------- | ---------------------------- |
| **代码复杂度** | 简洁，适合自相似问题                   | 较繁琐，需手动管理循环和状态 |
| **空间复杂度** | 通常 `O(n)`（调用栈），尾递归可 `O(1)` | 通常 `O(1)`（仅需局部变量）  |
| **时间效率**   | 可能有重复计算（需优化）               | 无重复计算，效率稳定         |
| **适用场景**   | 树形结构、嵌套问题、数学定义问题       | 线性问题（如遍历数组、阶乘） |
| **风险**       | 栈溢出、重复计算                       | 逻辑错误（如循环条件写错）   |

### 总结

递归的本质是 “**拆解问题 + 终止条件**”，它不是一种算法，而是一种 “思维模式”。掌握递归的关键在于：

1. 明确**基线条件**（避免无限递归）；
2. 设计**递归条件**（确保问题规模缩小且结构不变）；
3. 结合场景优化（尾递归、记忆化、转迭代），规避栈溢出和重复计算。

在实际开发中，递归常用于处理树形结构、深度优先搜索（DFS）、分治算法等场景，是理解动态规划、回溯法等高级算法的基础。



# 图论

在数据结构与算法中，**图论（Graph Theory）** 是研究 “图” 这种非线性数据结构的核心理论，它通过抽象化现实中的 “关联关系”（如社交网络中的好友关系、地图中的路线连接），提供了一套描述、分析和解决复杂关系问题的方法论。图论不仅是数据结构的重要分支，更是解决网络优化、路径规划、拓扑排序等实际问题的关键工具。

### 一、图的基本定义与核心概念

要理解图论，首先需要明确图的抽象模型和核心术语 —— 图本质是由 “顶点” 和 “边” 构成的集合，用于描述事物间的多对多关系（区别于树的 “父 - 子” 层级关系）。

#### 1. 图的形式化定义

从数学角度，图可定义为 **G = (V, E)**，其中：

- **V（Vertex）**：非空的顶点集合（也叫 “节点”，如社交网络中的用户、地图中的城市）；
- **E（Edge）**：边的集合，每条边是两个顶点的无序对（或有序对），表示顶点间的关联关系（如用户间的好友关系、城市间的公路）。

#### 2. 图的核心分类

根据 “边是否有方向”“边是否有权重”，图可分为以下几类，不同类型对应不同的应用场景：

| 分类维度   | 具体类型                   | 定义                                                         | 典型应用场景                                   |
| ---------- | -------------------------- | ------------------------------------------------------------ | ---------------------------------------------- |
| 边的方向性 | 无向图（Undirected Graph） | 边是无序对（如 (u, v) = (v, u)），表示双向关联（如 “好友关系”）。 | 社交网络、无向公路网                           |
|            | 有向图（Directed Graph）   | 边是有序对（如 <u, v> ≠ <v, u>），表示单向关联（如 “关注关系”“依赖关系”）。 | 任务依赖、网页跳转链接、水流方向               |
| 边的权重   | 无权图（Unweighted Graph） | 边仅表示 “是否关联”，无额外信息（边的权重默认为 1）。        | 统计两点间是否连通                             |
|            | 加权图（Weighted Graph）   | 边附带一个数值（权重，如距离、成本、时间），表示关联的 “强度” 或 “代价”。 | 路径规划（最短路径）、网络成本计算             |
| 特殊结构   | 完全图（Complete Graph）   | 任意两个顶点间都存在边（无向完全图有 n (n-1)/2 条边，n 为顶点数）。 | 全连接网络、社交网络的 “全好友” 场景           |
|            | 稀疏图 / 稠密图            | 边数远小于 n² 为稀疏图（如社交网络），接近 n² 为稠密图（如全连接网络）。 | 存储优化（稀疏图用邻接表，稠密图用邻接矩阵）   |
|            | 有环图 / 无环图            | 存在从某顶点出发回到自身的路径为 “有环图”；反之则为 “无环图”。 | 有环图：电路设计；无环图：任务调度             |
|            | 连通图 / 非连通图          | 无向图中任意两顶点都能到达为 “连通图”；反之则为 “非连通图”。 | 连通图：互联网拓扑；非连通图：多个独立社交圈子 |

#### 3. 图的关键术语

- **顶点的度（Degree）**：无向图中，顶点关联的边数（如 “好友数”）；有向图中分为 **入度（In-degree，指向该顶点的边数）** 和 **出度（Out-degree，从该顶点出发的边数）**（如 “被关注数” 和 “关注数”）。
- **路径（Path）**：从顶点 u 到 v 的边的序列（如 “从北京到上海的路线”），路径的 “长度” 可定义为边数（无权图）或边的权重和（加权图）。
- **环（Cycle）**：起点和终点相同的路径（如 “北京→天津→北京” 的路线）；无环的有向图称为 **DAG（Directed Acyclic Graph，有向无环图）**，是拓扑排序的核心场景。
- **子图（Subgraph）**：从原图中选取部分顶点和边构成的新图（如 “社交网络中的某个兴趣小组”）。
- **连通分量（Connected Component）**：无向图中最大的连通子图（如 “多个独立社交圈子中的每个圈子”）；有向图中类似概念是 **强连通分量（SCC）**—— 任意两顶点可双向到达的子图（如 “公司内部的管理层循环汇报关系”）。

### 二、图的存储结构

图的存储需要高效表达 “顶点” 和 “边” 的关联关系，常见的存储方式有 **邻接矩阵** 和 **邻接表**，两者各有优劣，需根据图的稀疏 / 稠密程度选择。

#### 1. 邻接矩阵（Adjacency Matrix）

用一个 **n×n 的二维数组** 存储图（n 为顶点数），其中 `matrix[i][j]` 表示顶点 i 和 j 的关联关系：

- 无向无权图：`matrix[i][j] = 1` 表示有边，`0` 表示无边（且 `matrix[i][j] = matrix[j][i]`）；
- 有向无权图：`matrix[i][j] = 1` 表示有从 i 到 j 的边，`0` 表示无；
- 加权图：`matrix[i][j] = 权重值`（无边时用 `∞` 或 `-1` 表示）。

**优缺点**：

- 优点：查询两顶点是否有边（`O(1)`）、计算顶点度（无向图直接求和行 / 列，`O(n)`）效率高；
- 缺点：空间复杂度 `O(n²)`（即使是稀疏图，也需存储所有 n² 个位置），添加 / 删除顶点需重构数组（效率低）。

**适用场景**：稠密图（如全连接网络）、顶点数较少的图。

#### 2. 邻接表（Adjacency List）

用一个 **数组（或哈希表）+ 链表（或动态数组）** 存储图：

- 数组下标（或哈希表的键）对应顶点编号；
- 每个数组元素对应一个链表（或动态数组），存储该顶点直接关联的所有顶点（及边的权重，加权图）。

例如，无向图中顶点 0 关联 1、2，则邻接表中 `adj[0] = [1, 2]`；有向图中顶点 0 指向 1、2，则 `adj[0] = [1, 2]`（反向边需单独存储）。

**优缺点**：

- 优点：空间复杂度 `O(n + m)`（m 为边数，稀疏图中 m 远小于 n²，空间更优），添加 / 删除边效率高（直接操作链表）；
- 缺点：查询两顶点是否有边需遍历链表（`O(k)`，k 为该顶点的度），效率低于邻接矩阵。

**适用场景**：稀疏图（如社交网络、互联网拓扑）、顶点数较多的图。

#### 3. 其他存储方式

- **邻接多重表**：优化无向图的邻接表，解决 “删除边需同时修改两个顶点的链表” 的问题（每条边仅存储一次，关联两个顶点的指针）；
- **十字链表**：优化有向图的邻接表，同时存储 “出边” 和 “入边”，便于计算入度和处理反向边。

### 三、图的核心算法（遍历与应用）

图论的核心价值在于通过算法解决 “关系问题”，如 “如何遍历所有节点”“如何找最短路径”“如何确定任务顺序” 等。以下是最基础且常用的算法：

#### 1. 图的遍历：深度优先（DFS）与广度优先（BFS）

遍历是指从某个顶点出发，访问图中所有可达顶点的过程，是后续所有图算法的基础。

##### （1）深度优先搜索（DFS，Depth-First Search）

- **核心思想**：“一条路走到黑”—— 从起点出发，优先访问当前顶点的未访问邻接顶点，直到无法前进时回溯，再探索其他路径。

- **实现方式**：递归（利用函数栈）或栈（手动维护访问栈）。

- 步骤示例

  （无向图 G = (V={0,1,2,3}, E={(0,1),(0,2),(1,3)})）：

  1. 起点 0 → 访问 0，标记为已访问；
  2. 选 0 的邻接顶点 1 → 访问 1，标记；
  3. 选 1 的邻接顶点 3 → 访问 3，标记；
  4. 3 无未访问邻接顶点，回溯到 1；1 无其他未访问邻接顶点，回溯到 0；
  5. 选 0 的邻接顶点 2 → 访问 2，标记；遍历结束。

- **应用场景**：检测图中的环、寻找连通分量、拓扑排序（基于 DFS 的逆后序）、迷宫求解。

##### （2）广度优先搜索（BFS，Breadth-First Search）

- **核心思想**：“逐层扩散”—— 从起点出发，先访问起点的所有未访问邻接顶点（第一层），再依次访问第一层顶点的未访问邻接顶点（第二层），直到遍历结束。

- **实现方式**：队列（手动维护访问队列，先进先出）。

- 步骤示例

  （同上无向图）：

  1. 起点 0 入队 → 出队访问 0，标记；将 0 的邻接顶点 1、2 入队；
  2. 1 出队访问 1，标记；将 1 的邻接顶点 3 入队；
  3. 2 出队访问 2，标记；2 无未访问邻接顶点；
  4. 3 出队访问 3，标记；3 无未访问邻接顶点；队列空，遍历结束。

- **关键特性**：BFS 是 **无权图中找 “最短路径”（边数最少）** 的唯一方法（因为逐层扩散确保首次到达顶点的路径是最短的）。

- **应用场景**：无权图最短路径、社交网络 “一度好友 / 二度好友” 统计、迷宫的最短出口。

#### 2. 最短路径算法（加权图核心）

当图为加权图时（边有成本 / 距离），需寻找 “权重和最小” 的路径，常用算法有 **Dijkstra 算法**、**Floyd-Warshall 算法** 和 **Bellman-Ford 算法**。

##### （1）Dijkstra 算法

- **适用场景**：**带非负权重的加权图**（无负边，如公路距离、时间），求 “单源最短路径”（从一个起点到所有其他顶点的最短路径）。

- **核心思想**：贪心策略 —— 维护一个 “已确定最短路径的顶点集”，每次从 “未确定集” 中选当前距离起点最近的顶点，更新其邻接顶点的距离（松弛操作），直到所有顶点都加入 “已确定集”。

- 步骤简化

  ：

  1. 初始化：起点距离为 0，其他顶点距离为 ∞；
  2. 用优先队列（最小堆）存储顶点及当前距离，每次取出距离最小的顶点 u；
  3. 对 u 的每个邻接顶点 v，若 “u 的距离 + u→v 的权重” < v 的当前距离，则更新 v 的距离（松弛）；
  4. 重复步骤 2-3，直到优先队列为空。

- **时间复杂度**：用优先队列优化后为 `O(m log n)`（m 为边数，n 为顶点数），适用于稀疏图。

##### （2）Floyd-Warshall 算法

- **适用场景**：**任意权重的图**（可含负边，但不能有负环），求 “所有顶点对之间的最短路径”（多源最短路径）。

- 核心思想

  ：动态规划 —— 定义

   

  ```
  dp[k][i][j]
  ```

   

  为 “经过前 k 个顶点（作为中间节点）时，i 到 j 的最短路径长度”，递推公式为：

  

  ```
  dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])
  ```

  

  （即 “不经过 k” 和 “经过 k” 两种情况取最小值）。

- **优化**：可压缩空间，用二维数组 `dp[i][j]` 直接更新（因为 `k` 层仅依赖 `k-1` 层）。

- **时间复杂度**：`O(n³)`（n 为顶点数），适用于顶点数较少的图（如 n < 1000）。

##### （3）Bellman-Ford 算法

- **适用场景**：**含负边的图**（可检测负环），求 “单源最短路径”（弥补 Dijkstra 算法无法处理负边的缺陷）。
- **核心思想**：松弛操作 —— 对所有边重复进行 n-1 次松弛（n 为顶点数），因为最短路径最多包含 n-1 条边（无环）；若第 n 次仍能松弛，则说明图中存在负环（负环会导致路径长度无限减小，无最短路径）。
- **时间复杂度**：`O(nm)`，效率低于 Dijkstra 算法，通常用于检测负环或处理含负边的小规模图。

#### 3. 拓扑排序（DAG 的核心应用）

- **适用场景**：**有向无环图（DAG）**，解决 “依赖关系的先后顺序” 问题（如任务调度、课程选修顺序 —— 必须先修 “高数” 才能修 “线代”）。

- **定义**：对 DAG 的顶点进行排序，使得对于每一条有向边 <u, v>，顶点 u 在排序结果中都位于 v 之前（即 “先完成依赖，再执行后续”）。

- 实现方法

  ：

  1. Kahn 算法（基于入度）

     ：

     - 初始化：计算所有顶点的入度，将入度为 0 的顶点入队（无依赖的初始任务）；
     - 循环：出队一个顶点 u，加入拓扑序列；遍历 u 的所有邻接顶点 v，将 v 的入度减 1（删除 u→v 的依赖）；若 v 的入度变为 0，入队；
     - 结束：若拓扑序列长度等于顶点数，则排序成功；否则图中存在环（无法拓扑排序）。

  2. DFS 逆后序

     ：

     - 对 DAG 进行 DFS，记录每个顶点的 “后序时间”（即递归结束时的顺序）；
     - 将后序序列反转，得到拓扑序列（因为 DFS 会先遍历完所有依赖顶点，再记录当前顶点的后序）。

- **应用**：编译依赖（先编译被依赖的库）、项目排期（先完成前置任务）。

#### 4. 最小生成树（MST，无向加权图的核心应用）

- **适用场景**：**无向加权连通图**，寻找一个 “子图”—— 包含所有顶点，边的权重和最小，且无环（即 “用最少的成本连接所有节点”，如电网铺设、网络布线）。

- **核心性质**：MST 有且仅有 n-1 条边（n 为顶点数），删除任意一条边会导致图不连通，添加任意一条边会形成环。

- 常用算法

  ：

  1. Prim 算法

     （类似 Dijkstra 算法，贪心）：

     - 从任意顶点出发，维护一个 “已加入 MST 的顶点集”；
     - 每次选 “连接已加入集和未加入集的边中权重最小的边”，将对应的未加入顶点加入 MST；
     - 重复直到所有顶点加入，时间复杂度 `O(m log n)`（用优先队列优化），适用于稠密图。

  2. Kruskal 算法

     （基于边排序，贪心）：

     - 将所有边按权重从小到大排序；
     - 依次选权重最小的边，若该边连接的两个顶点不在同一连通分量（用并查集检测），则将边加入 MST；
     - 重复直到选够 n-1 条边，时间复杂度 `O(m log m)`（排序边的时间），适用于稀疏图。

### 四、图论的实际应用场景

图论的价值在于 “抽象现实问题为图模型，用算法解决”，以下是典型应用：

1. **路径规划**：地图导航（如高德 / 百度地图的最短路径，用 Dijkstra 或其优化版 A* 算法）；
2. **社交网络**：好友推荐（基于连通分量、最短路径，如 “好友的好友”）、社群检测（基于强连通分量）；
3. **任务调度**：项目排期（拓扑排序，确定任务先后顺序）、CPU 进程调度（避免循环依赖）；
4. **网络设计**：通信网络铺设（最小生成树，用最少成本连接所有节点）、路由算法（如 OSPF 协议基于最短路径）；
5. **其他领域**：电路设计（检测环）、自然语言处理（语义网络）、生物信息学（蛋白质相互作用网络）。

### 五、学习图论的关键要点

1. **先理解模型**：遇到问题时，先明确 “顶点是什么”“边是什么”“边的方向 / 权重是否需要”，再选择合适的存储结构；
2. **掌握基础算法**：DFS/BFS 是所有图算法的基础，需熟练掌握其递归 / 迭代实现；最短路径、拓扑排序、最小生成树需理解 “贪心 / 动态规划” 的核心思想，而非死记代码；
3. **关注边界情况**：如图是否有环、是否有负边、是否连通，这些会直接影响算法选择（如 Dijkstra 不能处理负边，拓扑排序仅适用于 DAG）；
4. **结合实际场景**：通过案例（如导航、调度）理解算法的应用价值，避免单纯记忆理论。



# 回溯

在数据结构与算法中，**回溯（Backtracking）** 是一种基于 “试错” 思想的暴力搜索算法，核心逻辑是：**逐步构建解空间，若当前路径无法通向有效解，则回溯到上一步，尝试其他可能路径**。它本质是 “深度优先搜索（DFS）+ 剪枝” 的结合，常用于解决 “组合、排列、子集、切割、棋盘” 等需枚举所有可能解的问题。

### 一、回溯的核心原理

回溯的本质是对 “解空间树” 的遍历：

- **解空间树**：将问题的所有可能解抽象为一棵树，每个节点代表 “当前已做出的选择”，叶子节点代表 “完整的解” 或 “无效的尝试”。
- **遍历逻辑**：从根节点出发，沿某一分支深度优先探索（构建解）；若发现当前节点无法通向有效解（如违反约束条件），则 “剪枝”（停止该分支探索），并回溯到父节点，尝试其他分支。

#### 回溯的三要素（必明确）

1. **路径（Path）**：当前已选择的元素集合（即已构建的解的一部分）。
2. **选择列表（Choice List）**：当前可选择的元素集合（下一步能尝试的选项）。
3. **终止条件（Termination Condition）**：当路径满足问题要求时（如路径长度达到目标、覆盖所有必要元素），将路径加入结果集，并回溯。

### 二、回溯的通用代码框架（C++）

回溯算法的代码高度模板化，无论问题场景如何变化，核心结构均围绕 “递归探索 + 回溯撤销” 展开。以下是通用框架：

cpp







```cpp
#include <vector>
using namespace std;

// 结果集：存储所有有效解
vector<vector<int>> result;
// 路径：存储当前正在构建的解
vector<int> path;

// 回溯函数：参数通常包含“选择列表”和“约束条件相关参数”
void backtracking(/* 选择列表相关参数，如nums、startIndex等 */) {
    // 1. 终止条件：路径满足要求，加入结果集
    if (/* 终止条件，如path.size() == k */) {
        result.push_back(path); // 复制当前路径到结果集
        return;
    }

    // 2. 遍历选择列表：尝试所有可能的选择
    for (/* 遍历选择列表，如int i = startIndex; i < nums.size(); i++ */) {
        // （可选）剪枝：提前排除无效选择，减少遍历次数
        if (/* 剪枝条件，如当前元素已使用、不符合约束 */) {
            continue; // 跳过该选择，剪枝
        }

        // 3. 做出选择：将当前元素加入路径
        path.push_back(/* 当前选择的元素，如nums[i] */);

        // 4. 递归探索：深入下一层，继续构建解
        backtracking(/* 更新后的选择列表参数，如i+1（避免重复选） */);

        // 5. 回溯撤销：撤销上一步选择，回到上一层，尝试其他选项
        path.pop_back();
    }
}

// 调用入口：初始化参数，启动回溯
vector<vector<int>> solveProblem(/* 问题输入，如nums、k等 */) {
    result.clear(); // 清空结果集（避免多组测试用例干扰）
    path.clear();   // 清空路径
    backtracking(/* 传入初始化参数 */);
    return result;
}
```

### 三、回溯的典型应用场景（C++ 实例）

回溯的应用场景可归纳为 5 类，核心差异在于 “选择列表的范围” 和 “剪枝条件”，以下为每类场景的经典问题与代码实现。

#### 1. 组合问题（无重复元素，选 k 个元素）

**问题描述**：给定无重复元素的数组 `nums`，返回所有长度为 `k` 的组合（如 `nums=[1,2,3], k=2`，结果为 `[[1,2],[1,3],[2,3]]`）。

**关键约束**：组合不考虑顺序（如 `[1,2]` 和 `[2,1]` 是同一组合），需通过 `startIndex` 控制选择范围（避免重复）。

cpp







```cpp
#include <vector>
using namespace std;

vector<vector<int>> result;
vector<int> path;

// startIndex：控制下一次选择的起始位置，避免重复组合
void backtracking(vector<int>& nums, int k, int startIndex) {
    // 终止条件：路径长度达到k，加入结果
    if (path.size() == k) {
        result.push_back(path);
        return;
    }

    // 遍历选择列表：从startIndex开始，避免回头选
    // 剪枝优化：剩余元素不足时，无需继续遍历（i <= nums.size() - (k - path.size())）
    for (int i = startIndex; i <= nums.size() - (k - path.size()); i++) {
        path.push_back(nums[i]);   // 选当前元素
        backtracking(nums, k, i+1); // 下一轮从i+1开始（不重复选同一元素）
        path.pop_back();           // 回溯撤销
    }
}

vector<vector<int>> combine(vector<int>& nums, int k) {
    result.clear();
    path.clear();
    backtracking(nums, k, 0);
    return result;
}
```

#### 2. 排列问题（无重复元素，全排列）

**问题描述**：给定无重复元素的数组 `nums`，返回所有可能的全排列（如 `nums=[1,2,3]`，结果为 `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`）。

**关键约束**：排列考虑顺序（需选所有元素），需通过 “used 数组” 标记元素是否已使用（避免同一元素在路径中重复出现）。

cpp







```cpp
#include <vector>
using namespace std;

vector<vector<int>> result;
vector<int> path;

// used：标记元素是否已加入当前路径（大小与nums一致）
void backtracking(vector<int>& nums, vector<bool>& used) {
    // 终止条件：路径长度等于nums长度（全排列完成）
    if (path.size() == nums.size()) {
        result.push_back(path);
        return;
    }

    // 遍历选择列表：从0开始（排列需考虑所有未使用元素）
    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) { // 剪枝：跳过已使用的元素
            continue;
        }
        used[i] = true;        // 标记为已使用
        path.push_back(nums[i]);// 选当前元素
        backtracking(nums, used); // 递归探索
        path.pop_back();       // 回溯撤销选择
        used[i] = false;       // 回溯撤销标记
    }
}

vector<vector<int>> permute(vector<int>& nums) {
    result.clear();
    path.clear();
    vector<bool> used(nums.size(), false); // 初始化used数组
    backtracking(nums, used);
    return result;
}
```

#### 3. 子集问题（无重复元素，所有子集）

**问题描述**：给定无重复元素的数组 `nums`，返回所有可能的子集（包括空集和全集，如 `nums=[1,2,3]`，结果为 `[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]`）。

**关键约束**：子集不考虑顺序，且每个元素只能选一次，需通过 `startIndex` 控制选择范围（空集通过初始回溯直接加入）。

cpp







```cpp
#include <vector>
using namespace std;

vector<vector<int>> result;
vector<int> path;

// startIndex：控制下一次选择的起始位置，避免重复子集
void backtracking(vector<int>& nums, int startIndex) {
    // 终止条件：无显式终止（startIndex越界时自然退出）
    // 每一步路径都是一个子集，直接加入结果
    result.push_back(path);

    // 遍历选择列表：从startIndex开始
    for (int i = startIndex; i < nums.size(); i++) {
        path.push_back(nums[i]);   // 选当前元素
        backtracking(nums, i+1);   // 下一轮从i+1开始
        path.pop_back();           // 回溯撤销
    }
}

vector<vector<int>> subsets(vector<int>& nums) {
    result.clear();
    path.clear();
    backtracking(nums, 0);
    return result;
}
```

#### 4. 切割问题（字符串分割，满足特定条件）

**问题描述**：给定字符串 `s`，将其分割为若干子串，使每个子串都是回文串（如 `s="aab"`，结果为 `[["a","a","b"],["aa","b"]]`）。

**关键约束**：切割不重复，需通过 `startIndex` 控制切割起点（每次切割从 `startIndex` 到 `i` 的子串，判断是否为回文）。

cpp







```cpp
#include <vector>
#include <string>
using namespace std;

vector<vector<string>> result;
vector<string> path;

// 判断子串s[left..right]是否为回文
bool isPalindrome(string& s, int left, int right) {
    while (left < right) {
        if (s[left] != s[right]) return false;
        left++;
        right--;
    }
    return true;
}

// startIndex：切割的起始位置（避免重复切割）
void backtracking(string& s, int startIndex) {
    // 终止条件：startIndex达到字符串末尾（切割完成）
    if (startIndex == s.size()) {
        result.push_back(path);
        return;
    }

    // 遍历切割范围：从startIndex到s.size()-1
    for (int i = startIndex; i < s.size(); i++) {
        // 剪枝：若当前子串不是回文，跳过
        if (!isPalindrome(s, startIndex, i)) {
            continue;
        }
        // 截取子串s[startIndex..i]，加入路径
        path.push_back(s.substr(startIndex, i - startIndex + 1));
        backtracking(s, i + 1); // 下一轮从i+1开始切割
        path.pop_back();        // 回溯撤销
    }
}

vector<vector<string>> partition(string s) {
    result.clear();
    path.clear();
    backtracking(s, 0);
    return result;
}
```

#### 5. 棋盘问题（N 皇后）

**问题描述**：在 `n×n` 的棋盘上放置 `n` 个皇后，使它们不能互相攻击（同一行、同一列、同一对角线无多个皇后），返回所有合法的放置方案。

**关键约束**：需通过 “列标记数组”“正对角线标记数组”“反对角线标记数组” 剪枝（避免无效尝试）。

cpp







```cpp
#include <vector>
#include <string>
using namespace std;

vector<vector<string>> result;

// 检查当前位置(row, col)是否可放皇后
bool isValid(int row, int col, int n, 
             vector<bool>& usedCol,        // 标记列是否已使用
             vector<bool>& usedDiag1,      // 标记正对角线（row-col固定）
             vector<bool>& usedDiag2) {    // 标记反对角线（row+col固定）
    if (usedCol[col]) return false;
    if (usedDiag1[row - col + n - 1]) return false; // 偏移量：避免负索引
    if (usedDiag2[row + col]) return false;
    return true;
}

// row：当前处理的行（每行只放一个皇后，避免行冲突）
void backtracking(int n, int row, 
                   vector<bool>& usedCol, 
                   vector<bool>& usedDiag1, 
                   vector<bool>& usedDiag2, 
                   vector<string>& board) {
    // 终止条件：所有行都放完皇后
    if (row == n) {
        result.push_back(board);
        return;
    }

    // 遍历当前行的所有列，尝试放皇后
    for (int col = 0; col < n; col++) {
        // 剪枝：跳过无效位置
        if (!isValid(row, col, n, usedCol, usedDiag1, usedDiag2)) {
            continue;
        }

        // 做出选择：放皇后，标记约束
        board[row][col] = 'Q';
        usedCol[col] = true;
        usedDiag1[row - col + n - 1] = true;
        usedDiag2[row + col] = true;

        // 递归探索下一行
        backtracking(n, row + 1, usedCol, usedDiag1, usedDiag2, board);

        // 回溯撤销：移除皇后，取消标记
        board[row][col] = '.';
        usedCol[col] = false;
        usedDiag1[row - col + n - 1] = false;
        usedDiag2[row + col] = false;
    }
}

vector<vector<string>> solveNQueens(int n) {
    result.clear();
    vector<string> board(n, string(n, '.')); // 初始化棋盘（全为'.'）
    vector<bool> usedCol(n, false);          // 列约束
    vector<bool> usedDiag1(2 * n - 1, false); // 正对角线约束（共2n-1条）
    vector<bool> usedDiag2(2 * n - 1, false); // 反对角线约束
    backtracking(n, 0, usedCol, usedDiag1, usedDiag2, board);
    return result;
}
```

### 四、回溯的时间与空间复杂度

回溯的复杂度与 “解空间树的规模” 直接相关，通常为指数级（暴力搜索的本质），但剪枝可显著降低实际运行时间。

| 复杂度类型 | 分析                                                         |
| ---------- | ------------------------------------------------------------ |
| 时间复杂度 | 最坏情况：*O*(*N*×*N*!)（如全排列，需遍历 *N*! 个解，每个解需 *N* 步构建）；剪枝后：复杂度会降低（如 N 皇后的实际复杂度远低于 *N*!）。 |
| 空间复杂度 | *O*(*N*)（递归栈深度为问题的 “深度”，如全排列递归栈深为 *N*；路径和辅助数组的空间也为 *O*(*N*)）。 |

### 五、回溯的核心技巧：剪枝

剪枝是回溯算法的 “灵魂”，可大幅减少无效遍历，提升效率。常见剪枝场景：

1. **提前终止分支**：如组合问题中，剩余元素不足时（`i <= nums.size() - (k - path.size())`），直接跳过后续循环。
2. **约束排除**：如 N 皇后问题中，通过 `usedCol` `usedDiag` 数组提前排除冲突位置，避免无效递归。
3. **重复元素处理**：若问题含重复元素（如 “组合总和 II”），需先排序，再跳过相同元素（`if (i > startIndex && nums[i] == nums[i-1]) continue`），避免重复解。

### 总结

回溯是解决 “枚举类问题” 的通用工具，其核心是 “递归构建解 + 回溯撤销 + 剪枝优化”。在 C++ 实现中，需重点关注：

- 明确 “路径、选择列表、终止条件” 三要素；
- 利用 `startIndex`（组合、子集、切割）或 `used` 数组（排列）避免重复；
- 合理设计剪枝条件，降低时间复杂度。

掌握回溯的模板后，可灵活适配各类问题，只需根据具体场景调整 “选择列表的遍历范围” 和 “剪枝条件” 即可。