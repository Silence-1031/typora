# 苍穹外卖2

## 第三章 redis

### 第一节 入门

一、Redis 基础认知

1. 核心定义

Redis 是**基于内存的 Key-Value 键值对结构数据库**，核心功能是存储数据，但定位为 “MySQL 的补充” 而非替代。

2. 与 MySQL 的关键差异

| 对比维度 | Redis                      | MySQL                          |
| -------- | -------------------------- | ------------------------------ |
| 存储介质 | 内存（读写速度极快）       | 磁盘（持久化能力强）           |
| 数据结构 | Key-Value 键值对（灵活）   | 二维表（结构化存储）           |
| 适用场景 | 热点数据（秒杀、热门资讯） | 全量业务数据（订单、用户信息） |
| 核心优势 | 低延迟、高并发支持         | 复杂查询（联表）、事务         |

3. Key-Value 结构示例

一条 Key-Value 对应一条数据，格式简单直观，例如：

- `id:101`（Key 为 “id”，Value 为 “101”）
- `name:小智`（Key 为 “name”，Value 为 “小智”）
- `city:北京`（Key 为 “city”，Value 为 “北京”）



### 第二节 redis的数据结构

一、Redis 数据存储

Redis 以**键值对（Key-Value）** 形式存储数据，其中：

- **Key**：统一为**字符串类型**，用于唯一标识数据；
- **Value**：支持多种数据类型，本次重点讲解 5 种最常用类型（字符串、哈希、列表、集合、有序集合）。

二、5 种常用数据类型

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251126153237341.png" alt="image-20251126153237341" style="zoom:67%;" />

1. 字符串（String）

- **定义**：Redis 中最简单、最基础的数据类型，直接存储单个字符串值（也可存储数字等格式，但本质仍为字符串）。
- 特点
  - 结构单一，仅为 “Key - 单个 Value” 的映射；
  - 是 Redis 中使用频率最高的类型之一。

2. 哈希（Hash）（散列）

- **定义**：类似 Java 中的`HashMap`，Value 部分是 “字段 - 值（Field-Value）” 的键值对集合，即 `Key -> {Field1:Value1, Field2:Value2, ...}`。
- 特点
  - 支持多个 Field，每个 Field 对应唯一 Value；
  - 可精准操作单个 Field（如修改某 Field 的 Value，无需更新整个哈希）。
- 典型应用场景：存储**对象类数据**（如用户信息、商品详情），例如：
  - Key：`user:1001`（用户 ID）；
  - Value：`{name:"张三", age:"25", address:"北京"}`（用户的多个属性及对应值）。

3. 列表（List）

- **定义**：类似 Java 中的`LinkedList`，是有序的元素集合，元素按**插入顺序**排列，支持从两端（头部 / 尾部）操作元素。
- 特点
  - **有序性**：元素顺序与插入顺序一致；
  - **可重复性**：允许存储相同的元素；
  - 操作高效：从头部（左）或尾部（右）插入 / 删除元素速度快。
- 典型应用场景：存储需保留顺序的数据，例如：
  - 朋友圈点赞列表（按点赞时间排序）；
  - 消息队列（按消息产生顺序消费）。

4. 集合（Set）

- **定义**：类似 Java 中的`HashSet`，是无序的元素集合，基于哈希表实现。
- 特点
  - **无序性**：元素无固定排列顺序，无法通过索引访问；
  - **不可重复性**：集合内元素唯一，重复插入会自动去重；
  - 支持集合运算：可计算两个 Set 的**交集、并集、差集**。
- 典型应用场景
  - 存储无重复且无需排序的数据（如用户的关注列表、标签集合）；
  - 计算共同关系（如 “你和朋友的共同好友”，即两个用户关注列表的交集）。

5. 有序集合（Sorted Set / ZSet）

- **定义**：在 集合基础上增加 “分数（Score）” 属性，每个元素关联一个 Score，Redis 通过 Score 的大小对元素进行**排序**。
- 特点
  - **有序性**：按 Score 升序 / 降序排列，替代 “无序” 的 Set；
  - **不可重复性**：元素唯一（但不同元素的 Score 可相同）；
  - 排序基于 Score，无需手动维护顺序。
- 典型应用场景：存储需排序的排行榜类数据，例如：
  - 视频播放量排行榜（Score：播放次数，按 Score 降序排列）；
  - 投票排名（Score：得票数，按 Score 降序展示名次）。

三、核心对比总结

| 数据类型         | 有序性               | 可重复性                     | 类似 Java 结构          | 核心应用场景                     |
| ---------------- | -------------------- | ---------------------------- | ----------------------- | -------------------------------- |
| 字符串（String） |                      | （单个值，无重复）           | String                  | 单个文本、数字存储               |
| 哈希（Hash）     | （Field 无固定顺序） | （Field 唯一，Value 可重复） | HashMap                 | 对象类数据（用户、商品）         |
| 列表（List）     | 有（插入顺序）       | 是                           | LinkedList              | 有序数据（点赞列表、消息队列）   |
| 集合（Set）      | 无                   | 否                           | HashSet                 | 无重复数据、集合运算（共同好友） |
| 有序集合（ZSet） | 有（Score 排序）     | 否                           | TreeSet（但基于 Score） | 排行榜（播放量、投票）           |



### 第三节 redis常用命令

Redis 命令的核心差异：Redis 与 MySQL 操作数据的逻辑存在本质区别：

- **MySQL**：通过统一的 SQL 语句操作数据（如`INSERT`插入、`SELECT`查询），与数据类型无关，语法结构固定。
- **Redis**：**不同数据类型对应专属命令**（如字符串、哈希、列表等各有一套操作命令），需先明确数据类型，再选择对应命令。

#### 3.1 字符串操作指令

一、字符串类型 4 个核心命令

字符串（String）是 Redis 最基础的数据类型，常用命令共 4 个

|         命令格式          |                   核心作用                    |                           关键说明                           |                           实操示例                           |
| :-----------------------: | :-------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      `SET key value`      |     设置指定 key 的 value（新增 / 覆盖）      | 1. 若 key 已存在，会覆盖原有 value；<br>2. 命令不区分大小写（如`set`/`SET`效果一致） | `SET name jack` → 新增 key 为`name`、value 为`jack`的字符串  |
|         `GET key`         |             获取指定 key 的 value             | 1. 若 key 存在，返回对应的 value；<br/>2. 若 key 不存在，返回`null`（空） |     `GET name` → 返回`jack`；<br/>`GET abc` → 返回`null`     |
| `SETEX key seconds value` | 设置 key 的 value，并指定过期时间（秒为单位） | 1. 过期时间到后，Redis 会**自动删除**该 key；<br/>2. `seconds`必须为整数，代表 “秒” | `SETEX code 60 1234` → key`code`的 value 为`1234`，60 秒后过期 |
|     `SETNX key value`     |   仅当 key 不存在时，才设置 value（防覆盖）   | 1. 若 key 已存在，命令执行失败（返回`0`）；<br/>2. 若 key 不存在，执行成功（返回`1`） | 1. 首次执行`SET NX k1 itcast` → 返回`1`（成功）；<br/>2. 再次执行`SET NX k1 itheima` → 返回`0`（失败，`k1`仍为`itcast`） |

二、关键特性：命令不区分大小写

Redis 字符串相关命令（及其他多数命令）均不区分大小写，例如：

- `SET name tom` 与 `set name tom` 效果完全一致；

- `GET name`与`get name`效果完全一致。

  该特性与 MySQL 的 SQL 语句类似，降低了命令输入的严格性。

四、典型应用场景

1. **`SET EX`：短信验证码场景**
   - 业务需求：短信验证码通常需 “5 分钟内有效”，过期后自动失效。
   - 实现逻辑：生成验证码后，用`SET EX key 300 验证码`（300 秒 = 5 分钟）存储，过期后 Redis 自动删除，无需手动清理，避免无效数据残留。
2. **`SET NX`：分布式锁场景**
   - 业务需求：分布式系统中，需防止多个服务同时操作同一资源（如并发下单减库存），避免数据不一致。
   - 实现逻辑：用`SET NX lockKey 1`尝试获取锁 —— 若返回`1`，表示成功获取锁（可执行操作）；若返回`0`，表示锁已存在（其他服务正在操作，需等待或放弃）。（注：分布式锁的完整实现需结合过期时间，视频提示后续课程展开）



#### 3.2 哈希操作命令

一、Redis 哈希结构核心概念

1. **结构定义**：哈希（Hash）是 Redis 中的一种复合数据类型，本质是`string类型的field（字段）`与`string类型的value（值）`的映射表（键值对集合）。
2. 存储特点
   - 整体数据格式为「外层 key → 内层 Hash 表（field:value）」，即外层 key 对应的值是一个哈希表。
   - 内层的 field 和 value 均为简单字符串，结构清晰，适合存储**对象类数据**（如用户信息、商品信息等）。
3. **核心优势**：无需将整个对象序列化存储，可直接操作对象的单个字段（如修改用户年龄无需更新整个用户信息），灵活性更高。

二、Redis 哈希常用命令

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251126155548737.png" alt="image-20251126155548737" style="zoom:67%;" />

| 命令    | 语法格式                    | 功能描述                                                     |
| ------- | --------------------------- | ------------------------------------------------------------ |
| `HSET`  | `HSET key field value`      | 给指定 key 的哈希表设置「field:value」键值对；若 key 不存在则创建，若 field 已存在则覆盖旧值 |
| `HGET`  | `HGET key field`            | 获取指定 key 的哈希表中某个 field 对应的 value               |
| `HDEL`  | `HDEL key field [field...]` | 删除指定 key 的哈希表中一个或多个 field                      |
| `HKEYS` | `HKEYS key`                 | 获取指定 key 的哈希表中**所有 field**（字段名）              |
| `HVALS` | `HVALS key`                 | 获取指定 key 的哈希表中**所有 value**（字段值）              |

三、命令记忆与使用注意事项

1. **命令前缀规律**：所有哈希操作命令均以`H`开头（Hash 的缩写），便于联想记忆（如 HSET=Hash Set、HGET=Hash Get）。
2. 操作粒度
   - `HSET/HGET/HDEL` 操作的是哈希表中的**单个 field**，适合精准修改 / 查询 / 删除字段。
   - `HKEYS/HVALS` 操作的是哈希表的**所有 field 或 value**，适合批量获取字段名或字段值。
3. **数据一致性**：执行`HDEL`后，哈希表中仅删除指定 field，外层 key 不会被删除；若需删除整个哈希表，需使用通用命令`DEL key`（视频未提及，但属于高频关联操作）。





#### 3.3 列表操作命令

一、Redis 列表（List）的基础特性

Redis 中的列表是**简单字符串的有序集合**，核心特点如下：

1. **存储结构**：Value 部分为列表，列表中的每个元素都是字符串（如`a、b、c、d`）；
2. **排序规则**：严格按照**元素插入顺序**排序，插入顺序决定最终存储顺序；
3. **操作维度**：支持从 “左侧（头部）” 和 “右侧（尾部）” 双向操作，可类比 “水平摆放的队列”（左侧为队头，右侧为队尾）。

二、4 个核心操作命令（含实操案例

| 命令格式                       | 命令含义                                                     | 关键参数说明                       | 实操案例与效果                                               |
| ------------------------------ | ------------------------------------------------------------ | ---------------------------------- | ------------------------------------------------------------ |
| `LPUSH key value1 [value2...]` | 从列表**左侧（头部）** 插入 1 个或多个元素                   | key：列表标识；value：待插入字符串 | 1. 执行`LPUSH myList a b c`：插入后列表元素顺序为`[c, b, a]`（左侧插入，后插元素在更左侧）；<br>2. 再执行`LPUSH myList d`：插入后列表变为`[d, c, b, a]`（d 在最左侧头部）。 |
| `LRANGE key start stop`        | 获取列表中**指定范围**的元素，类似 “分页查询”                | start：起始索引；stop：结束索引    | 1. 执行`LRANGE myList 0 -1`：`0`表示从头部开始，`-1`表示到尾部结束，返回全部元素`[d, c, b, a]`；<br>2. 若执行`LRANGE myList 0 1`：返回前 2 个元素`[d, c]`。 |
| `RPOP key`                     | 从列表**右侧（尾部）** 删除 1 个元素，并**返回被删除的元素** | key：列表标识                      | 1. 列表初始为`[d, c, b, a]`，执行`RPOP myList`：删除尾部的`a`，返回`a`，列表变为`[d, c, b]`；<br>2. 再执行`RPOP myList`：删除尾部的`b`，返回`b`，列表变为`[d, c]`。 |
| `LLEN key`                     | 获取列表的**长度**（即元素个数）                             | key：列表标识                      | 列表为`[d, c]`时，执行`LLEN myList`：返回`2`）。             |

三、关键注意事项

1. **命令大小写**：Redis 命令不区分大小写（如`LPUSH`可写为`lpush`），但约定使用大写以区分命令与参数；
2. **索引规则**：`LRANGE`的`start`和`stop`支持 “负索引”——`-1`代表最后一个元素（尾部），`-2`代表倒数第二个元素，以此类推；
3. **空列表处理**：若列表已无元素（长度为 0），执行`RPOP`不会报错，仅返回`nil`；若 key 不存在，`LLEN`返回`0`，`LRANGE`返回空列表；
4. **插入顺序影响**：`LPUSH`是 “左侧插入”，后插入的元素会排在更靠前的位置（如先插`a b c`，再插`d`，`d`在`c`前面），需注意与 “右侧插入（RPUSH）” 的区别（视频未讲`RPUSH`，但需理解双向插入逻辑）。



#### 3.4 集合操作命令

一、Redis 集合（Set）的核心特性

Redis 中的集合是 **String 类型元素的无序集合**，具备以下 3 个关键特性，是其区别于列表（List）、哈希（Hash）等类型的核心：

1. **元素类型单一**：集合中的每个成员均为 String 类型（简单字符串），不支持嵌套其他数据类型（如集合内不能包含另一个集合）。
2. **元素唯一**：集合内不允许存在重复元素，若尝试添加已存在的元素，Redis 会自动忽略该操作（不会报错，但返回 “添加成功的元素个数为 0”）。
3. **无序性**：集合不记录元素的插入顺序，查询时返回的元素顺序与插入顺序无关（例如插入顺序为 `a、b、c`，查询可能返回 `c、a、b`）。

二、Redis 集合（Set）常用命令及实战

视频中重点讲解了 6 个核心命令，涵盖 “增、查、统计、集合运算、删” 五大操作场景，每个命令均包含**语法格式**、**功能说明**和**实战示例**：

|             命令语法             |                   命令功能                   |                           实战示例                           |
| :------------------------------: | :------------------------------------------: | :----------------------------------------------------------: |
| `SADD key member1 [member2 ...]` | 向指定集合中添加 1 个或多个 String 类型元素  | `SADD set1 a b c d`<br/>结果：返回 `4`（表示成功添加 4 个元素）<br/>重复添加测试：执行 `SADD set1 a`，返回 `0`（`a` 已存在，添加失败） |
|          `SMEMBERS key`          | 返回指定集合中的**所有成员**（查询全量元素） | `SMEMBERS set1`<br>结果：返回 `["c","b","a","d"]`（无序，与插入顺序无关） |
|           `SCARD key`            |   统计指定集合中的**成员个数**（元素数量）   | `SCARD set1`<br/>结果：返回 `4`（对应 `a、b、c、d` 四个元素） |
|     `SINTER key1 [key2 ...]`     |            计算多个集合的**交集**            | `SINTER set1 set2`<br/>结果：返回 `["a","b"]`（`set1` 和 `set2` 共有的元素） |
|     `SUNION key1 [key2 ...]`     |            计算多个集合的**并集**            | `SUNION set1 set2`<br/>结果：返回 `["a","b","c","d","x","y"]`（合并后自动剔除重复元素 `a、b`） |
| `SREM key member1 [member2 ...]` |       从指定集合中删除 1 个或多个元素        | `SREM set1 a`<br/>结果：返回 `1`（表示成功删除 1 个元素），后续查询 `SMEMBERS set1` 时，`a` 已不存在 |

三、命令记忆技巧

- `ADD`（添加）→ `SADD`（添加元素）
- `MEMBERS`（成员）→ `SMEMBERS`（查询所有成员）
- `CARD`（卡片 / 数量）→ `SCARD`（统计数量）
- `INTER`（Intersection，交集）→ `SINTER`（计算交集）
- `UNION`（并集）→ `SUNION`（计算并集）
- `REM`（Remove，删除）→ `SREM`（删除元素）



#### 3.5 有序集合操作命令

一、有序集合（ZSet）的核心特性

有序集合是 Redis 的 5 种基础数据类型之一，兼具 “集合” 和 “有序” 的双重属性，关键特性如下：

1. **元素唯一性**：与普通集合（Set）一致，元素为`string`类型，且不允许重复（避免数据冗余）。

2. **排序依据：分数（Score）**：每个元素会关联一个`double`类型的 “分数”，Redis 通过该分数对元素进行排序（这是与普通集合的核心区别）。

3. 数据结构形态：整体仍以 “Key-Value” 形式存储，但 Value 是 “元素 - 分数” 的映射集合，示例如下：

   | Key   | Value（元素 - 分数映射） |
   | ----- | ------------------------ |
   | zset1 | a:10.0、b:10.5、c:10.2   |

二、有序集合（ZSet）核心操作命令

| 命令      | 格式                                           | 核心作用                                          | 示例及说明                                                   |
| --------- | ---------------------------------------------- | ------------------------------------------------- | ------------------------------------------------------------ |
| `ZADD`    | `ZADD key score1 member1 [score2 member2 ...]` | 向有序集合中添加 1 个或多个 “元素 - 分数” 对      | `ZADD zset1 10.0 a 10.5 b`。                                 |
| `ZRANGE`  | `ZRANGE key start stop [WITHSCORES]`           | 按 “分数升序” 返回指定区间的元素                  | 1. `ZRANGE zset1 0 -1`：返回`zset1`中所有元素（`0`表示起始位置，`-1`表示末尾位置），默认只返回元素；<br>2. `ZRANGE zset1 0 -1 WITHSCORES`：返回元素的同时，附带对应的分数。 |
| `ZINCRBY` | `ZINCRBY key increment member`                 | 为指定元素的分数 “增加指定值”（支持负数，即减分） | `ZINCRBY zset1 5.0 a`：将`zset1`中元素`a`的分数增加 5.0（原 10.0→15.0） |
| `ZREM`    | `ZREM key member1 [member2 ...]`               | 从有序集合中删除 1 个或多个元素                   | `ZREM zset1 b`：删除`zset1`中的元素`b`；执行后返回 “成功删除的元素个数”（如示例返回 1）。 |

三、关键注意点

1. **排序规则**：`ZRANGE`默认按 “分数升序” 返回元素；若需降序，可使用扩展命令`ZREVRANGE`（视频未提及，但为高频场景补充）。
2. **分数精度**：分数为`double`类型，可能存在精度丢失（如视频中 10.2 可能显示为 10.199999...），实际使用中需注意场景适配（如无需高精度的排名场景可忽略）。
3. **命令前缀**：所有有序集合命令均以`Z`开头（代表`ZSet`），便于与其他数据类型的命令区分（如 Set 命令以`S`开头）。



#### 3.6 通用操作

一、通用命令核心特点

通用命令是 Redis 中 “跨数据类型” 的命令，不依赖于 String、Hash、List、Set、ZSet 等具体数据类型，仅针对 “Key” 进行操作，适用于所有存储在 Redis 中的数据，是日常管理和开发中高频使用的基础命令。

二、四大核心通用命令详解

1. `KEYS pattern`：匹配并查询符合模式的 Key功能

- 功能:根据指定的 “模式（pattern）”，查询 Redis 数据库中所有符合条件的 Key，支持通配符匹配，常用于快速查看当前库中的 Key 集合。

- `pattern`：匹配模式，支持通配符（常用`*`表示 “任意字符”）。

| 命令         | 功能说明                                     | 示例结果                                  |
| ------------ | -------------------------------------------- | ----------------------------------------- |
| `KEYS *`     | 查询所有 Key                                 | 返回 `["name", "set1", "set2", "myList"]` |
| `KEYS set*`  | 查询以 “set” 开头的所有 Key                  | 返回 `["set1", "set2"]`                   |
| `KEYS *list` | 查询以 “list” 结尾的所有 Key（不区分大小写） | 返回 `["myList"]`                         |

**注意**

- 生产环境慎用`KEYS *`：若 Redis 中 Key 数量极多（如 10 万 +），`KEYS *`会遍历所有 Key，阻塞 Redis 服务，影响业务；建议用`SCAN`命令替代。



2. EXISTS key：检查指定 Key 是否存在

- 功能:判断某个 Key 是否存在于 Redis 数据库中，返回结果为 “存在计数”，仅关注 “存在与否” 时可直接通过返回值判断。

- 语法:`EXISTS key [key ...]`

  - `key`：需检查的 Key（支持同时检查多个 Key，用空格分隔）；

  - 返回值：整数类型，`1`表示 Key 存在，`0`表示 Key 不存在；若检查多个 Key，返回 “存在的 Key 的数量”。

| 命令              | 功能说明                          | 示例结果（假设库中有 key：name，无 key：ABC） |
| ----------------- | --------------------------------- | --------------------------------------------- |
| `EXISTS name`     | 检查 “name” 是否存在              | 返回 `1`（存在）                              |
| `EXISTS ABC`      | 检查 “ABC” 是否存在               | 返回 `0`（不存在）                            |
| `EXISTS name ABC` | 同时检查 “name” 和 “ABC” 是否存在 | 返回 `1`（仅 name 存在）                      |

3. TYPE key：查询 Key 对应的 Value 数据类型

- 功能:返回指定 Key 所存储的 Value 的数据类型，明确当前 Key 对应的是 String、Hash、List、Set 还是 ZSet，帮助开发者确认数据结构，避免操作命令与类型不匹配（如用 String 命令操作 Hash 类型 Key）。

- 语法：`TYPE key`

  - `key`：需查询的 Key；

  - 返回值：字符串类型，常见值为`string`、`hash`、`list`、`set`、`zset`（若 Key 不存在，返回`none`）。

| 命令          | 功能说明                    | 示例结果      |
| ------------- | --------------------------- | ------------- |
| `TYPE name`   | 查询 “name” 的 Value 类型   | 返回 `string` |
| `TYPE set1`   | 查询 “set1” 的 Value 类型   | 返回 `set`    |
| `TYPE myList` | 查询 “myList” 的 Value 类型 | 返回 `list`   |
| `TYPE ABC`    | 查询不存在的 “ABC” 的类型   | 返回 `none`   |

4. DEL key：删除指定 Key（及对应 Value）

- 功能

删除 Redis 中指定的 Key（及其关联的 Value），支持一次性删除多个 Key，删除成功后 Key 会从数据库中彻底移除。

- 语法:`DEL key [key ...]`

  - `key`：需删除的 Key（支持同时删除多个 Key，用空格分隔）；

  - 返回值：整数类型，代表 “成功删除的 Key 数量”（若删除不存在的 Key，不计入计数，返回`0`）。

| 命令                  | 功能说明                                | 示例结果（假设库中有 key：name、set1、set2、zset1） |
| --------------------- | --------------------------------------- | --------------------------------------------------- |
| `DEL name`            | 删除 “name” Key                         | 返回 `1`（成功删除 1 个）                           |
| `DEL set1 set2 zset1` | 一次性删除 “set1”“set2”“zset1” 三个 Key | 返回 `3`（成功删除 3 个）                           |
| `DEL ABC`             | 删除不存在的 “ABC” Key                  | 返回 `0`（未删除任何 Key）                          |

**注意**

- DEL 命令是 “立即删除”：删除后数据无法恢复，若需 “延迟删除” 或 “逻辑删除”，需结合 Redis 的过期时间（`EXPIRE`命令，视频暂未提及）或业务层设计。

三、命令使用场景梳理

| 命令     | 典型使用场景                                                 |
| -------- | ------------------------------------------------------------ |
| `KEYS`   | 开发 / 测试环境快速查看 Key 集合，确认数据是否存在           |
| `EXISTS` | 操作前判断 Key 是否存在（如避免重复写入、确认数据有效性）    |
| `TYPE`   | 排查 “命令与数据类型不匹配” 的错误（如用`HGET`操作 String Key） |
| `DEL`    | 清理过期 / 无用数据、业务逻辑中删除指定数据（如用户退出后删除临时 Key） |



### 第四节 RedisR的java客户端

一、Redis 的 Java 客户端对比

|        客户端         |                           核心特点                           |               适用场景                |
| :-------------------: | :----------------------------------------------------------: | :-----------------------------------: |
|       **Jedis**       | 1. Redis 官方推荐<br>2. 方法名与 Redis 命令**完全对应**，学习成本低<br/>3. 封装简洁优秀 |   简单场景、对 Redis 命令熟悉的场景   |
|      **Lettuce**      |  1. 基于 Netty 多线程框架实现<br/>2. 性能高效，支持异步操作  |       高并发、高性能要求的场景        |
| **Spring Data Redis** | 1. Spring 生态的一部分，对 Jedis、Lettuce 进行**高度封装**<br/>2. 简化操作，降低使用门槛 | 企业级 Spring 项目（课程 / 项目首选） |

二、Spring Data Redis 核心使用步骤

课程明确其使用需遵循 3 个关键步骤，类比 MySQL 的 JDBC/MyBatis 配置逻辑：

1. 导入 Maven 坐标

- 核心：在项目的`pom.xml`中引入 Spring Data Redis 相关依赖，确保项目能加载框架类库（类似 MySQL 的 JDBC 驱动坐标）。

2. 配置 Redis 数据源

- 作用：指定 Redis 服务的连接信息，让 Java 程序找到目标 Redis 服务，配置内容包括：
  - Redis 服务器地址（如`localhost`或远程 IP）
  - 端口号（默认 6379）
  - 密码（若 Redis 服务设置了访问密码）

3. 编写配置类创建`RedisTemplate`对象（Redis模板对象）

- **核心对象**：`RedisTemplate`是 Spring Data Redis 中**最核心、最常用**的操作对象，所有 Redis 数据操作（字符串、哈希、列表等）都依赖该对象。
- **实现方式**：通过自定义配置类（标注`@Configuration`），在类中定义方法（标注`@Bean`），手动创建并配置`RedisTemplate`实例，最终交由 Spring 容器管理。
- **后续使用**：通过`@Autowired`或`@Resource`注解，将`RedisTemplate`注入到 Service、Controller 等组件中，即可调用其方法操作 Redis 数据。



### 第五节 配置Redis

一、核心前提：Spring Data Redis 的选择依据

视频明确推荐使用`Spring Data Redis`框架操作 Redis，核心原因是其对 Redis 原生 API 进行了封装，能与 Spring Boot 生态无缝集成，简化连接管理、数据序列化等重复工作，避免原生 Jedis 等工具的繁琐配置。

二、环境搭建四步走（核心操作）

1. 第一步：导入 Spring Data Redis 的 Maven 坐标

- **依赖来源**：项目初始工程已预置`spring-boot-starter-data-redis`（Spring Boot 提供的 starter 依赖，自动管理版本与依赖传递）。

- 检查位置：在`sky-take-out-server`模块的`pom.xml`文件中：

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
  </dependency>
  ```

- **作用**：自动引入 Redis 连接池、Spring Data Redis 核心 API 等基础组件，为后续操作提供依赖支持。

2. 第二步：配置 Redis 数据源（连接信息）:类比 MySQL 数据源配置，需在 Spring Boot 配置文件中指定 Redis 连接参数，核心关注**工程化配置规范**（避免硬编码）。

```yaml
# 1. 自定义配置项（可放在配置文件任意位置，推荐集中管理）
sky:
  redis:
    host: localhost
    port: 6379
    password: 123456
    database: 0

# 2. 引用自定义配置项（Redis数据源配置）
spring:
  redis:
    host: ${sky.redis.host}
    port: ${sky.redis.port}
    password: ${sky.redis.password}
    database: ${sky.redis.database}
```



3. 第三步：编写配置类，创建 RedisTemplate 对象

`RedisTemplate`是 Spring Data Redis 的核心操作类，需通过配置类手动创建（目的是自定义**Key 序列化器**，避免默认序列化导致的 Key 乱码问题）。

（1）配置类编写规范

- **包路径**：放在`config`包下（工程规范，统一管理配置类），类名建议为`RedisConfiguration`。

- 核心注解

  - `@Configuration`：声明此类为 Spring 配置类，会被 Spring 扫描并加载。

  ```java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  import org.springframework.data.redis.connection.RedisConnectionFactory;
  import org.springframework.data.redis.core.RedisTemplate;
  import org.springframework.data.redis.serializer.StringRedisSerializer;
  import lombok.extern.slf4j.Slf4j;
  
  @Configuration
  @Slf4j
  public class RedisConfiguration {
  
      // 注入Redis连接工厂（由spring-boot-starter-data-redis自动创建，无需手动实现）
      @Bean
      public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
          log.info("开始创建RedisTemplate对象");
          // 1. 实例化RedisTemplate
          RedisTemplate redisTemplate = new RedisTemplate();
          
          // 2. 关联Redis连接工厂（指定Redis连接来源）
          redisTemplate.setConnectionFactory(redisConnectionFactory);
          
          // 3. 关键：设置Key的序列化器（使用StringRedisSerializer，避免Key乱码）
          redisTemplate.setKeySerializer(new StringRedisSerializer());
          
          // 4. 返回配置好的RedisTemplate（注入到Spring容器中，供后续使用）
          return redisTemplate;
      }
  }
  ```

（2）关键细节：为什么要自定义 Key 序列化器？

- Spring Data Redis 默认使用`JdkSerializationRedisSerializer`，会将 Key 序列化为二进制格式（如`\xAC\xED\x00\x05t\x00\x03key`），导致 Redis 客户端（如 Redis CLI）无法直观查看 Key。
- 使用`StringRedisSerializer`可将 Key 序列化为普通字符串，保证可读性与兼容性。

三、Redis 基础补充：数据库隔离机制

视频特别强调 Redis 的**多数据库特性**，避免后续操作数据时混淆库位：

- Redis 默认创建 16 个数据库（编号 0-15），通过`SELECT 数据库编号`命令切换（如`SELECT 1`切换到 1 号库）。
- 不同数据库的数据完全隔离（0 号库的 Key 不会出现在 1 号库中），可用于按业务模块拆分数据（如 0 号库存用户数据，1 号库存商品数据）。

四、工程化实践规范

1. **依赖管理**：优先使用 Spring Boot Starter 依赖（如`spring-boot-starter-data-redis`），避免手动管理版本冲突。
2. **配置分离**：敏感配置（如 Redis 密码、IP）不硬编码，通过自定义前缀（如`sky.redis`）抽离，方便环境切换与配置中心集成。
3. **代码结构**：配置类统一放在`config`包，测试类放在`test`包对应路径，符合企业级项目的代码分层规范。



```java
@Test
public void testHash() {
    // 1. 获取HashOperations对象
    HashOperations hashOperations = redisTemplate.opsForHash();
    
    // 2. 向哈希表（key=100）中添加字段：name=tom、age=20
    hashOperations.put("100", "name", "tom");
    hashOperations.put("100", "age", 20);
    
    // 3. 查询哈希表（key=100）中name字段的值，强转为String类型
    String name = (String) hashOperations.get("100", "name");
    System.out.println("用户姓名：" + name); // 输出：用户姓名：tom
    
    // 4. 查询哈希表（key=100）中所有字段名
    Set keys = hashOperations.keys("100");
    System.out.println("所有字段名：" + keys); // 输出：所有字段名：[name, age]
    
    // 5. 查询哈希表（key=100）中所有字段值
    List values = hashOperations.values("100");
    System.out.println("所有字段值：" + values); // 输出：所有字段值：[tom, 20]
    
    // 6. 删除哈希表（key=100）中的age字段
    hashOperations.delete("100", "age");
}


```





### 第六节 营业状态设置

一、功能需求分析（业务逻辑核心）

基于产品原型，明确功能目标与影响范围，是技术设计的前提：

1. **核心功能**：支持商家端修改店铺状态（营业 / 打烊），并在商家端、用户端分别展示状态
2. 状态规则约定
   - 营业状态（标识为`1`）：用户可在小程序正常下单点餐
   - 打烊状态（标识为`0`）：用户无法在小程序发起点餐
3. **多端交互影响**：状态修改需同步作用于 “商家管理端”（展示 + 操作）和 “用户小程序端”（仅展示，影响下单权限）

二、接口设计（前后端交互规范）

遵循项目 “按端划分接口前缀” 的约定，设计 3 个接口覆盖全场景，接口设计需符合 RESTful 风格：

| 接口用途                   | 请求方式 | 请求路径               | 参数说明                             | 返回数据格式                             | 核心作用                 |
| -------------------------- | -------- | ---------------------- | ------------------------------------ | ---------------------------------------- | ------------------------ |
| 设置店铺营业状态（商家端） | PUT      | `/admin/shop/{status}` | 路径参数`status`：1 = 营业，0 = 打烊 | `{code: 1/0, message: "提示", data: {}}` | 商家修改状态（修改操作） |
| 查询店铺状态（商家端）     | GET      | `/admin/shop/status`   | 无参数                               | `{code: 1, data: 1/0, message: "成功"}`  | 商家端展示当前状态       |
| 查询店铺状态（用户端）     | GET      | `/user/shop/status`    | 无参数                               | `{code: 1, data: 1/0, message: "成功"}`  | 小程序端判断是否允许下单 |

**关键设计原则：**

- **接口拆分原因**：项目约定 “商家端接口前缀为`/admin`，用户端为`/user`”，通过路径即可识别请求来源，便于权限控制、日志统计等后续扩展
- **请求方式选择**：修改状态用`PUT`（符合 RESTful 中 “更新资源” 的语义），查询用`GET`（无副作用，可缓存）
- **参数传递**：状态值通过 “路径参数” 传递（简单值 + 语义清晰），无需复杂请求体

三、数据存储方案（性能与成本权衡）

针对 “仅需存储 1 个状态值（0/1）” 的轻量场景，放弃 MySQL 表存储，选择 Redis 优化性能：

1. 存储介质选择理由
   - 若用 MySQL：需单独创建表（仅 1 个字段 1 条数据），存在 “资源浪费”“IO 开销高” 问题
   - 若用 Redis：基于字符串（String）类型存储，Key-Value 结构轻量，读写性能远超 MySQL（内存操作 vs 磁盘操作）
2. Redis 存储设计
   - Key：`shop:status`（语义化命名，便于维护）
   - Value：`1`（营业）或`0`（打烊）（与接口参数、业务逻辑保持一致，避免多端转换）
3. **优势**：后续查询接口（商家端 / 用户端）可直接从 Redis 读取，减少数据库压力，提升接口响应速度





## 第四章 微信登录

### 第一节 HttpClient

一、HttpClient 基础概念

1. 定义与归属

- **所属项目**：HttpClient 是 Apache 软件基金会下的子项目，是 Java 生态中常用的 HTTP 客户端编程工具包。
- **核心作用**：提供高效、功能丰富的 HTTP 协议支持，可在 Java 程序中通过编码方式**构造并发送 HTTP 请求**（如 GET、POST、DELETE、PUT 等），且支持 HTTP 协议的最新版本与建议。

2. 核心特性

- 定位为 “客户端编程工具包”，而非独立运行的工具，需集成到 Java 项目中使用；
- 支持多种 HTTP 请求方法，满足不同业务场景（如查询数据用 GET、提交数据用 POST）；
- 提供稳定的 API 封装，简化 HTTP 请求的创建、发送与响应处理流程。

二、关键依赖配置（Maven）

使用 HttpClient 需先在项目的 `pom.xml` 中导入依赖，视频中指定的版本为 4.5（主流稳定版本），配置如下：

```xml
<dependency>
    <groupId>org.apache.httpcomponents</groupId> <!-- 组ID，固定为Apache的HTTP组件组 -->
    <artifactId>httpclient</artifactId>          <!-- 模块ID，指定HttpClient核心包 -->
    <version>4.5</version>                       <!-- 版本号，视频中使用4.5版本 -->
</dependency>
```

三、核心 API 组件

| 组件名称              | 类型   | 核心作用                                                     |
| --------------------- | ------ | ------------------------------------------------------------ |
| `HttpClient`          | 接口   | 定义 HTTP 客户端的核心能力（如发送请求），是所有 HttpClient 实现类的顶层接口 |
| `CloseableHttpClient` | 实现类 | `HttpClient` 接口的具体实现类，实际开发中用于创建可关闭的客户端实例 |
| `HttpGet`             | 类     | 代表 **HTTP GET 请求**，用于构造查询类请求（如获取数据）     |
| `HttpPost`            | 类     | 代表 **HTTP POST 请求**，用于构造提交类请求（如上传数据、提交表单） |

> `HttpClients`是**构建器类**，用于创建 `CloseableHttpClient` 实例（而非直接 new 实例）

四、HttpClient 发送请求的固定流程

**步骤 1：创建 HttpClient 实例**：通过 `HttpClients` 构建器创建 `CloseableHttpClient` 对象（客户端实例是发送请求的 “载体”）

```java
// 方式：通过构建器创建客户端实例
CloseableHttpClient httpClient = HttpClients.createDefault();
```

**步骤 2：创建 HTTP 请求对象**：根据业务需求，选择对应的请求类型（GET/POST 等），构造具体的请求对象：

- 若发送 GET 请求：创建 `HttpGet` 实例，传入请求 URL；

- 若发送 POST 请求：创建`HttpPost`实例，传入请求 URL（后续需额外设置请求体、参数等）。

  示例逻辑：

```java
// GET 请求示例：构造访问“某接口”的GET请求
HttpGet httpGet = new HttpGet("http://xxx.com/api/xxx");

// POST 请求示例：构造提交“某接口”的POST请求
HttpPost httpPost = new HttpPost("http://xxx.com/api/xxx");
```

**步骤 3：调用 execute 方法发送请求**：通过 `CloseableHttpClient` 的 `execute()` 方法，传入步骤 2 创建的请求对象，完成请求发送并获取响应（后续需处理响应结果，如获取状态码、响应体等），核心代码逻辑：

```java
// 发送请求并获取响应（response 为响应对象，需后续处理）
CloseableHttpResponse response = httpClient.execute(httpGet); // 此处以GET请求为例
```





### 第二节 微信小程序

#### 2.1 简介

一、微信小程序核心定义与特点

- 官方定位：微信小程序是一种 “新的开放能力”，核心优势体现在两大维度：
  1. **传播与获取**：可在微信内便捷获取（如搜索、扫码、分享）和传播，无需独立下载安装；
  2. **使用体验**：具备接近原生 APP 的流畅体验，解决传统 H5 页面加载慢、交互差的问题。
- **核心载体**：依赖微信生态运行，开发者可通过**微信公众平台**（官方指定平台）了解完整开发规范与能力。

二、小程序注册主体与权限差异

微信小程序支持多类型主体注册，不同主体对应不同功能权限，核心区别如下：

| 注册主体类型                  | 核心特点                         | 关键权限限制                                             |
| ----------------------------- | -------------------------------- | -------------------------------------------------------- |
| 个人                          | 注册门槛低，无需企业资质         | **无支付权限**，无法开发涉及交易、付费的功能             |
| 企业 / 政府 / 媒体 / 其他组织 | 需提供对应资质（如企业营业执照） | 支持开通支付、地图、即时通讯等高级权限，可开发商业化功能 |

- 核心结论：若开发需支付功能的小程序（如《苍穹外卖》的订单支付模块），必须以企业及以上主体注册。

三、微信官方提供的开发支持资源

为降低开发门槛，微信官方提供了全套工具与文档，核心资源包括：

1. **完善的开发文档**：涵盖 API、组件、框架、权限等所有开发细节，是开发核心参考；
2. **专属开发者工具**：集成代码编辑、模拟器、调试器、预览发布等功能，是小程序开发的必备工具（后续课程会讲解安装配置）；
3. **设计指南**：规范小程序的界面风格、交互逻辑，确保符合微信生态的用户习惯；
4. **体验 Demo**：提供官方示例小程序，可直观体验小程序的功能边界（如界面组件、API 能力）。

四、小程序从开发到上线的核心流程

小程序需经过 “注册 - 配置 - 开发 - 审核 - 上线” 5 个关键步骤，具体流程如下：

1. **注册小程序**：在微信公众平台完成主体信息提交，获取唯一的小程序 AppID（开发与上线的核心标识）；
2. **完善小程序信息**：配置小程序名称、头像、介绍、服务范围（如 “餐饮外卖”）等基础信息，需符合微信平台规范；
3. **本地开发**：使用微信开发者工具编写代码，实现业务功能（如《苍穹外卖》的商品浏览、下单功能）；
4. **提交审核**：将开发完成的代码上传至微信平台，等待官方审核（审核重点包括合规性、功能完整性、用户体验）；
5. **发布上线**：审核通过后，开发者可选择 “正式发布”，发布后所有微信用户可搜索、使用该小程序。



#### 2.2 小程序开发

一、微信小程序开发整体认知

1. **技术定位**：小程序开发本质属于**前端开发**，核心使用 **JavaScript（JS）** 语言，搭配小程序专属的页面结构、样式文件，适合有基础前端知识或后端开发者快速入门了解。
2. **学习目标**：本课程面向后端开发者，因此小程序开发以 “了解核心流程与结构” 为目标，无需深入前端复杂语法。

二、微信小程序核心目录结构

小程序目录分为 “**主体配置（根目录）** ” 和 “**页面配置（pages 子目录）** ” 两部分，文件位置和作用有明确规范：

1. 主体配置文件（根目录，控制整个小程序）

​	根目录下必须包含 3 个核心文件（部分可选），负责小程序的全局逻辑、配置和样式，具体如下：

| 文件名称   | 是否必须 | 核心作用                                                     | 类比前端技术           |
| ---------- | -------- | ------------------------------------------------------------ | ---------------------- |
| `app.js`   | 是       | 小程序**全局逻辑代码**，如初始化生命周期、全局变量、全局方法等 | JavaScript（JS）       |
| `app.json` | 是       | 小程序**全局配置文件**，如页面路径注册、窗口样式（标题栏、导航栏）、网络超时等 | 无直接类比（专属配置） |
| `app.wxss` | 否       | 小程序**全局样式表**，定义所有页面共享的样式（如字体、颜色、布局） | CSS（层叠样式表）      |

- 关键说明：`app.json` 是 “页面注册入口”，所有需要展示的页面必须在该文件的 `pages` 数组中配置路径，否则无法访问。

2. 页面配置文件（pages 子目录，控制单个页面）

​	小程序的每个页面（如首页、购物车、详情页）需放在 `pages` 子目录下，每个页面单独成一个文件夹，且由 4 个文件组成（部分可选），负责单个页面的逻辑、结构、配置和样式，具体如下：

| 文件名称      | 是否必须 | 核心作用                                                     | 类比前端技术           |
| ------------- | -------- | ------------------------------------------------------------ | ---------------------- |
| `页面名.js`   | 是       | 当前页面**局部逻辑代码**，如页面生命周期（加载、显示、隐藏）、事件处理（点击、输入） | JavaScript（JS）       |
| `页面名.wxml` | 是       | 当前页面**结构布局**，定义页面的 UI 元素（如按钮、文本、图片、列表） | HTML（超文本标记语言） |
| `页面名.json` | 否       | 当前页面**局部配置**，可覆盖 `app.json` 的全局配置（如单独设置本页面标题栏颜色） | 无直接类比（专属配置） |
| `页面名.wxss` | 否       | 当前页面**局部样式表**，定义仅作用于本页面的样式，优先级高于 `app.wxss` | CSS（层叠样式表）      |

- 示例结构：若有一个 “首页（index）”，则 `pages` 目录下会有 `index` 文件夹，内部包含 `index.js`、`index.wxml`、`index.json`（可选）、`index.wxss`（可选）4 个文件。
- 关键说明：`页面名.wxml` 使用小程序专属标签（如 `<view>` 对应 HTML 的 `<div>`、`<text>` 对应 `<span>`），语法与 HTML 类似但有差异。

三、小程序页面开发核心语法

1. 页面结构：WXML 语法（类比 HTML）

- **核心标签**：`view`标签等同于 HTML 的`div`，用于包裹页面元素（如文本、图片），是布局的基础容器；`image`标签用于展示图片，需通过`src`属性指定图片地址。
- **动态数据绑定**：采用 “差值表达式”`{{ 变量名 }}`实现页面与数据的联动，例如在`index.wxml`中写`<view>{{ message }}</view>`，即可动态展示`index.js`中定义的`message`变量值。

2. 页面数据管理：Page 对象的`data`属性

- 数据定义：在页面的`index.js`中，通过`Page({ data: { 变量名: 值 } })`定义页面所需数据，例如：

  ```javascript
  Page({
    data: {
      message: "Hello World", // 文本变量
      nickname: "", // 用于存储用户昵称
      avatarUrl: "" // 用于存储用户头像地址
    }
  })
  ```

- **数据更新**：需通过小程序内置方法`this.setData({ 变量名: 新值 })`修改数据，修改后页面会自动刷新（不可直接用`this.data.变量名 = 新值`，否则页面不更新）。

3. 页面样式：WXSS 语法（类比 CSS）

- 语法与 CSS 基本一致，支持`width`、`height`、`color`等常见样式属性，可直接在标签内通过`style`属性写内联样式（如`<image style="width:100px; height:100px;" />`），或在`index.wxss`中写类选择器样式。
- 样式作用域：页面专属的`index.wxss`仅作用于当前页面，全局`app.wxss`作用于所有页面，若样式冲突，页面样式优先级更高。

三、小程序事件绑定与交互：按钮操作与事件处理

1. 按钮组件（`button`）的使用

- 核心属性:`type`属性控制按钮样式，支持 3 种预设类型：
  - `default`：默认样式（灰色背景，绿色文字）
  - `primary`：主要样式（绿色背景，白色文字，常用作核心操作按钮）
  - `warn`：警告样式（红色文字，用于危险操作如 “删除”）
- **示例代码**：`<button type="primary" bindtap="getUserInfo">获取用户信息</button>`，点击按钮会触发`getUserInfo`方法。

2. 事件绑定：`bindtap`绑定点击事件

- **绑定语法**：在组件（如`button`）上通过`bindtap="方法名"`绑定点击事件，方法需在页面的`index.js`中定义（与`data`同级）。

- 事件方法定义：例如定义 “获取用户信息” 的方法：

  ```javascript
  Page({
    data: { /* 数据定义 */ },
    // 点击按钮触发的方法
    getUserInfo: function() {
      // 方法逻辑（如调用微信API获取用户信息）
    }
  })
  ```



#### 2.3 微信小程序登录

 一、核心参与角色

微信登录流程涉及 3 个关键角色，各角色职责明确且协同工作，是理解流程的基础：

1. **微信小程序端**：用户交互入口，负责触发登录、获取临时授权码（code）、存储自定义登录状态（token）。
2. **开发者服务器（后端服务）**：开发者自主开发的服务（如基于 SpringBoot/SSM 的 Java 后端），负责接收 code、调用微信接口、生成 token、维护用户信息。
3. **微信接口服务**：微信官方提供的登录接口服务，负责验证 code 合法性、返回用户唯一标识（openid）和会话密钥（session_key）。

二、完整登录流程（7 步标准链路）

流程严格遵循微信官方规范，每一步的输入、输出和核心操作明确，缺一不可：

| 步骤 |   执行角色   |                           核心操作                           |                     关键参数 / 返回结果                      |
| :--: | :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  1   | 微信小程序端 |                     调用`wx.login()`方法                     |   输出：**临时授权码（code）**（有效期短，仅能使用 1 次）    |
|  2   | 微信小程序端 |  调用`wx.request()`发送 HTTP 请求，将 code 传给开发者服务器  |            输入：code；输出：无（仅完成请求传递）            |
|  3   | 开发者服务器 |      接收小程序请求，提取 code，准备调用微信接口的参数       | 输入：code；准备参数：`appid`（小程序唯一标识）、`appsecret`（小程序密钥）、code |
|  4   | 开发者服务器 |    通过**HttpClient**发送 GET 请求，调用微信官方登录接口     | 请求地址：微信官方登录接口（需按官方文档配置）；参数：`appid`、`appsecret`、`code`、`grant_type=authorization_code`（固定值） |
|  5   | 微信接口服务 |               验证参数合法性，返回用户核心信息               | 输出：**openid**（用户唯一标识，核心）、`session_key`（会话密钥，可选） |
|  6   | 开发者服务器 | 自定义登录状态：1. 将 openid 存入数据库（关联用户信息）2. 生成**token**（令牌，用于后续身份验证） |                  输出：token（传给小程序）                   |
|  7   | 微信小程序端 |   接收 token，存入`storage`（本地存储），用于后续业务请求    | 存储：token；后续使用：发起购物车、下单等请求时，携带 token 证明身份 |

三、关键概念与注意事项

1. 核心概念解析

- code（临时授权码）：小程序通过`wx.login()`获取的临时凭证，作用是 “桥接” 小程序与微信接口服务，仅有效 1 次，使用后立即失效（课程中通过 Postman 重复提交同一 code 验证了失效机制）。
- openid（用户唯一标识）：微信用户在当前小程序中的唯一 ID（不同小程序的 openid 不同），是开发者服务器识别用户的核心依据，需持久化存储（如存入 MySQL）。
- token（自定义令牌）：开发者服务器生成的身份凭证，替代 openid 在后续业务中传递（避免直接暴露 openid），需设置有效期（如 2 小时），后续请求通过解析 token 获取用户身份。
- appid 与 appsecret：小程序的 “账号密码”，需从微信公众平台获取，必须妥善保管（禁止前端暴露，仅在后端使用）。

2. 实战注意事项

- **code 的时效性**：必须在获取 code 后尽快调用微信接口，且不可重复使用，失效后需重新调用`wx.login()`获取新 code。
- **接口调用方式**：开发者服务器调用微信接口必须使用**GET 方式**，参数需严格匹配官方要求（参数名、数据类型不可错）。



## 第五章 缓存

### 第一节 问题

1. 问题背景

   当大量用户通过小程序查询菜品时，后端会频繁访问数据库，造成数据库压力过大、系统响应慢，进而降低用户体验。系统的查询性能瓶颈主要在数据库层面。

2. 解决方案：引入 Redis 缓存

   - Redis 基于内存存储数据，内存操作的性能远高于数据库的磁盘 IO 操作，通过缓存菜品数据可减少数据库查询次数。
   - **缓存核心逻辑**：优先查询 Redis 缓存，缓存中有数据则直接返回；缓存中无数据则查询数据库，再将查询结果存入缓存，供后续请求使用。

3. 缓存设计细节

   - **缓存粒度**：结合小程序按分类展示菜品的特点，以**菜品分类**为单位缓存数据，即一个分类对应一份缓存数据。
   - Redis 键值设计
     - Key：采用前缀 + 分类 ID 的形式（例如 `d_分类id`），便于区分不同分类的菜品缓存。
     - Value：将对应分类下的菜品集合对象序列化后，以 String 类型存储在 Redis 中。
   - **缓存一致性保障**：当数据库中的菜品数据发生变更（如修改价格、新增菜品）时，需要**及时清理对应分类的缓存数据**，避免出现缓存数据与数据库数据不一致的问题。



### 第二节 对原有代码的改进

1. 缓存的核心需求
   - 问题：用户频繁点击菜品分类时，会重复查询数据库，高并发场景下会导致数据库压力大、响应慢。
   - 解决方案：将菜品数据缓存到 Redis 中，减少数据库查询次数。
2. 缓存实现的核心思路（缓存穿透规避）
   - 后端接收到菜品查询请求后，**先查询 Redis 缓存**。
   - 若缓存中存在对应数据，直接返回缓存数据，无需访问数据库。
   - 若缓存中不存在数据，**查询数据库**，并将查询结果存入 Redis，供后续请求使用。
3. 缓存的代码改造要点
   - **确定改造位置**：改造用户端菜品列表查询的 Controller 层对应的 Service 逻辑（`user`包下的`DishController`的`list`方法）。
   - **Redis 的 key 设计**：按菜品分类缓存，key 的格式为 `dish_分类id`（如`dish_16`），确保不同分类的菜品数据隔离。
   - RedisTemplate 的使用
     - 注入`RedisTemplate`对象（项目需提前导入`spring-boot-starter-data-redis`依赖、配置 Redis 数据源、编写 Redis 配置类）。
     - 操作字符串类型：使用`opsForValue()`方法，`get(key)`获取缓存，`set(key,value)`存入缓存。
     - 数据类型：存入的是`List<DishVO>`集合对象，Redis 会自动序列化该对象进行存储，获取时直接强转为对应类型。
4. 功能测试验证
   - 第一次查询某分类菜品：Redis 无缓存，查询数据库并写入缓存，控制台会输出 SQL 语句。
   - 后续查询同一分类菜品：直接从 Redis 获取数据，控制台无 SQL 输出，验证缓存生效。



### 第三节 数据一致性

1. 缓存数据不一致的问题根源

   - 菜品数据缓存到 Redis 后，用户端查询会直接从 Redis 读取，提升性能。
   - 若管理端直接修改数据库数据（如修改菜品价格、状态），但未同步清理 Redis 缓存，会导致 Redis 数据与数据库数据不一致，用户端展示旧数据。

2. 需要清理缓存的业务操作场景

   当数据库中菜品数据发生变更时，必须清理对应缓存，涉及 4 类操作：

   - 新增菜品：新菜品需加入对应分类缓存，旧缓存无此数据。
   - 修改菜品：包括修改价格、分类等属性，可能影响 1 个或多个分类的缓存数据。
   - 删除菜品：需从缓存中移除对应菜品数据。
   - 菜品起售 / 停售：状态变更后，用户端应展示最新的可售 / 不可售状态。

3. 缓存清理的实现策略

   - **精准清理**：适用于新增菜品场景。新增菜品所属分类明确，直接构造该分类的缓存 `key`（格式为 `dish_分类id`），通过 `RedisTemplate` 删除对应缓存，避免清理无关数据。
   - 批量清理：适用于修改、删除、起售 / 停售菜品场景。
     - 这些操作可能涉及多个分类的缓存，精准清理需额外查询数据库判断影响范围，性价比低。
     - 直接删除所有以 `dish_` 开头的缓存 `key`，实现简单高效。
   - **代码优化**：抽取通用的缓存清理方法（如 `cleanCache(String pattern)`），通过 `RedisTemplate.keys(pattern)` 获取匹配的所有 `key`，再批量删除，提升代码复用性和规范性。

4. 技术实现要点

   - 注入 `RedisTemplate` 操作 Redis 缓存。
   - Redis 的 `delete` 方法不支持通配符，需先通过 `keys` 方法获取匹配的 `key` 集合，再批量删除。
   - 缓存清理逻辑写在**管理端接口**中，因为数据变更操作仅在管理端触发。



### 第四节 spring cache

1. Spring Cache 核心定位
   - Spring Cache 是 Spring 提供的**基于注解的缓存框架**，核心作用是简化缓存代码开发，使用方式类似 Spring 的事务管理注解。
   - 该框架仅提供**抽象层**，底层可切换不同的缓存实现，常见的有 EHCache、Caffeine、Redis，本项目中采用 Redis 作为缓存实现。
   - 项目中集成 Spring Cache 只需导入 `spring-boot-starter-cache` 依赖，若要使用 Redis 作为底层实现，额外导入 Spring Data Redis 依赖即可，无需额外配置。
2. Spring Cache 常用注解
   - `@EnableCaching`：作用是**开启缓存注解功能**，需添加在 Spring Boot 启动类上。
   - `@Cacheable`：添加在方法上，执行方法前会先查询缓存。若缓存中有数据，直接返回缓存数据；若没有，执行方法并将返回值存入缓存，与手动实现的 “查缓存 - 查数据库 - 存缓存” 逻辑一致。
   - `@CachePut`：添加在方法上，**只将方法返回值存入缓存，不会查询缓存**，这是它与 `@Cacheable` 的核心区别。
   - `@CacheEvict`：添加在方法上，用于**删除缓存中的一条或多条数据**，实现缓存清理。
3. Spring Cache 核心前置步骤
   - **开启缓存注解功能**：在 Spring Boot 启动类上添加 `@EnableCaching` 注解，这是使用 Spring Cache 注解的前提。
   - **注解使用位置**：Spring Cache 的缓存注解（如 `@CachePut`）一般添加在 **Controller 层的业务方法**上，用于关联业务操作和缓存操作。





#### 4.1 @CachePut 注解的使用

- **核心作用**：将**方法的返回值**存入指定缓存中，适用于新增、更新业务场景（如用户新增），实现数据库和缓存的同步更新。

- 关键属性

  - `cacheNames`：指定**缓存名称**，值为自定义字符串，建议与业务相关（如用户缓存设置为 `userCache`）。
  - `key`：指定缓存的 Key，需通过 **SpEL 表达式**动态生成，保证 Key 的唯一性。

- **应用场景**：以新增用户为例，在 `save` 方法上添加 `@CachePut`，方法执行后将返回的 `User` 对象存入 Redis。

- Redis 中缓存 Key 的生成规则

  - Spring Cache 存入 Redis 的 Key 格式为：`cacheNames::key`
  - 示例：若 `cacheNames="userCache"`，`key` 为用户 id（如 1），则最终 Redis 中的 Key 为 `userCache::1`。
  - Redis 可视化工具会将 Key 按冒号分层展示为树形结构，多个冒号会生成空层级（如 `userCache::1` 会显示为 `userCache` → `empty` → `1`）。

- SpEL 表达式动态生成 Key 的多种写法

  SpEL（Spring Expression Language）是 Spring 表达式语言，支持在注解中动态取值，以下是针对`save(User user)`方法生成 Key（用户 id）的 5 种写法，效果完全一致：

  | 写法               | 说明                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | `#user.id`         | 直接通过**方法参数名**取值，参数名需与方法形参（`user`）保持一致 |
  | `#result.id`       | 通过 `#result` 引用**方法返回值**，返回值为 `User` 对象，直接取其 `id` 属性 |
  | `#p0.id`           | 通过 `#p+索引` 引用方法参数，索引从 0 开始，`#p0` 代表第一个参数（`user`） |
  | `#a0.id`           | 通过 `#a+索引` 引用方法参数，作用与 `#p0` 一致，是另一种参数索引写法 |
  | `#root.args[0].id` | 通过 `#root.args[索引]` 引用方法参数数组，`args[0]` 代表第一个参数（`user`） |

  - **推荐写法**：`#user.id`，语义最直观，与参数名直接关联，便于理解和维护。



#### 4.2@Cacheable 注解作用与使用

1. @Cacheable 注解作用与使用
   - 核心功能：方法执行前，先查询缓存中是否存在对应数据。
     - 若缓存存在数据：直接返回缓存数据，**不执行目标方法**（视频中不会调用 `getById` 方法，也不会查询数据库）。
     - 若缓存不存在数据：执行目标方法查询数据库，再将返回结果存入缓存，供后续查询使用。
   - 使用要点
     - 需指定 `cacheNames`，且要与存入缓存时的 `cacheNames` 保持一致，确保能命中同一组缓存。
     - 动态 `key` 的 SpEL 表达式需匹配方法**形参**（如 `getById` 方法形参为 `id`，则 `key` 配置为 `#id`）。
     - 该注解不能使用 `#result` 关键字（源码未支持），与 `@CachePut` 存在区别。
2. Spring Cache 底层原理
   - 基于**代理技术**实现：添加缓存注解后，Spring 会为目标类（如 Controller）生成代理对象。
   - 方法调用时，会先经过代理对象的逻辑：优先查询缓存，再决定是否执行目标方法。



#### 4.3 @CacheEvict

1. @CacheEvict 注解的核心作用

   该注解用于清理缓存数据，保证缓存与数据库数据的一致性。当数据库中的数据被删除后，通过此注解可以同步删除对应的缓存数据。

2. @CacheEvict 单条缓存清理

   - 配置参数：通过 `cacheNames` 指定要操作的缓存名称，通过 `key` 动态指定要清理的缓存键。
   - 示例场景：在 `deleteById` 方法上添加该注解，`key` 取值为方法入参 `id`，即可根据主键清理对应缓存数据。
   - 实现原理：Spring Cache 生成代理对象，在目标方法执行完毕后，根据配置的 `cacheNames` 和 `key` 计算出缓存标识，进而操作 Redis 删除对应缓存。

3. @CacheEvict 批量缓存清理

   - 配置参数：指定 `cacheNames`，同时设置 `allEntries = true`，无需配置 `key`。
   - 示例场景：在 `deleteAll` 方法上添加该注解，可删除 `cacheNames` 指定的缓存名称下的**所有缓存数据**。
   - 适用场景：当需要清空某一类缓存数据（如所有用户相关缓存）时使用。

4. 缓存清理的执行时机

   缓存清理操作在目标方法执行完毕后触发，因此在方法执行过程中，缓存数据仍会存在，方法执行完成后才会被删除。





## 第六章 添加购物车

### 第一节 需求分析

1. 需求分析

   - **购物车的核心作用**：外卖系统中用于暂时存放用户所选的菜品和套餐，与线下超市购物车功能一致。
   - 添加购物车的操作逻辑
     - 套餐：直接点击加号即可添加。
     - 菜品：分两种情况，无口味数据的菜品直接点击加号添加；有口味数据的菜品需先选择规格（口味），再点击 “加入购物车” 按钮。
     - 重复添加：同一商品再次添加时，直接在购物车中对商品数量加 1，无需重复生成记录。

2. 接口设计

   - **请求方式**：POST（属于新增类操作）。

   - **请求路径**：`/user/shoppingCart/add`，前缀`/user`表明是用户端接口，`shoppingCart`为业务模块名，`add`标识添加操作。

   - 请求参数

     ：采用 JSON 格式通过请求体传递，包含三个参数：

     - 菜品 id（dishId）
     - 套餐 id（setmealId）
     - 口味（flavor，仅菜品有口味时传递）

   - **参数规则**：每次添加只能传递菜品 id 或套餐 id 其中一个，二者互斥。

   - **返回结果**：统一返回`code`（状态码）、`data`（数据）、`message`（消息）三项数据。

3. 数据库设计

   - **表名**：购物车表（shopping_cart）。
   - 核心字段
     - 主键 id：自增，唯一标识购物车记录。
     - 用户 id（user_id）：区分不同用户的购物车，实现购物车数据隔离。
     - 菜品 id（dish_id）、套餐 id（setmeal_id）：存储商品标识，二者互斥，分别对应菜品和套餐。
     - 口味（flavor）：存储菜品的口味信息。
     - 数量（number）：存储商品的购买数量。
   - 冗余字段设计
     - 冗余字段：商品名称（name）、商品图片路径（image）、商品单价（amount）、创建时间（create_time）。
     - 设计目的：这三个字段在菜品表 / 套餐表中已存在，在购物车表中冗余存储是为了**避免多表联查**，直接通过购物车表单表查询即可获取商品展示所需的名称、图片、价格，提升查询速度。
     - 使用原则：冗余字段需满足**相对稳定、不经常变化**的特点，否则会增加数据同步成本。



## 第七章 用户下单

### 第一节 需求分析

1. 用户下单需求分析
   - **核心目标**：用户通过下单通知商家备货发货，生成包含商品、金额、收货信息的订单数据。
   - 订单数据来源
     - 商品及数量：来自用户购物车（前期已实现购物车增删查功能）。
     - 订单总金额：由菜品费用（商品单价 × 数量累加）、餐盒费（1 元 / 商品）、配送费（固定 6 元）构成，前后端均可计算。
     - 用户收货信息（姓名、地址、手机号）：来自用户地址簿（前期已实现地址簿导入功能）。
     - 备注、餐具数量：由用户在下单页面填写，需前端提交。
2. 用户点餐完整业务流程
   1. 将商品添加到购物车
   2. 点击结算，跳转至提交订单页面，选择收货地址，确认商品明细、费用
   3. 点击支付，跳转至订单支付页面，此时生成**未支付状态**的订单数据
   4. 完成支付，跳转至下单成功界面
3. 用户下单接口设计
   - **请求方式**：POST（本质是新增订单数据）
   - **请求路径**：`/user/order/submit`（前缀区分用户端操作，路径见名知意）
   - 请求参数
     - 必传参数：地址簿 id、备注、餐具数量
     - 可选参数：打包费、订单总金额（前端不传则后端计算）
     - 无需传参：商品明细（从购物车查询）、配送费（固定 6 元）
   - **返回结果**：需包含下单时间（用于前端计算支付倒计时）、订单总金额、订单号、订单 id（用于后续支付功能）
4. 接口设计的通用思路
   - 依据产品原型分析参数和返回数据，页面需要什么数据，接口就提供什么数据。
   - 项目开发中接口、代码、数据库结构并非一蹴而就，需多次迭代优化。