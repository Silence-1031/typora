#苍穹外卖一

## 第一章 软件整体介绍

### 第一节 软件开发

一、软件开发核心流程（企业标准）

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251122191127586.png" alt="image-20251122191127586" style="zoom: 67%;" />

企业开发软件需遵循固定流程，确保项目有序推进，共分为 5 个阶段，各阶段任务与输出物明确：

|   阶段   |                          核心任务                          |                          关键输出物                          |
| :------: | :--------------------------------------------------------: | :----------------------------------------------------------: |
| 需求分析 |       明确项目目标、业务效果；梳理功能边界与性能要求       | 《需求规格说明书》（Word 文档，含系统定义、硬件 / 软件环境、功能 / 性能需求）<br>产品原型（静态网页，直观展示功能界面与数据录入项，如 “新增员工” 原型） |
| 设计阶段 | 将需求转化为技术方案，涵盖界面、数据存储、接口交互三个层面 | UI 设计（页面效果图、按钮样式、布局、人机交互逻辑）<br>数据库设计（表结构、字段类型、表间关系）<br>接口设计（请求方式、路径、参数、返回数据格式，如登录接口） |
| 编码阶段 |        开发人员实现代码逻辑，同时自我验证代码正确性        | 项目源代码（前后端功能代码）<br>单元测试（开发人员自测代码，确保功能有效） |
| 测试阶段 |        测试人员验证项目功能完整性、稳定性，排查 bug        | 测试用例（覆盖核心场景的测试步骤）<br>测试报告（记录测试结果，标注 bug 与修复情况） |
| 上线运维 |          搭建正式服务环境，部署项目并保障稳定运行          | 软件环境配置（服务器、数据库、中间件安装）<br>上线部署（项目正式对外提供服务） |

 

二、项目组角色分工

|      角色      |                           核心职责                           |    对应流程阶段    |
| :------------: | :----------------------------------------------------------: | :----------------: |
|    项目经理    | 整体项目管理：任务分配、进度把控、风险协调，对项目整体结果负责 | 全流程（统筹协调） |
|    产品经理    | 需求调研、梳理业务逻辑；输出调研文档与产品原型，确保需求准确传递 |    需求分析阶段    |
|   UI 设计师    | 设计用户界面效果，含页面布局、按钮样式、交互逻辑，保障用户体验 |      设计阶段      |
|     架构师     | 设计项目整体架构（如前后端分离架构）、选型技术栈（如 SpringBoot、SSM） |      设计阶段      |
| **开发工程师** |  编写前后端代码，实现业务功能；完成单元测试，确保代码正确性  |      编码阶段      |
|   测试工程师   | 编写测试用例，执行测试（功能 / 性能 / 兼容性测试）；输出测试报告，推动 bug 修复 |      测试阶段      |
|   运维工程师   | 搭建服务器环境（开发 / 测试 / 生产）；部署项目上线，保障线上服务稳定 |    上线运维阶段    |



 三、软件三大核心环境**（环境隔离）**

软件开发需区分不同环境，避免开发、测试、正式服务相互干扰，三者定位与用途差异显著：

| 环境类型 |  英文标识   |                           核心用途                           |       访问权限       |             数据特点             |
| :------: | :---------: | :----------------------------------------------------------: | :------------------: | :------------------------------: |
| 开发环境 | Development | 开发人员编写、调试代码；团队共享局域网内数据库（或本地数据库） |  仅开发团队内部访问  |    数据为测试数据，可随意修改    |
| 测试环境 |   Testing   | 测试人员执行测试用例，验证功能完整性；开发人员修复测试中发现的 bug | 开发 / 测试团队访问  |   数据模拟真实场景，需保持干净   |
| 生产环境 | Production  |        正式对外提供服务（如用户使用 “苍穹外卖” 下单）        | 全量用户访问（公开） | 数据为真实业务数据，严禁随意操作 |

**环境流转逻辑：**开发环境编码完成 → 部署到测试环境测试 → 测试通过后，部署到生产环境正式上线，确保线上服务稳定。



### 第二节 项目介绍

一、项目整体认知：定位、用户与功能架构

1. 项目定位

​	专为餐饮企业（餐厅、饭店等）定制的外卖管理系统，分为**管理端**（面向商家）和**用户端**（面向 C 端点餐用户），覆盖 “商家运营管理” 与 “用户点餐消费” 全流程。

2. 核心用户

- **商家端用户**：餐饮企业员工（如管理员、收银员），负责店铺运营与订单管理；
- **C 端用户**：普通消费者，通过小程序完成点餐、支付、查订单等操作。

3. 功能架构（分端拆解）

（1）管理端功能模块

|   功能模块   |                           核心作用                           |
| :----------: | :----------------------------------------------------------: |
|   员工管理   |   维护餐厅内部人员信息（新增、修改、禁用 / 启用员工账号）    |
|   分类管理   |     管理菜品 / 套餐的分类（如 “热菜”“主食”“下午茶套餐”）     |
|   菜品管理   | 维护菜品信息（新增、修改、下架、起售，控制菜品是否对外展示） |
|   套餐管理   |         维护套餐信息（调整价格、新增套餐、停售套餐）         |
|   订单管理   | 监控全量订单状态（待接单、待派送、已完成、已取消等，支持按状态筛选） |
|    工作台    |  展示当日核心数据（今日营业额、有效订单数、待处理订单汇总）  |
|   数据统计   | 多维度数据分析（近一个月营业额、用户数量、订单量、菜品销量排名） |
|   来单提醒   |         用户下单后触发语音播报 + 文字提示，避免漏单          |
| 营业状态设置 |         控制店铺 “营业 / 打烊”，打烊后用户端无法点餐         |

（2）用户端功能模块

|    功能模块    |                           核心作用                           |
| :------------: | :----------------------------------------------------------: |
|  微信授权登录  |   基于微信小程序授权，无需单独注册，直接获取用户昵称、头像   |
|    商品浏览    |    查看商家展示的菜品 / 套餐（按分类筛选，支持查看详情）     |
|   购物车管理   |     添加商品、删除商品、清空购物车，实时计算选中商品总价     |
| 在线下单与支付 |          提交订单并完成微信支付（对接微信支付接口）          |
|  历史订单查询  | 查看过往订单记录，支持按订单状态（待支付、待接单、已完成等）筛选 |
|    地址管理    |             维护多个收货地址，下单时选择一个使用             |
|    用户催单    |         订单提交后若商家长时间未接单，可发起催单提醒         |

二、产品原型：开发的 “视觉依据”

1. 产品原型的定义与价值

- **定义**：由产品经理设计的静态 HTML 页面，直观展示项目功能的 “最终视觉效果”（非真实功能，仅用于业务演示）；
- **价值**：作为开发人员的核心参考，确保开发的功能与产品设计一致，避免业务理解偏差。

2. 分端原型核心特点

（1）管理端原型

- 页面结构：左侧为功能菜单（如员工管理、订单管理），右侧为数据展示区；
- 关键交互展示：登录页（输入用户名 / 密码）、员工管理页（新增 / 删除按钮）、订单管理页（多状态标签页）、工作台（当日数据汇总）、营业状态切换按钮（营业 / 打烊）。

（2）用户端原型

- 核心场景展示：
  - 授权登录页（弹窗请求微信授权）；
  - 商品列表页（区分 “无商品”“有商品”“商家打烊” 三种状态，打烊时无 “加购按钮”）；
  - 购物车弹窗（展示选中商品，支持 “去结算” 跳转）；
  - 历史订单页（标注订单状态触发条件与页面展示规则）；
- 细节说明：原型中附带文字注释（如订单状态含义、按钮交互逻辑），需开发前仔细阅读。



三、技术选型：项目开发的 “技术栈清单”

技术选型由架构师确定，覆盖 “用户层→网关层→应用层→数据层→工具” 全链路，具体如下：

|      技术层级      |                   涉及技术 / 框架 / 中间件                   |                           核心作用                           |
| :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| **用户层**（前端） |       Node.js、Vue.js、Element UI、微信小程序、ECharts       | Vue.js+Element UI：开发管理端前端页面；- 微信小程序：开发用户端；<br>ECharts：实现数据统计模块的图表（如营业额趋势图） |
|     **网关层**     |                            Nginx                             | 实现反向代理（隐藏后端服务地址）与负载均衡（分发请求到多个后端服务） |
| **应用层**（后端） | Spring Boot、Spring MVC、Spring Task、HttpClient、Spring Cache、JWT、阿里云 OSS、Swagger、POI、WebSocket | Spring Boot+Spring MVC：搭建后端服务框架；<br>Spring Task：实现定时任务（如订单超时自动取消）；<br>HttpClient：发送 HTTP 请求（如调用第三方接口）；<br>Spring Cache：简化缓存操作（配合 Redis 使用）；<br>JWT：实现用户登录认证（生成 / 验证令牌）；- 阿里云 OSS：存储项目中的图片（如菜品图片、套餐图片）；<br>Swagger：生成后端接口文档，支持在线接口测试；<br>POI：操作 Excel 文件（如导出运营数据报表）；<br>WebSocket：实现实时通信（如来单提醒、用户催单） |
|     **数据层**     |     MySQL、Redis、MyBatis、PageHelper、Spring Data Redis     | MySQL：存储核心业务数据（如用户信息、订单数据、菜品数据）；<br>Redis：作为缓存中间件（减轻 MySQL 压力，如缓存菜品列表）；<br>MyBatis：持久层框架，实现 MySQL 数据库操作；<br>PageHelper：MyBatis 分页插件，简化分页逻辑；<br>Spring Data Redis：简化 Java 代码操作 Redis 的 API |
|    **开发工具**    |                  Git、Maven、JUnit、Postman                  | Git：版本控制（管理代码提交、分支合并）；<br>Maven：项目构建与依赖管理（统一管理 jar 包）；<br>JUnit：单元测试框架（测试单个方法逻辑）；<br>Postman：接口测试工具（测试后端接口是否正常） |



### 第三节 前端项目环境

 一、项目整体架构（前后端分离）

作为企业级主流开发模式，项目明确划分 “前端” 与 “后端” 两大模块，需先建立整体认知：

| 模块     | 具体组成          | 技术栈 / 功能说明                              | 开发重点备注                   |
| -------- | ----------------- | ---------------------------------------------- | ------------------------------ |
| **前端** | 商家管理端（Web） | Vue + Element UI 开发，供商家管理菜品 / 订单等 | 代码已提供，无需开发，直接使用 |
|          | 用户端（小程序）  | 供用户点餐使用，对接后端服务                   | 后续开发到相关功能时再搭环境   |
| **后端** | 统一服务端        | Spring Boot 开发的 Java 应用，提供所有业务接口 | 项目核心开发内容               |

二、前端环境搭建核心：基于 Nginx 部署

因项目重点在后端开发，前端（管理端 Web）已提供打包好的代码，无需手动开发，仅需通过**Nginx 服务器**运行



### 第四节 后端环境项目

#### 4.1 整体架构

一、项目构建基础

本项目后端工程基于 **Maven** 实现，核心特点是采用 **分模块开发模式**，该模式能降低模块间耦合度、便于统一依赖管理，同时贴合企业级项目开发实际场景（企业中极少从零搭建项目，多在已有工程基础上迭代）。

二、整体项目结构（父工程 + 子模块）

项目以 `sky-take-out` 作为 **Maven 父工程**，聚合 3 个子模块，各模块职责清晰，具体结构如下：

|     工程 / 模块     |                           核心作用                           |                       关键内容 / 说明                        |
| :-----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 父工程 sky-take-out | 1. 统一管理项目所有依赖的版本（避免版本冲突）<br>2. 聚合所有子模块，实现整体工程管控 | 不直接存放业务代码，仅通过 `pom.xml` 维护依赖版本和模块聚合关系 |
|  子模块 sky-common  |  **公共依赖模块**，提供全项目可复用的通用类，被其他模块依赖  | 包含 7 类核心公共资源：<br>1. 常量类（项目通用常量定义）<br>2. 上下文类（项目上下文相关配置）<br/>3. 枚举类（业务枚举，如订单状态、菜品类型）<br/>4. 自定义异常类（统一异常体系）<br/>5. JSON 处理类（JSON 序列化 / 反序列化工具）<br/>6. 配置属性类（封装 Spring Boot 配置文件中的配置项为 Java 对象）<br/>7. 结果类（统一后端返回格式，如接口响应的状态码、数据、提示信息）<br/>8. 工具类（通用工具方法，如日期处理、字符串校验） |
|   子模块 sky-pojo   |           **数据模型模块**，定义项目所有数据载体类           | 包含 3 类核心数据模型，均属于 **POJO（普通 Java 对象，仅含属性 + get/set 方法）**，细分目的是明确数据用途：<br/>1. Entity（实体类）：与数据库表一一对应，字段与表字段完全匹配<br/>2. DTO（数据传输对象）：用于 **程序各层间数据传递**（如前端提交 JSON 数据，后端用 DTO 接收）<br/>3. VO（视图对象）：用于 **后端向前端展示数据**（如列表页、表单页所需数据，按需封装，避免返回冗余字段） |
|  子模块 sky-server  |       **核心业务服务模块**，实现后端所有业务逻辑与配置       | 包含项目运行和业务开发的核心资源：<br/>1. 配置文件（如 application.yml，配置数据库、Redis 等）<br/>2. 配置类（自定义 Spring 配置，如拦截器配置、Bean 注入）<br/>3. 业务层代码（Controller 控制层、Service 服务层、Mapper 数据访问层）<br/>4. 拦截器（如登录拦截、权限校验）<br/>5. Spring Boot 启动类（项目入口，标注 `@SpringBootApplication`） |

三、关键概念辨析（企业级开发必懂）

1. **POJO 与 Entity/DTO/VO 的关系**
   - POJO 是统称，指 “仅含属性、get/set 方法，无复杂业务逻辑” 的 Java 类；
   - Entity、DTO、VO 是 POJO 的 **功能细分**，通过命名和用途明确数据载体的场景，避免 “一个类用到底” 导致的逻辑混乱（如用 Entity 接收前端参数会暴露数据库表结构，用 VO 存储数据库数据会冗余字段）。
2. **分模块开发的优势**
   - 解耦：各模块职责独立，修改一个模块不影响其他模块（如修改 common 中的工具类，只需确保接口不变，其他依赖模块无需改动）；
   - 复用：common 模块的通用类可被 server、pojo 模块复用，避免重复编码；
   - 维护：依赖版本由父工程统一管理，升级依赖（如 Spring Boot 版本）只需修改父工程 `pom.xml`，无需逐个模块调整。



#### 4.2 git版本控制

一、Git 版本控制的核心逻辑

​	Git 通过**仓库（Repository）** 管理代码版本，核心分为两类仓库，二者协同实现代码的本地管理与远程共享：

- **本地仓库**：存储在开发者本地电脑的代码仓库，用于记录本地代码的修改、提交历史，可独立完成版本控制（如回滚、分支管理）。
- **远程仓库**：存储在远程服务器（如 Gitee、GitHub）的代码仓库，用于团队协作（多人共享代码）、备份代码（防止本地代码丢失）。

二、关键前置文件：.gitignore（Git 忽略文件）

​	在使用 Git 管理项目前，需通过`.gitignore`文件指定**不需要 Git 跟踪管理的文件 / 目录**，避免冗余文件（如编译产物、工具配置文件）占用仓库空间或干扰协作，视频中明确需忽略的内容如下：

| 需忽略的文件 / 目录                   | 类型        | 原因                                                         |
| ------------------------------------- | ----------- | ------------------------------------------------------------ |
| `target/`                             | 目录        | 项目编译后生成的目录，包含`.class`字节码文件，属于 “编译产物”，无需跟踪（可通过源码重新编译生成） |
| `.idea/`                              | 目录        | IntelliJ IDEA（开发工具）的配置目录，包含工具个性化设置，与项目核心逻辑无关 |
| `*.iml`                               | 文件        | IDEA 生成的项目配置文件（如`sky-take-out.iml`），仅用于工具识别项目结构，非项目必要文件 |
| 编译后的`.class`文件、测试类 / 测试包 | 文件 / 目录 | 测试代码或编译临时文件，不影响项目核心功能，无需纳入版本控制 |

三、后续开发的 Git 工作流

​	完成上述步骤后，后续开发需遵循 “**修改代码 → 本地提交（Commit） → 推送远程（Push）** ” 的流程：

1. 开发新功能 / 修复 bug 后，先提交到本地仓库（记录修改历史）；
2. 定期将本地提交推送到远程仓库，确保远程仓库代码与本地同步，避免代码丢失或协作冲突。

四、核心注意事项

1. **仓库目录选择**：创建本地仓库时，必须选中**项目根目录**（如`sky-take-out`），若选子目录（如`src/`），会导致部分项目文件无法被 Git 跟踪；
2. **.gitignore 生效时机**：`.gitignore`仅对 “未被 Git 跟踪的文件” 生效，若某文件已被 Git 跟踪（如误提交的`target/`目录），需先执行`git rm --cached 文件名/目录名`移除跟踪，再添加到`.gitignore`；
3. **远程仓库地址正确性**：粘贴远程仓库地址时，需确认地址无误（避免少输 / 多输字符），否则会导致推送失败；
4. **首次推送的分支创建**：由于远程仓库初始为空，首次推送时 Git 会自动在远程创建`master`分支（与本地主分支对应），后续推送会默认同步到该分支。



#### 4.3 项目核心技术与设计规范

1. 技术栈与核心组件

|      技术 / 组件      |            作用说明            |                        视频中应用场景                        |
| :-------------------: | :----------------------------: | :----------------------------------------------------------: |
|      Spring Boot      |  后端框架，简化项目配置与启动  |      项目基础框架，通过`SkyApplication`启动类一键启动。      |
|        MyBatis        | 数据访问层框架，实现数据库交互 | `EmployeeMapper`通过注解编写 SQL，查询员工信息（`select * from employee where username = ?`）。 |
| JWT（JSON Web Token） | 生成身份令牌，实现登录状态维持 | 登录成功后，通过`JwtUtils.createJWT()`生成令牌，封装到`EmployeeLoginVO`返回给前端。 |
|    全局异常处理器     |  统一捕获与处理异常，规范响应  | `GlobalExceptionHandler`捕获`AccountNotFoundException`（账号不存在）、`PasswordErrorException`（密码错误）等自定义异常。 |

2. 项目设计规范

（1）分层设计（MVC+Service）：严格遵循分层职责，各层功能边界清晰：

- **Controller**：接收前端请求，参数校验（如`EmployeeLoginDTO`接收账号密码），调用`Service`，封装响应结果（`Result.success(vo)`）。
- **Service**：实现核心业务逻辑（如账号存在性判断、密码比对、账号状态校验），调用`Mapper`操作数据库。
- **Mapper**：仅负责数据库查询 / 操作，不包含业务逻辑（如`getByUsername`根据用户名查员工）。
- **DTO/VO/PO**：数据传输与封装规范：
  - `DTO`（Data Transfer Object）：前端→后端的数据传输对象，如`EmployeeLoginDTO`（接收登录参数）。
  - `VO`（View Object）：后端→前端的数据传输对象，如`EmployeeLoginVO`（封装员工 ID、用户名、JWT 令牌）。
  - `PO`（Persistent Object）：数据库表映射实体，如`Employee`（与`employee`表字段一一对应）。

（2）SQL 编写规范

项目中 SQL 编写分两种场景，根据复杂度选择：

- **注解方式**：适用于简单 SQL（如单表查询、新增），直接在`Mapper`方法上用`@Select`/`@Insert`等注解编写，如`EmployeeMapper.getByUsername`。
- **XML 方式**：适用于复杂 SQL（如多表联查、动态 SQL，含`if`/`where`/`foreach`标签），后续项目开发中会涉及。

（3）配置属性管理

通过**配置属性类**（`@ConfigurationProperties`）封装配置文件参数，避免硬编码：

- 示例：`JwtProperties`类（位于`common.properties`包），通过`@ConfigurationProperties(prefix = "sky.jwt")`绑定`application-dev.yml`中`sky.jwt`下的配置（如`admin-secret-key`（JWT 密钥）、`admin-ttl`（令牌过期时间））。
- 优势：配置集中管理，修改配置无需改动代码，符合开闭原则。

（4）常量与异常设计

- **常量类**：统一管理业务常量，如账号状态（`0`= 禁用，`1`= 启用），避免魔法值（硬编码的数字 / 字符串），提高代码可读性。
- **自定义异常**：针对业务场景定义异常（如`AccountNotFoundException`），继承自`BaseException`，便于全局异常处理器统一捕获，且异常信息更精准。



#### 4.4 Nginx反向代理与负载均衡

一、Nginx 反向代理

1. 反向代理定义

反向代理是指**客户端（前端）不直接访问后端服务器，而是先请求 Nginx 服务器，再由 Nginx 将请求转发到后端目标服务器**的过程。

- 客户端视角：仅感知到 Nginx 的存在，无法直接访问后端服务；
- 核心作用：解决 “前后端请求路径不匹配”“后端服务隐藏” 等问题。

2. 登录请求的反向代理流程

以本次联调的登录请求为例，完整链路如下：

1. 前端发送请求：`localhost/api/employ/login`（目标：Nginx 服务器，端口 80）；
2. Nginx 接收请求后，根据配置规则，将请求**转发**到后端 Tomcat 服务器：`localhost:8080/admin/employ/login`；
3. 后端处理请求后，将响应结果返回给 Nginx；
4. Nginx 再将响应结果转发给前端，完成整个交互。

二、Nginx 反向代理的 3 大核心优势

|       优势       |                           具体说明                           |                          企业级价值                          |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   提高访问速度   | Nginx 可在自身层面缓存高频请求的响应数据（如静态资源、重复接口请求）；后续相同请求无需转发到后端，直接返回缓存数据。 |     减少后端服务器压力，降低请求响应时间，提升用户体验。     |
|   支持负载均衡   | 当后端部署多台服务器（集群）时，Nginx 可作为 “负载均衡器”，按指定规则（如轮询、权重）将大量请求**均匀分配给每台后端服务器**。 |  避免单台服务器因请求过载崩溃，保证系统高可用、高并发能力。  |
| 保障后端服务安全 | 企业项目中，后端服务通常部署在**内网（局域网）**，不直接暴露到互联网；前端只能通过 Nginx 这一个 “入口” 间接访问后端，后端服务 IP / 端口对外隐藏。 | 防止后端服务被直接攻击，降低安全风险（如恶意请求、端口扫描）。 |

三、负载均衡：概念与核心作用

1. 负载均衡定义

负载均衡是 Nginx 的延伸功能，指**将客户端发送的大量请求，按照预设策略（如轮询、权重）分配到后端多台服务器（集群）**，避免单台服务器负载过高。

2. 无 Nginx vs 有 Nginx 的负载差异

- 无 Nginx：前端只能固定访问某一台后端服务器，若该服务器故障，整个服务不可用；
- 有 Nginx：前端请求由 Nginx 统一分发，即使某台后端服务器故障，Nginx 可将请求转发到其他正常服务器，保证服务连续性。



4.5 Nginx配置

 一、Nginx 反向代理配置

反向代理是 Nginx 的核心功能之一，作用是将前端发送的特定请求转发到后端指定服务（如 Tomcat），解决前后端联调时的路径匹配、跨域等问题，核心配置围绕`nginx.config`文件展开。

1. 核心配置文件

所有反向代理配置均在 Nginx 的主配置文件 **`nginx.config`** 中编写，该文件通常位于 Nginx 安装目录的`config`文件夹下。

2. 关键配置项

反向代理的核心是通过`server`（虚拟主机）和`location`（请求匹配规则）定义转发逻辑，依赖`proxy_pass`指令指定后端目标地址，具体配置结构如下：

```nginx
# 定义虚拟主机（监听80端口，前端默认请求端口）
server {
    listen 80;  # 监听端口，与前端请求端口保持一致
    
    # 匹配请求路径中包含"api"的请求（如前端登录请求：localhost/api/employ/login）
    location /api/ {
        # 反向代理核心指令：将匹配的请求转发到后端服务地址
        proxy_pass http://localhost:8080/admin/; 
    }
}
```

3. 转发逻辑说明

以 “前端登录请求” 为例，完整转发流程如下：

1. 前端发送请求：`localhost/api/employ/login`（端口 80，路径含`api`）；
2. Nginx 通过`location /api/`匹配该请求；
3. `proxy_pass`将请求转发到后端地址`http://localhost:8080/admin/`，并自动追加前端请求中`api`后的动态路径（即`employ/login`）；
4. 最终后端接收的完整请求路径：`localhost:8080/admin/employ/login`，恰好匹配 Tomcat 中部署的登录接口，实现请求转发成功。

二、Nginx 负载均衡配置

负载均衡本质是 “多后端服务的反向代理”，通过分发请求到多台后端服务器，实现流量分摊、提高服务可用性，核心是通过`upstream`指令定义后端服务集群。

1. 核心配置结构

负载均衡需先通过`upstream`定义后端服务组，再在`location`中通过`proxy_pass`指向该服务组，具体配置如下：

```nginx
# 1. 定义后端服务集群（名称自定义，需与下方proxy_pass一致，例：my_server）
upstream my_server {
    # 后端服务1：IP+端口（如Tomcat服务，端口8080）
    server 192.168.100.128:8080;
    # 后端服务2：另一台同服务服务器
    server 192.168.100.129:8080;
}

# 2. 定义虚拟主机（与反向代理一致，监听80端口）
server {
    listen 80;
    
    # 匹配含"api"的请求
    location /api/ {
        # 转发到定义的后端服务集群（需加"http://"前缀）
        proxy_pass http://my_server/;
    }
}
```

2. 核心逻辑

- 前端请求仍通过`location /api/`匹配；
- `proxy_pass`不再指向单一后端地址，而是指向`upstream`定义的服务集群；
- Nginx 自动将请求分发到集群中的后端服务器，默认实现 “请求均衡分配”。

三、Nginx 负载均衡策略

负载均衡支持多种分发策略，可根据后端服务器性能、业务需求灵活配置

|         策略名称          |                           核心逻辑                           |                           适用场景                           |
| :-----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      1. 轮询（默认）      | 按请求顺序 “轮流分配” 给后端服务器（如：请求 1→服务 1，请求 2→服务 2，请求 3→服务 1） |            后端服务器硬件配置一致、性能均等的场景            |
|     2. 权重（weight）     | 为每台服务器设置权重值（如`server 192.168.100.128:8080 weight=9;`），权重越高，分配到的请求越多 | 后端服务器性能差异大（如高配服务器权重设为 9，低配设为 1，请求比例 9:1） |
|   3. IP 哈希（ip_hash）   | 根据客户端 IP 地址计算哈希值，固定将同一 IP 的请求分配到同一后端服务器 | 需保持客户端与服务器 “会话一致性” 的场景（如用户登录状态存储在特定服务器） |
| 4. 最少连接（least_conn） |      优先将请求分配给当前 “活跃连接数最少” 的后端服务器      |      后端服务器处理请求耗时差异大，需动态平衡负载的场景      |
|  5. URL 哈希（url_hash）  | 根据请求 URL 的哈希值，固定将同一 URL 的请求分配到同一后端服务器 | 需缓存静态资源（如图片、JS 文件），减少不同服务器间重复缓存的场景 |
|    6. 响应时间（fair）    | 优先将请求分配给 “响应时间最短” 的后端服务器（需额外模块支持） |       对服务响应速度要求高，需动态选择最优服务器的场景       |



#### 第五节 导入接口文档

一、理论认知：前后端分离开发核心逻辑

1. 前后端分离开发的核心价值

- **并行开发提效**：通过提前定义接口，前端开发人员可专注于页面渲染与交互逻辑，后端开发人员可专注于业务逻辑与数据处理，双方无需等待对方开发完成，大幅缩短项目周期。
- **职责边界清晰**：接口作为前后端交互的 “契约”，明确了请求地址、请求方式、请求参数格式、响应数据格式等关键信息，避免开发过程中因需求理解偏差导致的返工。

2. 前后端分离标准开发流程

<img src="C:\Users\Silence\AppData\Roaming\Typora\typora-user-images\image-20251123141208812.png" alt="image-20251123141208812" style="zoom:80%;" />

- 接口定义（核心前置步骤）：确定前后端交互的 “契约”，包括：
  - 请求层：请求地址（如`/admin/employee/login`）、请求方式（GET/POST/PUT/DELETE 等）；
  - 数据层：前端提交的参数格式（如 JSON 对象）、后端返回的响应格式（如包含`code`/`data`/`msg`的 JSON）；
  - 约束层：参数校验规则（如必填项、数据类型限制）、状态码含义（如 200 表示成功、400 表示参数错误）。
- **并行开发与自测**：前后端分别基于接口文档开发，开发过程中可通过接口测试工具（如 Postman）自测功能正确性。
- **联调验证**：双方开发完成后，联合验证数据交互是否正常（如前端参数能否被后端正确接收、后端响应能否被前端正确渲染）。
- **提测上线**：联调通过后，提交给测试人员进行全面测试，测试通过后部署上线。

3. 企业级接口设计的实际场景

- **设计周期长**：真实项目中，接口设计需前后端、产品经理多次沟通，需考虑业务扩展性、兼容性等问题，并非一次性确定。
- **动态调整**：开发或测试阶段可能发现接口设计缺陷（如参数缺失、响应格式不合理），需重新迭代接口文档并同步给所有相关人员。
- **课程简化处理**：因课程时间限制，本项目直接提供现成的接口文档（JSON 文件），后续开发中会补充分析接口设计思路，帮助学员锻炼接口设计能力。

二、实操步骤：YAPI 平台导入接口文档

1. 核心工具：YAPI 接口管理平台

YAPI 是企业常用的开源接口管理工具，支持接口文档的创建、导入、测试、版本控制等功能，可统一管理项目接口，方便团队协作。

2. 接口文档分类逻辑

本项目接口按 “用户角色” 分为两类，分别对应两个 JSON 文件，分类管理可提升接口查找效率：

- **管理端接口**：供后台管理员使用，如员工管理、菜品管理、订单统计等接口（共 47 个）；
- **用户端接口**：供普通用户使用，如地址簿管理、购物车操作、订单下单等接口（共 25 个）。



#### 第六节 Swagger

一、Swagger 的核心定位与价值

1. 解决的核心问题

- 替代传统工具（如 Postman）的低效问题：Postman 测试多参数接口时需手动构造大量参数，效率低；Swagger 可自动生成接口文档 + 在线测试页面，无需手动拼接参数。
- 后端开发阶段的 “文档 + 测试” 一体化工具：既避免手动编写接口文档的繁琐，又能直接在生成的页面中完成接口调试，减少跨工具操作成本。

2. 与 YApi 的区别（关键认知）

| 工具    | 定位阶段 | 核心作用                                      | 场景差异                     |
| ------- | -------- | --------------------------------------------- | ---------------------------- |
| YApi    | 设计阶段 | 管理、维护接口规范（前端与后端的 “接口契约”） | 前期定规范，供前后端参考开发 |
| Swagger | 开发阶段 | 帮助后端开发人员自动生成文档、快速测试接口    | 后期验功能，后端自测接口正确 |

- 两者定位互补，而非替代关系，实际项目中需同时使用。

二、Knife4j 框架（Swagger 的简化封装）

原生 Swagger 配置繁琐，NFJ 对其进行封装，提供 “增强解决方案”，简化配置步骤，降低使用门槛。

三、Nife4J 的核心使用流程

1. 第一步：导入 Maven 坐标（依赖配置）

- 核心操作：在项目的`pom.xml`文件中引入 NineFourJ 的依赖坐标（固定代码，无需手动编写，直接复制课件代码即可）。
- 作用：让 Spring 框架识别并加载 NineFourJ 相关功能，为后续生成文档做准备。

2. 第二步：编写配置类（核心配置）

在 Spring 配置类（如`WebMvcConfiguration`）中添加 2 个关键配置：

（1）配置 Docket 对象（生成文档的核心配置）

- 作用：定义接口文档的基础信息（标题、版本、描述），并指定需要扫描的 Controller 包路径。
- 核心代码逻辑：
  1. 创建`ApiInfo`对象：设置文档标题（如 “苍穹外卖项目接口文档”）、版本（如 “2.0”）、描述（如 “员工管理、菜品管理等接口测试”）。
  2. 创建`Docket`对象：指定 Swagger 版本（`Swagger2`）、关联`ApiInfo`对象，再通过`select().apis(RequestHandlerSelectors.basePackage("com.sky.controller"))`指定扫描的 Controller 包（必须准确，否则无法识别接口）。
  3. 加`@Bean`注解：让 Spring 自动创建并管理`Docket`对象，确保配置生效。

（2）配置静态资源映射

- 核心问题：Spring MVC 默认会拦截所有请求（包括访问 Swagger 文档页面的请求），若不配置静态资源映射，会导致文档页面（`doc.html`）无法访问。
- 解决代码：重写`addResourceHandlers`方法，将`/doc.html`（文档页面路径）和`/webjars/**`（页面依赖的静态资源路径）映射到类路径下的对应资源，避免被 Spring MVC 拦截。
- 代码关键：方法名`addResourceHandlers`不可自定义（继承自`WebMvcConfigurationSupport`父类，需重写固定方法名）。

3. 第三步：启动项目并访问文档页面

- 访问路径（固定）：`http://localhost:8080/doc.html`（8080 为项目端口，需根据实际配置调整）。
- 页面效果：左侧展示扫描到的 Controller（如`EmployeeController`）及其中的方法（如`login`、`logout`），右侧可查看接口详情（请求方式、参数结构、响应示例）。

四、Swagger核心注解

|      注解名称       |          作用层级          |                    核心用途                    |          常用属性          |
| :-----------------: | :------------------------: | :--------------------------------------------: | :------------------------: |
|       `@Api`        |    类（如 Controller）     |     描述整个类的功能定位，说明类的作用范围     | `tags`（标签，描述类功能） |
|     `@ApiModel`     |     实体类 / DTO / VO      |    说明数据模型的用途（如 “登录传输模型”）     | `description`（模型描述）  |
| `@ApiModelProperty` |  实体类 / DTO / VO 的属性  |            描述单个属性的含义、用途            |    `value`（属性说明）     |
|   `@ApiOperation`   | 方法（如 Controller 方法） | 描述单个接口方法的业务功能（如 “登录 / 退出”） |  `value`（方法功能说明）   |

```java
@Data
@ApiModel(description = "员工登录时传递的数据模型")
public class EmployeeLoginDTO implements Serializable {

    @ApiModelProperty("用户名")
    private String username;

    @ApiModelProperty("密码")
    private String password;

}
```



## 第二章 技术要点

### 第一节 新增员工

一、核心需求背景

新增员工功能的初始代码中，**创建人 ID（create_user）和修改人 ID（update_user）被写死为固定值**，不符合实际业务逻辑（应动态关联当前登录用户），需通过技术手段获取登录用户的真实 ID 并赋值。

二、JWT 认证流程：理解 “如何获取登录用户 ID” 的前提

| 角色 |                           关键操作                           |                           核心目的                           |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 前端 | 1. 登录时提交用户名 / 密码<br>2. 登录成功后保存 JWT Token<br>3. 后续请求在**请求头携带 Token** |                  实现身份认证与后续请求授权                  |
| 后端 | 1. 校验用户名 / 密码，生成含**用户 ID**的 JWT Token 并返回<br>2. 通过**Token 拦截器**拦截所有请求，校验 Token 合法性<br>3. Token 校验通过则放行，不通过返回 401（未授权） | 1. 生成含用户信息的 Token<br>2. 保障接口访问安全<br>3. 解析 Token 中的用户 ID |

关键细节：

- JWT Token 的 “承载信息”：登录成功生成 Token 时，会将**当前用户 ID（如 empId）存入 Token 的 claims（声明）中**（代码中通过`createJWT`方法传入含`empId`的 map 对象实现）。
- 拦截器的核心作用：Token 校验通过后，可在拦截器中**解析 Token 中的 empId**—— 这是获取 “当前登录用户 ID” 的关键节点。

三、ThreadLocal 技术：解决 “ID 跨层传递” 问题

1. 问题痛点

拦截器解析出用户 ID 后，需将其传递到 Service 层的`save`方法（用于给 create_user/update_user 赋值），但拦截器与 Service 层无直接调用关系，无法通过 “方法参数” 传递。

2. ThreadLocal 的核心特性

ThreadLocal 并非线程，而是**线程的 “局部存储空间”**，具备以下关键特性，恰好解决跨层传递问题：

- **线程隔离**：每个线程独享一份存储空间，不同线程的数据互不干扰（避免多用户请求时 ID 混淆）。
- **同线程共享**：同一请求对应的线程，从拦截器→Controller→Service→DAO 的全链路中，均可访问 ThreadLocal 中的数据（因一次请求对应一个独立线程）。
- **客户端发起的每一次请求，后端都会分配一个独立线程处理，该线程贯穿请求的全链路**—— 这是 ThreadLocal 能跨层传递数据的核心前提。

四、ThreadLocal 实战：代码封装与使用步骤

为简化 ThreadLocal 的操作，项目中通常封装为工具类（如`BaseContext`），核心步骤分 “存值”“取值”“删值” 三部分：

1. ThreadLocal 工具类封装（BaseContext）

封装`set`（存值）、`get`（取值）、`remove`（删值）方法，避免重复代码：

```java
public class BaseContext {
    // 定义ThreadLocal对象，泛型为用户ID的类型（如Long）
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    // 存值：将用户ID存入当前线程的局部空间
    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    // 取值：从当前线程的局部空间获取用户ID
    public static Long getCurrentId() {
        return threadLocal.get();
    }

    // 删值：避免内存泄漏（如请求结束后清理数据）
    public static void remove() {
        threadLocal.remove();
    }
}
```

2. 跨层传递 ID 的完整流程

步骤 1：拦截器中 “存值”

Token 校验通过后，解析 Token 中的 empId，调用`BaseContext.setCurrentId(empId)`，将 ID 存入 ThreadLocal：

```java
// 拦截器逻辑示例
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
    // 1. 从请求头获取Token
    String token = request.getHeader("token");
    // 2. 校验Token并解析出empId
    Claims claims = JwtUtil.parseJWT(token);
    Long empId = Long.valueOf(claims.get("empId").toString());
    // 3. 将empId存入ThreadLocal
    BaseContext.setCurrentId(empId);
    // 4. 放行请求
    return true;
}
```

步骤 2：Service 层 “取值”

在 Service 的`save`方法中，调用`BaseContext.getCurrentId()`获取用户 ID，赋值给员工对象的 create_user 和 update_user：

```java
// Service层save方法示例
public void save(Employee employee) {
    // 从ThreadLocal中获取当前登录用户ID
    Long currentId = BaseContext.getCurrentId();
    // 动态赋值
    employee.setCreateUser(currentId);
    employee.setUpdateUser(currentId);
    // 执行数据库插入操作
    employeeMapper.insert(employee);
}
```

步骤 3：（可选）请求结束后 “删值”

若使用 Spring 的拦截器，可在`afterCompletion`（请求完成后）调用`BaseContext.remove()`，避免线程复用导致的内存泄漏（如线程池中的线程重复使用时，数据残留）



### 第二节 分页查询

一、问题背景：日期格式展示异常

在员工分页查询的功能测试中，后端返回的`createTime`（创建时间）和`updateTime`（最后修改时间）（类型为`LocalDateTime`），在前端页面展示为**数组 / 非人类可读格式**（如时间戳拆分后的字段集合），不符合业务预期，需通过代码完善解决日期格式化问题。

二、核心解决方案：两种日期格式化方式

方案 1：局部注解方式（@JsonFormat）

1. 原理与作用：通过在实体类的日期属性上添加 Jackson 框架提供的`@JsonFormat`注解，**单独指定该属性的 JSON 序列化格式**，仅对当前注解标注的属性生效，属于 “局部配置”。

2. 代码实现：在`Employee`实体类的`LocalDateTime`类型属性上添加注解：

```java
import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

public class Employee {
    // 对createTime单独格式化（年月日时分秒）
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss") 
    private LocalDateTime createTime;
    
    // 未加注解，保持原格式（用于对比）
    private LocalDateTime updateTime;
    
    // 其他属性...
}
```

3. 优缺点

| 优点                                 | 缺点                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 实现简单，无需额外配置类             | 仅作用于单个属性，若多个实体类有日期属性，需重复添加注解，代码冗余 |
| 灵活度高，可针对不同属性设置不同格式 | 无法统一管理日期格式，后期维护成本高                         |

方案 2：全局配置方式（扩展 Spring MVC 消息转换器）

1. 原理与作用：Spring MVC 通过 “消息转换器”（`HttpMessageConverter`）处理后端与前端的数据交互（如 Java 对象→JSON）。通过**自定义消息转换器并注入 Spring 容器**，可全局统一处理所有`LocalDateTime`类型的序列化格式，属于 “全局配置”，是项目推荐方案。

2. 实现步骤（核心代码流程）

步骤 1：编写自定义 Jackson 对象转换器（处理日期序列化）

项目中通常会封装通用的 Jackson 配置类（如`JacksonObjectMapper`），继承 Jackson 的`ObjectMapper`，统一设置日期格式：

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class JacksonObjectMapper extends ObjectMapper {
    // 定义全局日期格式（年月日时分，可根据需求调整为"yyyy-MM-dd HH:mm:ss"）
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
    
    public JacksonObjectMapper() {
        // 1. 配置LocalDateTime的序列化器（Java对象→JSON字符串）
        LocalDateTimeSerializer localDateTimeSerializer = new LocalDateTimeSerializer(
            DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)
        );
        // 2. 配置LocalDateTime的反序列化器（JSON字符串→Java对象）
        LocalDateTimeDeserializer localDateTimeDeserializer = new LocalDateTimeDeserializer(
            DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)
        );
        
        // 3. 注册序列化器和反序列化器到ObjectMapper
        this.registerModule(new JavaTimeModule()
            .addSerializer(LocalDateTime.class, localDateTimeSerializer)
            .addDeserializer(LocalDateTime.class, localDateTimeDeserializer)
        );
    }
}
```

步骤 2：扩展 Spring MVC 消息转换器（注入自定义转换器）

创建 Spring MVC 配置类，继承`WebMvcConfigurationSupport`，重写`extendMessageConverters`方法，将自定义转换器加入 Spring 容器，并设置优先级：

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import java.util.List;

@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {

    // 扩展Spring MVC消息转换器
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 1. 创建自定义的消息转换器（基于Jackson）
        MappingJackson2HttpMessageConverter customConverter = new MappingJackson2HttpMessageConverter();
        // 2. 为转换器设置自定义的JacksonObjectMapper（处理日期格式）
        customConverter.setObjectMapper(new JacksonObjectMapper());
        // 3. 将自定义转换器加入容器，并设置索引为0（优先使用，避免被默认转换器覆盖）
        converters.add(0, customConverter);
    }
}
```

3. 关键注意点

- **转换器优先级**：Spring MVC 默认有 8 个内置消息转换器，若直接`add`自定义转换器，会排在最后，无法生效。需通过`add(0, customConverter)`将其设为第 1 位，确保优先使用。
- **全局生效范围**：所有返回给前端的`LocalDateTime`类型数据，都会自动按`JacksonObjectMapper`中定义的格式序列化，无需额外配置。

4. 优缺点

| 优点                                           | 缺点                                                     |
| ---------------------------------------------- | -------------------------------------------------------- |
| 一次配置，全局生效，无代码冗余                 | 实现步骤较局部注解复杂，需理解消息转换器原理             |
| 格式统一，后期维护方便（修改一处即可全局生效） | 灵活度较低，若需特殊格式需额外处理（可结合局部注解覆盖） |

三、辅助知识点

1. 序列化与反序列化

- **序列化**：Java 对象→JSON 字符串（如`LocalDateTime`→"2024-05-20 14:30"），对应前端接收数据的格式。
- **反序列化**：JSON 字符串→Java 对象（如前端传递的日期字符串→`LocalDateTime`），对应后端接收前端参数的格式。
- 自定义`JacksonObjectMapper`同时配置了序列化器和反序列化器，确保前后端日期交互一致性。

2. 配置类规范

Spring MVC 的 Web 层配置类需继承`WebMvcConfigurationSupport`，通过重写父类方法（如`extendMessageConverters`）扩展框架功能，这是 Spring MVC 的标准扩展方式。

3. 功能测试与验证

- 两种方案实现后，需重启项目，通过接口测试工具（如 Postman）或前端页面验证：
  - 方案 1：`createTime`格式正常，`updateTime`格式异常（对比效果）。
  - 方案 2：`createTime`和`updateTime`格式均正常（全局生效）。



### 第三节 启用/禁用员工账号

- **构建器（Builder）** 是一种设计模式（属于创建型模式），核心作用是**简化复杂对象的创建过程**，尤其适用于 “属性多、创建逻辑复杂、需保证对象完整性” 的场景。它通过 “分步设置属性、统一构建对象” 的方式，解决了传统 `new 对象+setter` 模式的代码冗余、属性漏设、对象状态不一致等问题。

一、为什么需要构建器？—— 解决传统创建方式的痛点

先看一个场景：假设我们有一个 `Employee` 实体类，包含 `id`、`name`、`status`、`phone`、`email` 等多个属性。传统创建对象的方式是这样的：

```java
// 传统方式：new + 多次setter
Employee employee = new Employee();
employee.setId(14L);
employee.setStatus(0);
employee.setName("张三");
employee.setPhone("13800138000");
employee.setEmail("zhangsan@xxx.com");
```

这种方式的问题很明显：

1. **代码冗余**：属性越多，`setter` 调用越频繁，代码越长；
2. **对象状态不完整**：若忘记调用某个关键 `setter`（如 `setStatus`），会导致对象处于 “不合法状态”；
3. **可读性差**：无法一眼看出 “这个对象到底设置了哪些属性”，需逐行查看 `setter`。

而用**构建器模式**，可以把上述代码优化为：

```java
// 构建器方式：链式调用，一步完成
Employee employee = Employee.builder()
    .id(14L)
    .status(0)
    .name("张三")
    .phone("13800138000")
    .email("zhangsan@xxx.com")
    .build(); // 最终构建对象
```

代码更简洁、可读性更强，且能强制保证对象创建的完整性（需调用 `build()` 才能得到最终对象）。

二、构建器的核心原理：两步走

构建器的实现逻辑本质是 “拆分对象创建为‘属性设置’和‘最终构建’两个阶段”，核心包含两个角色：

1. **目标对象（Product）**：即我们要创建的复杂对象（如 `Employee`）；
2. **构建器（Builder）**：负责 “接收属性参数、组装对象” 的工具，通常是目标对象的**静态内部类**（也可独立存在）。

**依赖注解自动生成**：手动编写构建器会产生大量重复代码（每个属性都要写设置方法），因此实际开发中常用 **Lombok 框架**的 `@Builder` 注解，一键自动生成构建器，无需手动编写

- 在实体类上添加 `@Builder` 注解

```java
import lombok.Builder;
import lombok.Getter;

@Builder // 自动生成构建器
@Getter  // 自动生成getter（可选，根据需求添加）
public class Employee {
    private Long id;
    private String name;
    private Integer status;
    private String phone;
    private String email;
}
```

> 注意：Lombok 的 `@Builder` 还支持更多特性，比如用 `@Builder.Default` 给属性设置默认值（如 `@Builder.Default private Integer status = 1`），避免未设置时为 `null`。



### 第四节 公共字段自动填充

一、核心背景：公共字段的定义与业务场景

1. 公共字段的范围

在`苍穹外卖`项目的多张业务表中（如员工表、分类表、后续的菜品表、套餐表），存在**4 个通用字段**，无需针对每张表单独开发赋值逻辑：

- `create_time`：数据创建时间
- `create_user`：数据创建人（通常关联当前登录用户 ID）
- `update_time`：数据最后修改时间
- `update_user`：数据最后修改人（通常关联当前登录用户 ID）

2. 原有方案的问题（代码冗余）

传统开发中，对上述字段的赋值需在**每个业务模块的 Service 层手动编写**，例如：

- 新增员工时：`employee.setCreateTime(new Date()); employee.setCreateUser(currentUserId);`
- 新增分类时：`category.setCreateTime(new Date()); category.setCreateUser(currentUserId);`
- 问题：重复代码多、后期表结构变更需修改所有相关代码、维护成本高。

二、关键分析：公共字段的操作时机

不同公共字段需在**不同数据库操作类型**下赋值，需先明确 “操作类型 - 字段” 的对应关系，避免无效赋值：

| 公共字段      | 对应操作类型（数据库 SQL）     | 说明                                           |
| ------------- | ------------------------------ | ---------------------------------------------- |
| `create_time` | INSERT（插入）                 | 仅在数据首次插入时赋值，后续不修改             |
| `create_user` | INSERT（插入）                 | 仅在数据首次插入时赋值，后续不修改             |
| `update_time` | INSERT + UPDATE（插入 + 更新） | 插入时赋值 “创建时间”，更新时覆盖为 “当前时间” |
| `update_user` | INSERT + UPDATE（插入 + 更新） | 插入时赋值 “创建人”，更新时覆盖为 “当前修改人” |

三、实现思路：四步解决重复赋值问题

核心逻辑是 **“通过注解标识目标方法，用 AOP 统一拦截并反射赋值”**，具体步骤如下：

1. 步骤 1：定义自定义注解（标识需要处理的方法）

- 作用：作为 “开关”，仅拦截添加了该注解的持久层（Mapper）方法，避免拦截查询（SELECT）等无需赋值的操作。
- 示例：可定义`@AutoFill`注解，用于标记 Mapper 中的`insert`或`update`方法，明确当前操作类型（如`@AutoFill(type = OperationType.INSERT)`）。

2. 步骤 2：定义操作类型枚举（区分 INSERT/UPDATE）

- 作用：明确当前拦截的方法是 “插入” 还是 “更新”，以便针对性赋值（如 INSERT 需处理 4 个字段，UPDATE 仅需处理 2 个字段）。

- 示例：

  ```java
  public enum OperationType {
      INSERT,  // 插入操作
      UPDATE   // 更新操作
  }
  ```

3. 步骤 3：编写 AOP 切面（统一拦截与赋值）

- 核心技术：Spring AOP（面向切面编程），通过 “环绕通知” 或 “前置通知” 拦截目标方法。
- 切面逻辑：
  1. **拦截目标**：拦截所有添加了`@AutoFill`注解的 Mapper 方法；
  2. **获取操作类型**：从注解中提取`OperationType`（INSERT/UPDATE）；
  3. **获取参数对象**：获取 Mapper 方法中传入的业务实体（如 Employee、Category）；
  4. **反射赋值**：通过 Java 反射技术，为实体的公共字段设置值（如当前时间、当前登录用户 ID）。

4. 步骤 4：Mapper 方法添加注解（最终使用）

- 在 Mapper 接口的`insertXXX`或`updateXXX`方法上添加`@AutoFill`注解，指定操作类型，无需修改 Service 层代码即可自动触发字段填充。

- 示例：

  ```java
  // 新增员工时，自动填充4个公共字段
  @Insert("insert into employee(...) values(...)")
  @AutoFill(type = OperationType.INSERT)
  void insert(Employee employee);
  
  // 更新员工时，自动填充2个公共字段（update_time、update_user）
  @Update("update employee set ... where id=#{id}")
  @AutoFill(type = OperationType.UPDATE)
  void update(Employee employee);
  ```



### 第五节 文件上传

一、业务背景与接口范围

**文件上传的业务流程**：前端浏览器 → 后端服务（接收图片） → 调用阿里云 OSS API → 图片存储到 OSS → 后端返回图片在线 URL → 前端使用 URL 展示 / 提交菜品信息。

二、阿里云 OSS 配置与环境隔离

阿里云 OSS 是对象存储服务，需配置访问密钥、存储桶信息等，且需区分**开发环境（dev）** 和**生产环境（prod）** ，避免硬编码。

1. 配置文件设计（YAML）

（1）主配置文件（application.yml）

通过 “引用外部配置” 的方式，避免直接写敏感信息，格式如下

```yaml
sky:
  alioss:
    endpoint: ${sky.alioss.endpoint}        # OSS服务端点（如oss-cn-beijing.aliyuncs.com）
    access-key-id: ${sky.alioss.access-key-id}  # 阿里云访问密钥ID
    access-key-secret: ${sky.alioss.access-key-secret}  # 阿里云访问密钥Secret
    bucket-name: ${sky.alioss.bucket-name}  # OSS存储桶名称（需提前在阿里云控制台创建）
```

（2）环境配置文件（application-dev.yml）

在开发环境配置文件中填写具体值（生产环境在 application-prod.yml 中配置），示例：

```yaml
sky:
  alioss:
    endpoint: oss-cn-beijing.aliyuncs.com
    access-key-id: LTAI5txxxxxxxxx（替换为实际密钥）
    access-key-secret: 8xxxxxxxxxxxxxxxx（替换为实际Secret）
    bucket-name: sky-takeout-itcast（替换为实际存储桶名）
```

2. 配置属性类（Configuration Properties）

通过`@ConfigurationProperties`注解，将 YAML 中的配置自动封装为 Java 对象，便于代码中引用：

- 创建`AliOssProperties`类，放在`common.properties`包下；
- 类注解：`@Component`（注入 Spring 容器） + `@ConfigurationProperties(prefix = "sky.alioss")`（指定配置前缀，与 YAML 中的 “sky.alioss” 对应）；
- 成员变量：`endpoint`、`accessKeyId`、`accessKeySecret`、`bucketName`（**驼峰命名**，Spring Boot 自动将 YAML 中的 “横线分隔命名”（如 access-key-id）转换为驼峰命名）；
- 生成 getter/setter 方法（或用`@Data`注解简化）。

四、OSS 工具类与配置类

需封装 OSS 上传逻辑为工具类，并通过 Spring 配置类创建工具类实例，确保全局唯一。

1. OSS 工具类（AliOssUtil）

已提前封装，核心功能是 “将`MultipartFile`上传到 OSS 并返回图片 URL”，关键逻辑：

- 构造方法：接收`endpoint`、`accessKeyId`、`accessKeySecret`、`bucketName` 4 个参数，初始化 OSS 客户端；`upload`方法：
  1. 将`MultipartFile`转换为输入流（`file.getInputStream()`）；
  2. 生成唯一的文件名（避免重复覆盖，如 “20240520/abc123.jpg”）；
  3. 调用 OSS 客户端的`putObject`方法上传文件；
  4. 拼接图片 URL：格式为`https://${bucketName}.${endpoint}/${fileName}`（如https://sky-takeout-itcast.oss-cn-beijing.aliyuncs.com/20240520/abc123.jpg），作为方法返回值。

2. OSS 配置类（OssConfiguration）

通过配置类创建`AliOssUtil`实例，交给 Spring 容器管理，确保单例：

- 类注解：`@Configuration`（标识为配置类） + `@Slf4j`（日志）；

- 方法：创建`aliOssUtil`方法，标注`@Bean`（将方法返回值注入容器），参数注入`AliOssProperties`（Spring 自动注入配置属性对象）；

- 单例保证：添加`@ConditionalOnMissingBean`注解，确保容器中仅存在一个`AliOssUtil`实例（避免重复创建）；

- 方法逻辑：

  ```java
  @Bean
  @ConditionalOnMissingBean
  public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties) {
      log.info("开始创建阿里云OSS工具类对象");
      return new AliOssUtil(
          aliOssProperties.getEndpoint(),
          aliOssProperties.getAccessKeyId(),
          aliOssProperties.getAccessKeySecret(),
          aliOssProperties.getBucketName()
      );
  }
  ```



### 第六节 配置类

在 Spring Boot 开发中，**配置属性类（Configuration Properties Class）** 是专门用于 “将配置文件（如 application.yml、application.properties）中的配置项，自动映射为 Java 对象” 的类。它的核心作用是**消除硬编码、统一管理配置**，让代码更优雅、可维护（尤其适合多环境配置、大量配置项的场景）。

一、为什么需要配置属性类？

先看一个 “没有配置属性类” 的痛点场景：

如果项目需要使用阿里云 OSS，配置文件（application.yml）中会有以下配置：

```yaml
sky:
  alioss:
    endpoint: oss-cn-beijing.aliyuncs.com
    access-key-id: LTAI5txxxxxxxxx
    access-key-secret: 8xxxxxxxxxxxxxxxx
    bucket-name: sky-takeout-itcast
```

若不使用配置属性类，要在代码中获取这些配置，只能通过`@Value`注解逐个注入：

```java
// 逐个注入，配置项越多越繁琐
@Value("${sky.alioss.endpoint}")
private String ossEndpoint;

@Value("${sky.alioss.access-key-id}")
private String ossAccessKeyId;

@Value("${sky.alioss.access-key-secret}")
private String ossAccessKeySecret;

@Value("${sky.alioss.bucket-name}")
private String ossBucketName;
```

这种方式的问题很明显：

- 配置项多时，需要写大量重复的`@Value`注解，代码冗余；
- 配置项分散在多个类中，难以统一管理；
- 没有类型校验（如配置项是数字却填了字符串，编译时无法发现）。

而**配置属性类**能解决这些问题：它将同一前缀的配置项（如`sky.alioss`）封装成一个 Java 对象，通过一次注入即可使用所有配置，且支持类型校验、默认值设置等功能。

二、配置属性类的核心特性与使用规则

1. 核心注解（必须掌握）

配置属性类的功能依赖 Spring Boot 提供的 2 个核心注解：

| 注解                               | 作用                                                         | 注意事项                                                     |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `@ConfigurationProperties`         | 标识该类为 “配置属性类”，指定配置文件中对应的**前缀**（如`prefix = "sky.alioss"`），Spring Boot 会自动将前缀下的配置项映射到类的成员变量 | 前缀必须与配置文件中的层级完全匹配（如配置是`sky.alioss.endpoint`，前缀就是`sky.alioss`） |
| `@Component`（或`@Configuration`） | 将配置属性类注入到 Spring 容器中，使其成为一个 Bean，供其他类通过`@Autowired`注入使用 | 若不注入容器，配置属性类无法被 Spring 管理，映射会失效       |

2. 命名映射规则（关键细节）

配置文件中的配置项（如`access-key-id`）是 “横线分隔命名”（kebab-case），而 Java 类的成员变量是 “驼峰命名”（camelCase），Spring Boot 会**自动完成两者的映射**，规则如下：

- 配置文件：`sky.alioss.access-key-id` → 对应 Java 变量：`accessKeyId`
- 配置文件：`sky.alioss.bucket-name` → 对应 Java 变量：`bucketName`

只需保证 “去掉横线后首字母小写，后续单词首字母大写” 即可，无需额外配置。

3. 必备要素

一个合法的配置属性类必须包含 3 个要素：

1. **成员变量**：与配置文件中的配置项一一对应（名称满足映射规则，类型一致，如配置是字符串则变量用`String`）；
2. **Getter/Setter 方法**：Spring Boot 通过 Setter 方法给成员变量赋值（若用 Lombok 的`@Data`注解，可自动生成 Getter/Setter，简化代码）；
3. **配置前缀**：通过`@ConfigurationProperties(prefix = "...")`指定，确保 Spring 能找到对应的配置项。



三、实战案例

1. 第一步：引入依赖，Spring Boot 的配置属性功能依赖`spring-boot-configuration-processor`（可选，但能提供 IDE 自动提示），在`pom.xml`中添加：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```

2. 第二步：编写配置属性类（AliOssProperties）

```java
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

// 1. 注入Spring容器（@Component）
@Component
// 2. 指定配置前缀（对应application.yml中的"sky.alioss"）
@ConfigurationProperties(prefix = "sky.alioss")
// 3. Lombok的@Data：自动生成Getter/Setter、toString等方法（替代手动编写）
@Data
public class AliOssProperties {
    // 成员变量：与配置项一一对应（名称满足驼峰-横线映射规则）
    private String endpoint;          // 对应配置项：sky.alioss.endpoint
    private String accessKeyId;       // 对应配置项：sky.alioss.access-key-id
    private String accessKeySecret;   // 对应配置项：sky.alioss.access-key-secret
    private String bucketName;        // 对应配置项：sky.alioss.bucket-name
}
```

3. 第三步：使用配置属性类

在需要用到 OSS 配置的类（如`OssConfiguration`）中，通过`@Autowired`直接注入`AliOssProperties`对象，即可获取所有配置项：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import lombok.extern.slf4j.Slf4j;

@Configuration
@Slf4j
public class OssConfiguration {

    // 注入配置属性类（Spring自动提供Bean）
    @Autowired
    private AliOssProperties aliOssProperties;

    // 创建OSS工具类实例（依赖配置属性类的参数）
    @Bean
    public AliOssUtil aliOssUtil() {
        log.info("初始化阿里云OSS工具类，配置：{}", aliOssProperties);
        // 直接从配置属性类中获取参数，无需逐个注入
        return new AliOssUtil(
            aliOssProperties.getEndpoint(),
            aliOssProperties.getAccessKeyId(),
            aliOssProperties.getAccessKeySecret(),
            aliOssProperties.getBucketName()
        );
    }
}
```